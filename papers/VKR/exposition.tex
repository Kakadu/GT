\section{Exposition}
\label{expo}

В этом разделе мы постепенно представим наш подход используя несколько примеров. 
Хотя изложение не предоставляет конкретных деталей и не может использоваться как точная спецификация,
мы здесь предоставляем основные составляющие решения и мотивацию, которая привела к ним.
Далее мы будет использовать следующее соглашение: будем обозначать $\inbr{\dots}$ представление некоторого понятия в конкретном синтаксисе языка \textsc{OCaml}. Например, ``$\inbr{f_t}$`` является обозначением конкретной функции индексированной типом  ``$f$'' for a type ``$t$''. 
В конкретном синтаксисе оно может быть выражено как ``\lstinline{f_t}'', но мы пока воздержимся от указания конкретной формы.

Начнем с простого примера. Рассмотрим такое объявление типа арифметических выражений:

\begin{lstlisting}
   type expr =
   | Const of int
   | Var   of string
   | Binop of string * expr * expr
\end{lstlisting}

Рекурсивная функция ``$\inbr{show_{expr}}$'' (наиболее естественный кандидат на реализацию)
преобразует выражение в строку: 

\begin{lstlisting}
   let rec $\inbr{show_{expr}}$ = function
   | Const  n        -> "Const " ^ string_of_int n
   | Var    x        -> "Var " ^ x
   | Binop (o, l, r) ->
      Printf.sprintf "Binop (%S, %s, %s)" o ($\inbr{show_{expr}}$ l) ($\inbr{show_{expr}}$ r)
\end{lstlisting}

Представление, возвращаемое ``$\inbr{show_{expr}}$'', сохраняет имена конструкторов. Оно может быть
полезно приотладке или сериализации. Однако, как правило, также требуется иное, ``красивое''(\emph{pretty-printed}) представление. 
В этом представлении выражение представляется в ``естественном синтаксе'' с использованием инфиксных операций и без имён 
конструкторов, где скобки расставлены только там, где они действительно нужны. Мы можем реализовать это преобразование 
очень просто:

\begin{lstlisting}
   let $\inbr{pretty_{expr}}$ e =
     let rec pretty_prio p = function
     | Const  n        -> string_of_int n
     | Var    x        -> x
     | Binop (o, l, r) ->
        let po = prio o in
        (if po <= p then br else id) @@
        pretty_prio po l ^ " " ^ o ^ " " ^ pretty_prio po r
     in
     pretty_prio min_int e
\end{lstlisting}

Здесь мы пользуемся функциями ``\lstinline{prio}'', ``\lstinline{br}'' и ``\lstinline{id}'', доступными из вне. Функция ``\lstinline{prio}''
возвращает приоритет бианрной операции, ``\lstinline{br}'' окружает свой аргумент скобками, а ``\lstinline{id}'' --- тождественная функция.
Дополнительная функция ``\lstinline{pretty_prio}'' принимает числовой параметр, который обозначает приоритет окружающей операции (если такая имеется). Если приоритет текущей опреации меньше или равен переданному, тогда выражение окружается скобками. Для простоты мы считаем, что все операции неассоциативны, но такой же шаблон кода может быть использован для поддержки ассоциативных операций.
На верхнем уровне мы передаем наименьшее возможное число как приоритеть, чтобы убедиться, что мы не получим скобок, окружающих выражение целиком 

Реализации этих двух функций имеют очень мало общего. Обе возращаеют строки, но вторая принимает дополнительный аргумент, и 
правые части сопоставления с образцом для соответвующих конструкторов различаются. Единственной общей частью является
сопоставление с образцом само по себе. Мы может извлечь его в отдельную функцию и параметризовать эту функцию множеством трансформаций, 
соответсвующих конструкторам:

\begin{lstlisting}
   let $\inbr{gcata_{expr}}$ $\omega$ $\iota$ = function
   | Const n         -> $\omega$#$\inbr{Const}$ $\iota$ n
   | Var   x         -> $\omega$#$\inbr{Var}$   $\iota$ x
   | Binop (o, l, r) -> $\omega$#$\inbr{Binop}$ $\iota$ o l r
\end{lstlisting}

Здесь мы представляем множетсво семантически связанных функций объектом. ``$\omega$'' -- это объект, где методы соответсвуют конструктором
один к одному. ``$\iota$'' представляет дополнительный параметр, который может использоваться функциями как, например, ``$\inbr{pretty_{expr}}$'' (и игнорироваться фукнциями на подобие ``$\inbr{show_{expr}}$'').

Упомянутая в начале фукция ``$\inbr{show_{expr}}$'' может быть выражена следующим образом\footnote{Для ясности понимания мы опустили некоторые аннотации типов, которые помогают этому листингу кода пройти проверку типов.}:

\begin{lstlisting}
   let rec $\inbr{show_{expr}}$ e = $\inbr{gcata_{expr}}$
     object
       method $\inbr{Const}$ _ n   = "Const " ^ string_of_int n
       method $\inbr{Var}$  $\enspace$   _ x   = "Var " ^ x
       method $\inbr{Binop}$ _ o l r =
         Printf.sprintf "Binop (%S, %s, %s)" o ($\inbr{show_{expr}}$ l) ($\inbr{show_{expr}}$ r)
     end
     ()
     e
\end{lstlisting}

И, разумеется, всё то же  самое применимо к функции $\inbr{pretty_{expr}}$.

Вы могли заметить, что оба объекта, необходимые для реализации этих функций, могут быть созданы с помощью общего виртуального класса:

\begin{lstlisting}
   class virtual [$\iota$, $\sigma$] $\inbr{expr}$ =
   object
     method virtual $\inbr{Const}$ : $\iota$ -> int -> $\sigma$
     method virtual $\inbr{Var}\enspace\;\;$ : $\iota$ -> string -> $\sigma$
     method virtual $\inbr{Binop}$ : $\iota$ -> string -> expr -> expr -> $\sigma$  
   end
\end{lstlisting}

Конкретный класс, представляющий преобразование будет наследоваться от этого общего предка. Чтобы иметь возможность 
вызывать рекурсивно данное преобразование, мы параметризуем класс функцией самотрансформации ``\lstinline{fself}'' 
(\emph{открытая рекурсия}). 
Написание в стиле открытой рекурсии необходимо для возможности поддержки полиморфных вариантных типов и рекурсивных определений.
Теперь мы сможем релаизовать логику распечатки в формат, удобный человеку, в изоляции, отдельно от фукнции ``красивой'' распечатки
 (обратите внимание на использование ``\lstinline{fself}''):

\begin{lstlisting}
   class $\inbr{pretty_{expr}}$ (fself : $\iota$ -> expr -> $\sigma$) =
   object inherit [int, string] $\inbr{expr}$ 
     method $\inbr{Const}$ p n = string_of_int n
     method $\inbr{Var}$ p x = x
     method $\inbr{Binop}$ p o l r =
       let po = prio o in
       (if po <= p then fun s -> "(" ^ s ^ ")" else fun s -> s) @@
       fself po l ^ " " ^ o ^ " " ^ fself po r
   end
\end{lstlisting}

Функция распечатки в удобный человеку формат может быть легко описана с использованием класса выше и функции обощенной 
трансформации\footnote{Так как имена функции и классов находятся в разных пространствах имен в \textsc{OCaml}, мы может 
использовать одно и то же имя для класса и функции трансформации.}:

\begin{lstlisting}
   let $\inbr{pretty_{expr}}$ e =
     let rec pretty_prio p e = $\inbr{gcata_{expr}}$ (new $\inbr{pretty_{expr}}$ pretty_prio) p e in
     pretty_prio min_int e
\end{lstlisting}

Также мы может избежать объявления вложенной функции с помощью комбинатора неподвижной точки ``\lstinline{fix}'':

\begin{lstlisting}
   let $\inbr{pretty_{expr}}$ e =
     fix (fun fself p e -> $\inbr{gcata_{expr}}$ (new $\inbr{pretty_{expr}}$ fself) p e) min_int e
\end{lstlisting}

Выше мы смогли выделить две общие чатси для двух существенно различных преобразований: функцию обобщенного обхода
(``$\inbr{gcata_{expr}}$'') и такой виртуальный класс (``$\inbr{expr}$''), что все трансформации можно представить как его экземпляры.
Но стоило ли это того? В действительности, в этом примере мы добились не очень большого переиспользования кода путём добавления
большого количества абстракций. Итоговый код получился по размеру даже больше исходного.

We argue that in this particular case the transformations were not general enough. In order to justify our approach we consider another, more optimistic scenario. It is
well-known, that many transformations can be represented (and for a good reason) using \emph{catamorphisms}, or ``folds''~\cite{Fold,Bananas,CalculatingFP}. Technically, to
implement regular catamorphism we would need to abstract the type ``\lstinline{expr}'' of itself to make it a proper functor, but for now we stick with a more
lightweight version:

\begin{lstlisting}
   class [$\iota$] $\inbr{fold_{expr}}$ (fself : $\iota$ -> expr -> $\iota$) =
   object inherit [$\iota$, $\iota$] $\inbr{expr}$ 
     method $\inbr{Const}$ i n = i
     method $\inbr{Var}$ i x = i
     method $\inbr{Binop}$ i o l r = fself (fself i l) r
   end
\end{lstlisting}

This implementation simply threads the argument ``\lstinline{i}'' through all nodes of an expression and returns it unchanged. This seems pretty useless at a first
glance. However, if we modify this default behaviour a little, we can obtain something useful:

\begin{lstlisting}
   let fv e =
     fix (fun fself i e ->
            $\inbr{gcata_{expr}}$ (object inherit [string list] $\inbr{fold_{expr}}$ fself
                         method $\inbr{Var}$ i x = x :: i
                       end) i e
         ) [] e
\end{lstlisting}

This function calculates the list of all free variables in an expression (as there can be no binders this is simply the list of all variables). Immediate object we
construct here inherits from the ``useless'' ``$\inbr{fold_{expr}}$'' and redefines only one method~--- for variables. All other code makes exactly what we need~---
``$\inbr{gcata_{expr}}$'' traverses the expression, and all other methods of transformation object accurately pass the list of variables through. So, we indeed
managed to implement some interesting transformation with a very small modification of existing code (provided that ``$\inbr{fold_{expr}}$'' class was already supplied).
To avoid the impression that we carefully prepared everything to implement this particular example we can show another one:

\begin{lstlisting}
   let height e =
     fix (fun fself i e ->
            $\inbr{gcata_{expr}}$ (object inherit [int] $\inbr{fold_{expr}}$ fself
                         method $\inbr{Binop}$ i _ l r = 1 + max (fself i l) (fself i r) 
                       end) i e
         ) 0 e
\end{lstlisting}

Now we calculated the height of an expression. We used the same ``$\inbr{fold_{expr}}$'' class as a base for another immediate object; we redefined the method for
binary operators, which now calculates the heights of both sub expressions, takes the maximum and adds one. 

Another commonly recognised generic feature is ``map'':

\begin{lstlisting}
   class $\inbr{map_{expr}}$ fself =
   object inherit [unit, expr] $\inbr{expr}$
     method $\inbr{Var}$ _ x = Var x
     method $\inbr{Const}$ _ n = Const n
     method $\inbr{Binop}$ _ o l r = Binop (o, fself () l, fself () r)
   end
\end{lstlisting}

Again, as type ``\lstinline{expr}'' is not a functor, all we can do with ``$\inbr{map_{expr}}$'' is copying. However, by inheriting from it we
can provide more transformations:

\begin{lstlisting}
   class simplify fself =
   object inherit $\inbr{map_{expr}}$ fself
     method $\inbr{Binop}$ _ o l r =
       match fself () l, fself () r with
       | Const l, Const r -> Const ((op o) l r)
       | l      , r       -> Binop (o, l, r)     
   end
\end{lstlisting}

This class performs a constant folding: if both arguments of a binary operator are reduced (by the same transformation) to constants, then in
performs the operation. The function ``\lstinline{op}'' is defined elsewhere; it returns an integer function for evaluating given binary operator. One more:


\begin{lstlisting}
   class substitute fself state =
   object inherit $\inbr{map_{expr}}$ fself
     method $\inbr{Var}$ _ x = Const (state x)  
   end
\end{lstlisting}

This one substitutes variables in an expression with their values in some state, represented as function ``\lstinline{state}''. Two last
classes can be seamlessly combined to construct an evaluator:

\begin{lstlisting}
   class eval fself state =
   object
     inherit substitute fself state
     inherit simplify   fself
   end

   let eval state e =
     fix (fun fself i e -> $\inbr{gcata_{expr}}$ (new eval fself state) i e) () e  
\end{lstlisting}

In all these examples we, starting from some very common generic feature, implemented all needed transformations with a very little efforts (modulo
the verbose \textsc{OCaml} syntax for objects and classes). In each case we needed to override only one method, and we used a single per-type generic
function. On the other hand we dealt with a very simple type~--- for example, it was not even polymorphic, and supporting polymorphism might have
its own issues. In the rest of the paper we show that, indeed, the sketch we presented here can be extended to a generic programming
framework, in which all the components can be synthesised from type definitions. In particular, our approach provides the full support for:

\begin{itemize}
\item Polymorphism.
\item Type constructor application.
\item Mutual recursion. While there is no problem with implementation of hard-coded generic transformations, the implementation of \emph{extensible} ones
  requires extra efforts.
\item Polymorphic variant types. It includes the seamless integration via class inheritance of all features
  for polymorphic variant types when these types are combined into the one.
\item Separate compilation: we can generate code from type definitions for a module separately with no lookup into
  modules this one depends on.
\item Encapsulation: we support module signatures, including abstract and private type declarations. Generic functions, implemented for
  abstract types, can be safely used outside the module, but can be neither modified nor used to ``peep'' at the internal structure of
  the type.  
\end{itemize}

We also address some performance issues~--- as one could notice, in all preceding examples we created a whole bunch of \emph{identical} objects during a
transformation (one per each node of a data structure); as we will see, this can be avoided via memoization. Finally, our framework provides a plugin system which can be
used to generate a number of useful transformations (like ``\lstinline{show}'', ``\lstinline{fold}'' or ``\lstinline{map}''). The plugin system is
extensible as well~--- end users can implement their own plugins with a very little amount of extra effort since a large part of their functionality (the traversal
function and virtual transformation class) is already supplied by the framework. 
