\section{Implementation}
\label{sec:implementation}

Основными компонентами нашего решения являются синтаксические расширения (и для \cd{camlp5}~\cite{Camlp5}, и для  \cd{ppxlib}~\cite{PPXLib}), библиотека времени исполнения и система плагинов. Синтаксичесое расширение касается объявлений типов, аннотированных пользователем, и генерирует следующие сущности:


\begin{itemize}
\item обощенная функция трансформации (одна на каждый тип);
\item виртуальный класс, который используется как общий предок для всех трансформаций (один на каждый тип);
\item некоторое количество конкретных классов (по одному на каждый вид плагина);
\item структуру данных \emph{typeinfo}, котора содержит в себе информацию, специфичную для данного типа, а именно обощенную функцию трансформации и набор функций трансформации, которые порождаются плагинам. Всё представлено как самостоятельный объект.
\end{itemize}

Мы поддерживаем большинство вариантов в правой части объявлений типов со следующими ограничениями:

\begin{itemize}
\item поддерживаются только регулярные алгебраические типы данных; GADT'ы обрабатываются как обычные алгебраические типы;
\item констрейты не учитываются;
\item объекты, модули и типы с ключевым словом ``\lstinline{nonrec}'' не поддерживаются;
\item расширяемые типы данных (``\lstinline{...}''/``\lstinline{+=}'') не поддерживаются.
\end{itemize}

К примеру, если к типу ``\lstinline{t}'' применить плагин ``\lstinline{show}'', то в файле реализации сгенерируются следующие сущности (``$\dots$'' обзначают части, объяснение которых мы пока опускаем):

\begin{figure}[t]
  \center
  \begin{tabular}{l|l}
    \hline
    \multicolumn{2}{c}{\cd{camlp5} version}\\
    \hline
    \lstinline|@type ... $[$ with  $p_1, p_2, \dots$ $]$| & синтаксическая конструкция для обработки типа  \\
                                                         & с плагинами $p_1, p_2, \dots$; взаимно рекурсвные \\
                                                         & типы также поддерживаются  \\
    \lstinline|@$typ$| & название виртуального класса для типа $typ$ \\
    \lstinline|@$plugin$[$typ$]| & имя класса плагина для типа $typ$ и \\
                                 & плагина $plugin$\\
    \hline
        \multicolumn{2}{c}{\cd{ppxlib} version}\\
    \hline
    \lstinline|type ... = ...|  & синтаксическая конструкция для обработки типа  \\
    \lstinline|and  ... = ...|  & с плагинами $p_1, p_2, \dots$ \\
    \lstinline|[@@deriving gt ~options:{ $p_1, p_2, \dots$}]|
  \end{tabular}
  \caption{Конструкции расширенного синтаксиса}
  \label{syntax}
\end{figure}

\begin{lstlisting}
   let $\inbr{gcata_t}$ $\dots$ = $\dots$
   
   class virtual [$\dots$] $\inbr{t}$ =
   object
     $\dots$
   end

   class [$\dots$] $\inbr{show_t}$ $\dots$ =
   object inherit [$\dots$] $\inbr{t}$ $\dots$
     $\dots$
   end

   let t = {
     gcata   = $\inbr{gcata_t}$;
     $\dots$
     plugins = object
                 method show = $\dots$
               end
   }
\end{lstlisting}

С помощью структуры ``\lstinline{t}'' с информацией о типе мы можем симитировать фукнции трансформаций, индексированные типами :

\begin{lstlisting}
   let transform typeinfo = typeinfo.gcata
   let show      typeinfo = typeinfo.plugins#show
\end{lstlisting}

Функция ``\lstinline{transform(t)}'' -- это функция верхнего урочня из библиотеки, которая может быть инстанциирована для любого поддерживаемого типа  ``\lstinline{t}''. На рисунке~\ref{syntax} мы описываем конкретные синтаксические конструкции, реализованные как синстаксическое расширение. Обратите внимание, что конкретное представление имен для классов и функций трансформации (представленных выше как$\inbr{...}$) является несущественными пока используется \cd{camlp5}, так как предоставляется соответсвующее синтаксическое расширение.

\subsection{Типы трансформаций}

Дизайн бибилотеки основана на идеи описания катаморфизмов~\cite{Bananas} с помощью атрибутных 
грамматик~\cite{AGKnuth,AGSwierstra,ObjectAlgebrasAttribute}.
Вкратце, мы рассматриваем только трансформации следующего типа

\[
\iota \to t \to \sigma
\]

где $t$ -- это тип, значения которого мы преобразуем, $\iota$ и $\sigma$~--- типы \emph{наследуемых} и \emph{синтезируемых} атрибутов. 
Мы не будем исползовать атрибутные грамматики, чтобы описывать алгоритмическую часть трансформаций, мы только переиспользуем терминологию для описывания типов. 

Если рассматриваемый тип является параметрическим, то преобразование тоже будет параметрическим. Далее мы будет обозначать с помощью
$\left\{...\right\}$ множетсвенное вхождение сущности в скобках. С помощью такой нотации мы сможем описать обощенную форму преобразований, представимых с помощью нашей бибилотеки, как

\[
  \left\{\iota_i \to \alpha_i \to \sigma_i\right\}\to\iota \to\left\{\alpha_i\right\}\;t \to \sigma
\]

Здесь $\iota_i\to\alpha_i\to\sigma_i$ явяется фукнций-преобразованием для типового параметра $\alpha_i$. В общем, фукнции-трансформации структуры данных действуют на наследуемые атрибуты и конкретные значения и возвращают синтезируемые атрибуты для различных типов. Общий для всех преобразований класс-предок для $n$-параметрического типа имеет $3(n+1)$ типовых параметров:

\begin{itemize}
\item тройка $\iota_i$, $\alpha_i$, $\sigma_i$ для каждого типового параметра $\alpha_i$, где $\iota_i$ и $\sigma_i$ --- это типовые переменные для наследуемого и синтезированного атрибутов для преобразования  $\alpha_i$;
\item пара дополнительных типовых переменных $\iota$ и $\sigma$ для представления наследуемого и синтезрированного атрибутом трансформируемого типа;
\item дополнительная типовая переменная$\epsilon$, которая приравнивается к ``\lstinline|$\{\alpha_i\}$ t|'' для типов отличных от полиморфных вариантные, и приравнивается к \emph{открытому} типу ``\lstinline|[> $\{\alpha_i\}$ t]|'' для полиморфных вариантных типов (подробнее в 
разделе~\ref{pv}).
\end{itemize}

Например, если нам дан двупараметрический тип \lstinline{($\alpha$, $\beta$) t}, то заголовком общего класса-предка будет 

\begin{lstlisting}
  class virtual [$\iota_\alpha$, $\alpha$, $\sigma_\alpha$, $\iota_\beta$, $\beta$, $\sigma_\beta$, $\iota$, $\epsilon$, $\sigma$] $\inbr{t}$
\end{lstlisting}

Кокретные преобразования будут наследоваться от этого класса и, возможно, кокретизировать нектоорые из типовых параметров.
Дполпнительно, конкретные классы получают несколько аргументов-функций:

\begin{itemize}
\item $n$ функций, преобразующих типовые параметры: \lstinline|f$_{\alpha_i}$ : $\iota_i$ -> $\alpha_i$ -> $\sigma_i$|;
\item функция для реализации открытой рекурсии: \lstinline|fself : $\iota$ -> $\epsilon$ ->  $\sigma$|.
\end{itemize}

Например, для типа, упомянтого выше и преобразования ``\lstinline{show}'' заголовок конкретного лкасс будет выглядеть как

\begin{lstlisting}
  class [$\alpha$, $\beta$, $\epsilon$] $\inbr{show_t}$ 
    (f$_\alpha$ : unit -> $\alpha$ -> string)
    (f$_\beta$ : unit -> $\beta$ -> string)
    (fself : unit -> $\epsilon$ -> string) =
  object 
    inherit [unit, $\alpha$, string, unit, $\beta$, string, unit, $\epsilon$, string] $\inbr{t}$
    $\dots$
  end 
\end{lstlisting}

Обратите внимание, что мы поддерживаем это коглашение для всех типов, хотя для некоторых типов некоторые компоненты могут быть излишни, например, ``\lstinline{fself}''
нужен только для рекурсивных типов. Объяснение этому простое: если мы \emph{используем} некоторый тип
то мы в общем случае не знаем его определения. Следовательно, для поддержки раздельной компиляции интерфейсы всех сущностей должны иметь общую структуру.

Эта схема типизации выглядит очень многословной и неочевидной. Присутвует большое количество типовых парамертров в которых легко запутаться.
Однако, пользователям понадобится разбираться с ними только если они будут реализовывать преобразование \emph{вручную} с нуля путём 
наследования от общего класса-предка.
В большинстве случаем преобразование реализуется путём небольшой специализации конкретного плагина или используя систему плагинов. 
В первом случае многие типовые параметры будут уже специализрованя (например, для  ``\lstinline{show}'' большинство типовых параметров конкретизируется в базовые типы), во втором система плагинов упрощает процесс правильной конкретизации типовых параметром (подробнее в 
разделе~\ref{plugins}).

Нам также необходимо описать типы аргуметов у методов общего класса. Методадля коструктора  ``\lstinline|C of a$_1$ * a$_2$ * ... * a$_k$|'' имеет следующую сигнатуру:

\begin{lstlisting}
  method virtual $\inbr{C}$ : $\iota$ -> $\epsilon$ -> a$_1$ -> a$_2$ -> ... -> a$_k$ -> $\sigma$
\end{lstlisting}

Обратите внмание, метод принимает не только наследуемый атрибут и аргументы, соответствующие конструктору, но и значение, которое сейчас преобразуется.

Наконец, мы опишем тип обощенных функций преобразования. Тип слегка изменяется для случая полиморфных вариантных типов.


Для не типа, не являющегосяя полимрфным вариантным типом, с именем ``\lstinline|$\{\alpha_i\}$ t|'' обощенная функция трансформации имеет следующий тип:

\begin{lstlisting}
val $\inbr{gcata_t}$ : [$\{\iota_{\alpha_i}$, $\alpha_i$, $\sigma_{\alpha_i}\}$, $\iota$, $\{\alpha_i\}$ t, $\sigma$]#$\inbr{t}$ -> $\iota$ -> $\{\alpha_i\}$ t -> $\sigma$
\end{lstlisting}

Она принимает объект, представляющий преобразование, у которого типовые параметры, полученные путём наследования от базового класса, соответвующим образом конкретизированиы , наследуемый атрибут, значение, которое будет преобразовано и возвращает синтезируемый атрибут.
Дополнительный парметр ``$\epsilon$'' конкретизирется в обрабатываемый тип. 
Для полиморфных вариантных типов дополнительный параметр конкретизируется в \emph{открытую}
версию типа  (``\lstinline|[> $\{\alpha_i\}$ t]|''). 
Это позволяет применять функцию преобразования к объекту, представлящего преобразование расширенного типа с большим количество конструкторов.


\subsection{Комбинатор неподвижной точки и мемоизация}
\label{memofix}

В нашем подходе мы полагаемся  на открытую рекурсию: класс, реализующий конкретное преобразование принимает фукнцию преобразования самого себя как параметр.
Чтобы содать такую функцию необходим комбинатор неподвижной точки. В  этм разделе
мы рассмотрим только простой котакой комбинатор, а именно для одиночного объявления типа.
Во взаимно рекурсивном случае понадобится более сложная реализация (подробне в 
разделе~\ref{murec}).

Мы напоминаем вам пример из раздела~\ref{expo}:

\begin{lstlisting}
   let $\inbr{pretty_{expr}}$ e =
     fix (fun fself p e -> $\inbr{gcata_{expr}}$ (new $\inbr{pretty_{expr}}$ fself) p e) min_int e
\end{lstlisting}

Здесь присутисвует лямбда абстракци, тело которой вычисляется всякий раз, когда вызывается \lstinline{fself}'' в классе преобразования (по сути, для каждого узла в дереве трансформируемого значения). Так как все объекты одинаковы, то их создание можно соптимизировать.

Мы мемоизирует создания объекта, представляющего преобразование, с помощью ленивых вычислений. Для этого мы абстрагируем создание объекта в функцию, которая принимает
аргумент ``\lstinline{fself}''. Реализация комбинатора неподвижной точки выглядит следующим образом:

\begin{lstlisting}
   let fix gcata make_obj $\iota$ x =
     let rec obj = lazy (make_obj fself)
     and fself $\iota$ x = gcata (Lazy.force obj) $\iota$ x in
     fself $\iota$ x
\end{lstlisting}

Этот комбинатор может использоваться для всех типов и не является генерируемым по типу данных. Теперь мы может немного исправить объявление функции ``\lstinline{transform}'':

\begin{lstlisting}
   let transform typeinfo = fix typeinfo.gcata
\end{lstlisting}

С помощью этого определения пользователю не нужно использовать комбинатор неподвижной точки явно:

\begin{lstlisting}
   let $\inbr{show_{expr}}$ e =
     transform(expr) (fun fself -> new $\inbr{show_{expr}}$ fself) () e
\end{lstlisting}

\subsection{Система плагинов}
\label{plugins}

\begin{figure}[t]
  \center
  \small
  \begin{tabular}{ccp{4cm}}
    Название & Тип функции трансформации & Комментарий \\[3mm]
    \hline\\
    \lstinline|show| & \lstinline|$\{$ unit -> $\alpha_i$ -> string $\}$ -> unit -> $\{\alpha_i\}$ t -> string| & преобразование в строку\\[2mm]
    \lstinline|fmt| & \lstinline|$\{$ formatter -> $\alpha_i$ -> unit $\}$ -> formatter -> $\{\alpha_i\}$ t -> unit| & форматированый вывод с помощью модуля ``\lstinline|Format|'' \\[2mm]
    \lstinline|html| & \lstinline|$\{$ unit -> $\alpha_i$ -> HTML.t $\}$ -> unit  -> $\{\alpha_i\}$ t -> HTML.t| & преобразование в HTML представление \\[2mm]
    \lstinline|compare| & \lstinline| $\{$ $\alpha_i$ -> $\alpha_i$ -> comparison $\}$ -> $\{\alpha_i\}$ t -> $\{\alpha_i\}$ t -> comparison| & сравнение \\[2mm]
    \lstinline|eq| & \lstinline|$\{$ $\alpha_i$ -> $\alpha_i$ -> bool $\}$ -> $\{\alpha_i\}$ t -> $\{\alpha_i\}$ t -> bool| & проверка на равенство \\[2mm]
    \lstinline|foldl| & \lstinline |$\{$ $\alpha$ -> $\alpha_i$ -> $\alpha$ $\}$ -> $\alpha$ -> $\{\alpha_i\}$ t -> $\alpha$| & протаскивание наследуемого атрибута через все узлы сверху вниз \\[2mm]
    \lstinline|foldr| & \lstinline |$\{$ $\alpha$ -> $\alpha_i$ -> $\alpha$ $\}$ -> $\alpha$ -> $\{\alpha_i\}$ t -> $\alpha$| & протаскивание наследуемого атрибута через все узлы снизу вверх \\[2mm]
    \lstinline|gmap| & \lstinline|$\{$ unit -> $\alpha_i$ -> $\beta_i$ $\}$ -> unit -> $\{\alpha_i\}$ t -> $\{\beta_i\}$ t| & функтор %\\[2mm]
%    \lstinline|eval| & \lstinline|$\{$ $\epsilon$ -> $\alpha_i$ -> $\beta_i$ $\}$ -> $\epsilon$ -> $\{\alpha_i\}$ t -> $\{\beta_i\}$ t| & a variant of functor with an environment ``$\epsilon$'' passed through a transformation\\[2mm]
%    \lstinline|stateful| & \lstinline|$\{$ $\epsilon$ -> $\alpha_i$ -> $\epsilon$ * $\beta_i$ $\}$ -> $\epsilon$ -> $\{\alpha_i\}$ t -> $\epsilon$ * $\{\beta_i\}$ t| & similar to ``\lstinline|eval|'' but allows to update the environment on the way        
  \end{tabular}
  \caption{Список предоставляемых по-умолчанию плагинов}
  \label{listofplugins}
\end{figure}

Поведением по-умолчанию для нашей библиотеки является создание обощенной функции трансформации, обобщенного класса и струтуры с информацией о типе. Они не создает никаких конкретных встроенных преобразований. Все преобразования создаются \emph{плагинами}, а система плагинов позволяет пользователям реализоваывать их собственные.
Присутствует некоторое количество плагинов, поставляемых вместе с библиотекой 
(таблица~\ref{listofplugins}), но ни один из них не обрабатывается каким-то особым образом остальной частью библиотеки.

Каждый плагин реализован как динамически загружаемый объект, и чтобы создать плагин, разработчик должен правильно воспользоваться интерфейсом, предоставляемым библиотекой.
Аналогичный подход используется в нескольких уже существующих 
библиотеках~\cite{PPXLib,Yallop}, но, мы заявляем, что в нашем случае реализация плагинов выглядит несколько проще. Причиной этому является то, что конкретная и обобщенная части трансформаций разделены. Следовательно, создание плагина выливается только в правильное создание класса трансформации, что требует минимального вмешателства разработчика.
В общем случае, только следующая информация о новом плагине должна быть указана:

\begin{itemize}
\item Типы наследуемого и синтезируемого атрибутов для каждого параметра типа.
\item Типы наследуемого и синтезируемого атрибутов для самого преобразуемого типа.
\item Тело метода для преобразования конструкторов.
% \item Как будет выглядеть метод для структуры What the toplevel method of the typeinfo structure for the plugin is look like?
\end{itemize}

Итого, количетсво мест, где плагин генериует код для обработки типов довольно мало, а генерируемый код относительно прост. Интерфейс построения синтаксического дерева напоминает интерфес в \cd{ppxlib} (а именно, подмодуль \cd{Ast_builder}), который должен быть знаком всем, кто когда-то разрабатывал синтаксические расширения для \textsc{OCaml}
В разделе~\ref{pluginExample} мы представим полный пример создания свежей реализации плагина.

\subsection{Взаимная рекурсия}
\label{murec}

Полная поддержка взаимно рекурсивных определений типов требует дополнительных усилий.
Формально, создание всех необходимых сущностей может быть произведена также, как и для 
одиночного случая, но это может нарушить расширяемость получаемых преобразований.
Мы продемонстриуем это феномен в примере ниже. Рассмотрим определение типа


\begin{lstlisting}
   type expr = $\dots$ | LocalDef of def * expr
   and  def  = Def of string * expr
\end{lstlisting}

где мы опустили неважные части (переменные, бинарные операции и т.д.) в объявлении типа выражений. Довольно очевидно, что обобженные функции преобразований для обоих типов могут  быть оставлены как они есть, так как они по сути просто перекладывают работы про выполнению преобразования на плечи методов объекта и не зависят от наличия рекурсии в определениях типов.

\begin{lstlisting}
   let $\inbr{gcata_{expr}}$ $\omega$ $\iota$ = function
   $\dots$
   | LocalDef (d, e) as x -> $\omega$#$\inbr{LocalDef}$ $\iota$ x d e

   let $\inbr{gcata_{def}}$ $\omega$ $\iota$ = function
   | Def (s, e) as x -> $\omega$#$\inbr{Def}$ $\iota$ x s e
\end{lstlisting}

То же самое верно и для общего класса-предка. Однако, если мы начнем реализовывать сонкретные преобразования, то нам понадобится преобразование значений 
типа ``\lstinline{expr}'' внутри класса для ``\lstinline{def}'', и наоборот. Это может быть сделано с помощью взаимно рекурсивных определений классов (мы опять же опускаем неважные части кода):

\begin{lstlisting}
   class $\inbr{show_{expr}}$ fself = object 
     inherit [unit, _, string] $\inbr{expr}$ fself
     $\dots$
     method $\inbr{LocalDef}$ $\iota$ x d e =
       $\dots$ (fix $\inbr{gcata_{def}}$ (fun fself -> new $\inbr{show_{def}}$ fself) $\dots$) $\dots$
   end
   and $\inbr{show_{def}}$ fself = object 
     inherit [unit, _, string] $\inbr{def}$ fself
     method $\inbr{Def}$ $\iota$ x s e =
       $\dots$ (fix $\inbr{gcata_{expr}}$ (fun fself -> new $\inbr{show_{expr}}$ fself) $\dots$) $\dots$
   end
\end{lstlisting}

Заметьте, что в обоих аргументах ``\lstinline{fix}'' мы создаем \emph{конкретные} классы  (``$\inbr{show_{def}}$'' и ``$\inbr{show_{expr}}$''). На первый взгляд, это должно работать как полагается. Строго говоря, это \emph{конкретное} преобразование действительно работает.
Но что случится, если нам понадобится переопределить поведение в классе 
 ``$\inbr{show_{expr}}$''? Согласно подходу, определенному выше, на необходимо отнаследоваться от ``$\inbr{show_{expr}}$'', переопределить некоторые метода и сконструировать функцию с помощью комбинатора неподвижной точки:

\begin{lstlisting}
   class custom_show fself = object 
     inherit $\inbr{show_{expr}}$ fself
     method $\inbr{Const}$ $\iota$ x n = "a constant"
   end

   let custom_show e = fix $\inbr{gcata_{expr}}$ (fun fself -> new custom_show fself) () e
\end{lstlisting}

А это не будет работать так, как мы ожидаем, потому мы не определили метод
``$\inbr{LocalDef}$'', который использует класс по-умолчанию для типа  ``\lstinline{def}'', который в свою очередь пользуется классом по-умолчанию для типа  ``\lstinline{expr}''.
Получается, что мы переопределили только поведение только одной компоненты взаимно рекурсивного преобразования типов, а именно для типа ``\lstinline{expr}'' as such. 
Все вхождения типа ``\lstinline{expr}'' в жругих типах всё ещё преобразуются стандартным образом. Чтобы исправить это поведение, нам придется повторить реализацию взаимно рекурсивных классов \emph{целиком}, что обесценивает всю идею расширяемости.

Наше решение проблемы снова полагается на идею одткрытой рекурсии. В кратце, мы параметризируем конкретный класс преобразования трансформациями \emph{всех} типов, учавствующих во взаимно рекурсивном определении типов.
так как эта параметризация нарушает соглашение об интерфейсах классов, нам придется объявить эти классы как дополнительные. Для нашего примера они будут выгляет вот так:

\begin{lstlisting}
   class $\inbr{show\_stub_{expr}}$ $f_{expr}$ $f_{def}$ = object 
     inherit [unit, _, string] $\inbr{expr}$ $f_{expr}$
     $\dots$
     method $\inbr{LocalDef}$ $\iota$ x d e = $\dots$ ($f_{def}$ $\dots$) $\dots$
   end

   class $\inbr{show\_stub_{def}}$ $f_{expr}$ $f_{def}$ = object 
     inherit [unit, _, string] $\inbr{def}$ $f_{def}$
     method $\inbr{Def}$ $\iota$ x s e = $\dots$ ($f_{expr}$ $\dots$) $\dots$
   end
\end{lstlisting}

Обратите внимание на отсутствие рекурсивных классов.


Затем мы сгенериуем комбинатор неподвиджной точки для этого взаимно рекурсивного определения:

\begin{lstlisting}
   let $\inbr{fix_{expr, def}}$ ($c_{expr}$, $c_{def}$) =
     let rec $t_{expr}$ $\iota$ x = $\inbr{gcata_{expr}}$ ($c_{expr}$ $t_{expr}$ $t_{def}$) $\iota$ x
     and $t_{def}$ $\iota$ x = $\inbr{gcata_{def}}$ ($c_{def}$ $t_{expr}$ $t_{def}$) $\iota$ x in
     ($t_{expr}$, $t_{def}$)
\end{lstlisting}

Здесь $c_{expr}$ и $c_{def}$ являются генераторами объектов, которые принимают как параметры функции преобразования всех типов, которые встречаются во взаимно рекурсивном определении. ОБратите внимание, что тот же самый кобинатор неподвижной точки может использоваться для того, чтобы сконструировать любое конкретное преобразование для данного взаимно рекурсивногоопределения типов.

С этими дополнительными классами мы может сконструировать реализации по-умолчанию для любого конкретного преобразования:

\begin{lstlisting}
   let $\inbr{show_{expr}}$, $\inbr{show_{def}}$ =
     $\inbr{fix_{expr,def}}$ (new $\inbr{show\_stub_{expr}}$, new $\inbr{show\_stub_{def}}$) 
\end{lstlisting}

Эти преобразования по-умолчанию, во-первых, должны сохраниться во всех структурах с информацией о типах для соответсвующих типов, и во-вторых, используются для создания классов трансформацией, с ожидаемым интерфейсом:

\begin{lstlisting}
   class $\inbr{show_{expr}}$ fself = object 
     inherit $\inbr{show\_stub_{expr}}$ fself $\inbr{show_{def}}$ 
   end
   class $\inbr{show_{def}}$ fself = object 
     inherit $\inbr{show\_stub_{def}}$ $\inbr{show_{expr}}$ fself 
   end
\end{lstlisting}

Здесь мы снова сделали взаимно рекурсивные типы неотличимыми от простых (в терминах интерфейсов классов), что позволяет единообразным способом конструировать преобразования этих типов в файлах, где эти типы используются, но не объявлены.

С другой стороны, чтобы расширить имеющееся преобразование, теперь необходимо наследоваться от \emph{дополнительных} классов и использовать специальный комбинатор неподвижной точки.
Для нашего предыдущего неудачного случая преобразование выглядит почти также просто, как и для одигочного объявления типа:

\begin{lstlisting}
   let custom_show, _ =
      $\inbr{fix_{expr,def}}$ ((fun $f_{expr}$ $f_{def}$ ->
                     object inherit $\inbr{show\_stub_{expr}}$ $f_{expr}$ $f_{def}$
                       method $\inbr{Const}$ $\iota$ x n = "a constant"
                     end),
                    new $\inbr{show\_stub_{def}}$) 
\end{lstlisting}

В конкретной реализации библиотеки мы генерируем мемоизирующий комбинатор неподвижной точки, который следует тому же шаблону, который был описан в разделе ~\ref{memofix}. К тому же, мы созраняем данный комбинатор в структуре с информацией о типе, чтобы для 
типа ``\lstinline{t}'' этот комбинатор мог быть использован с помощью выражение 
``\lstinline{fix(t)}''. Пользователям, однако, придется держать в уме, что тип является взаимно рекурсивным, чтобы воспользоваться комбинатором правильно.

Однако присутствует одна слоажность с поддержкой взаимной рекурсии: мы полагаемся на то свойства, что добавление одной фукнции преобразования для типа  достаточно, чтобы реализовать открытую рекурсию. Однако, строго говоря, это не так. Например, рассмотрим следующее объявление типа:

\begin{lstlisting}
   type ($\alpha$, $\beta$) a = A of $\alpha$ b * $\beta$ b
   and  $\alpha$ b = X of ($\alpha$, $\alpha$) a
\end{lstlisting}

В аргументрах конструктора ``\lstinline{A}'' мы имеем \emph{различные} параметризации типа ``\lstinline{b}'', и поэтому нам понадобятся \emph{две} функции~--- для``\lstinline{$\alpha$ b}'' и для ``\lstinline{$\beta$ b}''. Однако, тип ``\lstinline{a}'' не является регулярным~--- начав преобразование типа ``\lstinline{($\alpha$, $\beta$) a}'' мы придём к необходимости преобразования значений типов ``\lstinline{($\alpha$, $\alpha$) a}'' и ``\lstinline{($\beta$, $\beta$) a}''.

Следовательно, 
Thus, we have already ruled such definitions out. In this reasoning we assume that mutually recursive definitions are \emph{essential} in the sense that they
can not be split into separate type declarations (i.e. that every pair of types are mutually ``reachable''). If we replace the second definition in the
example above with, say,

\begin{lstlisting}
   ...
   and $\alpha$ b = int
\end{lstlisting}

then we would end up with a case which is not supported by our framework. However, as types ``\lstinline{a}'' and ``\lstinline{b}'' are actually \emph{not}
mutually recursive, the whole definition can be rewritten, which restores the support.

\subsection{Polymorphic Variants}
\label{pv}

We consider the support for polymorphic variants~\cite{PolyVar,PolyVarReuse} as an important feature of our framework since it complements the ability of defining
composable data structures with the ability of creating composable transformations. The main difference between polymorphic variants and usual algebraic
data types is that it is possible to \emph{extend} previously declared polymorphic variants by adding more constructors or to combine a few types into the one. 

Our goal is to provide a \emph{seamless} integration of generic features: when a few types are being combined we would want to acquire all generic
features for the result type by inheriting the same features from the constituent types.

As we said previously, an extra type parameter ``$\epsilon$'' is inferred to an open version of the polymorphic variant type. Thus, the same generic transformation
function can be used to transform a value using a transformation object for a \emph{wider} type\footnote{We refrain from calling this type a ``subtype'' since there is
no subtyping in \textsc{OCaml}.}. This is achieved by a specific form of generic transformation function, which performs an ``opening'':

\begin{lstlisting}
   let $\inbr{gcata_t}$ $\omega$ $\iota$ subj =
     match subj with
     $\dots$
     | C $\dots$ -> $\omega$#$\inbr{C}$ $\iota$ (match subj with #t as subj -> subj) $\dots$
     $\dots$
\end{lstlisting}

This results in applying the methods of transformation object to an opened version of the type, while the transformation function itself still operates only
of the closed version.

When a few polymorphic variant types are combined, the transformation function simply matches a value against type patterns and dispatches the
transformation to the transformation functions of a corresponding constituent type.
