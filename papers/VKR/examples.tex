\section{Примеры}
\label{sec:examples}

В этом разделе мы представим несколько примеров, реализованных с помощью нашей библиотеки. В этих примерах используются синтаксические расширения \cd{camlp5}, хотя всё может быть переписано с использованием \cd{ppxlib}. Как было скзано выше даннная работа является прямым наследником~\cite{TransformationObjects} и все примеры из той статьи работают в этой версии. Здесь мы покажем несколько новых.

\subsection{Типизированые логические значения}

Первый пример появился во врем работы на строго типизированым логическим предметно-ориентированным языком для \textsc{OCaml}~\cite{OCanren}. 
Одной из самых важных конструкций была унификация термов со свободными логическими переменными, работать с такими структурами данных сложно, а допустить ошибку --- легко. Типичным сценарием взаимодействия  между логическими и нелогическими частями программ является 
создание так называемых \emph{целей вычислений} (англ. goal), содержащих структуры данных со свободными логическими переменными в них.
Решением логической цели, является подстановка переменных, правые части которой в идеальном случае не содержит свободных переменных. Чтобы
сконструировать цель вычислений систематически вводить логические переменные в некоторую типизированную структуру данных,  а для восстановления ответа -- систематически извлекать из логических представлений ответы в нелогическом представлении.

Упрощённый тип для логических переменных может быть описан следующим образом:

\begin{lstlisting}
   @type 'a logic =
   | V     of int
   | Value of 'a
   with show, gmap
\end{lstlisting}

Логическое значение может быть либо свободной логической переменной (``\lstinline{V}'') или каким-то другим значением (``\lstinline{Value}''), которое не вляется свободной переменной, но потенциально может содержать свободные переменные внутри себя. Чтобы преобразовывать в и из логических значений, можно воспользоваться следующими функциями:

\begin{lstlisting}
   let lift x = Value x
  
   let reify  = function
   | V     _ -> invalid_arg "Free variable"
   | Value x -> x
\end{lstlisting}

Функция ``\lstinline{reify}'' бросает исключение для свободных переменных, так как в присутствии вхождений свободных переменных
логическое значение нельзя рассматривать как обыкновенную (нелогическую) структуру данных.

Когда мы работает с логическими структурами данных, на необходима возможность вставлять логические переменные в произвольные позиции.
Это означает, что мы должны переключиться на использование другого типа, который принадлежит домену логических типов. Например,
для арифметических выражений, которые мы использовали как пример, нам понадобится конструировать значения вида

\begin{lstlisting}
   Value (
     Binop (
       V 1, 
       Value (Const (V 2)),
       V 3
    )
   )
\end{lstlisting}

которые будут иметь тип ``\lstinline{lexpr}'', объявленный как

\begin{lstlisting}
   type expr' = Var of string logic | Const of int logic | Binop of lexpr * lexpr
   and  lexpr = expr' logic
\end{lstlisting}

Нам также нужно реализовать дву функции преобрзования. Все эти определения представляют собой типичный пример однотипного (boilerplate) кода.

С измользование нашего подхода решение почти полностью декларативно\footnote{При условии включения ключа компиляции \cd{-rectypes}}.
Во-первых, мы абстрагируемся от интересующего нас типа, заменяя все его вхождения типовой переменной с невстречающимся ранее именем:

\begin{lstlisting}
   @type ('string, 'int, 'expr) a_expr =
   | Var   of 'string
   | Const of 'int
   | Binop of 'string * 'expr * 'expr with show, gmap
\end{lstlisting}

Здесь мы абстрагировали тип от всего конкретного, но мы могли обойтись абстрагированием только от самого себя. Заметьте, что 
мы воспользовались двумя видами обощенных преобразований~--- ``\lstinline{show}'' и ``\lstinline{gmap}''. 
Первое будет полезно для отладочных целей, а второе является необходимым для нашего решения.

Тепреь мы можем объявить логические и нелогические состовляющие как специализации исходного типа:

\begin{lstlisting}
   @type expr  = (string, int, expr) a_expr with show, gmap
   @type lexpr = (string logic, int logic, lexpr) a_expr logic with show, gmap
\end{lstlisting}

ОБратие внимание, что ``новый'' тип ``\lstinline{expr}'' эквивалентен старому, следовательно, такое переписывание типов не нарушает существующий код.

Наконец, определения фукнций преобразования воспользуются преобразованием, полученным с помощью плагина ``\lstinline{gmap}'', предоставляемого библиотекой:

\begin{lstlisting}
   let rec to_logic   expr = gmap(a_expr) lift  lift  to_logic  expr
   let rec from_logic expr = gmap(a_expr) reify reify from_logic @@ reify expr
\end{lstlisting}

Как вы видите, поддержка типовых операторов существенна для этого примера. В предыдущей реализации~\cite{TransformationObjects} типовые опреаторы не были поддержаны и их было не так просто добавить.

\subsection{Преобразование в безымянное представление}

Полиморфные вариантные типы позволяют описывать структуры данных композиционально, статически типизированно и в разных модулях 
компоновки~\cite{PolyVarReuse}.
Объявлять преобразования таких структур данных отдельно являеется естественной идеей. Проблема конструирования преобразований 
раздельно объявленных строго типизированных компонент известна как ``проблема выражений'' (``The Expression Problem''~\cite{ExpressionProblem}), которая часто исползуется как ``лакмусовый тест'' для оценивания подходов к обощенному программированию~\cite{ObjectAlgebras,ALaCarte}. 
В этом разделе мы покажем решение проблемы выражений в рамках нашего подхода. В качестве конкретной задачи мы реализуем преобразование лямбда-термов в безымянное представление.

Во-первых, опишем часть языка термов без связывающих конструкций:

\begin{lstlisting}
   @type ('name, 'lam) lam = [
   | `App of 'lam * 'lam
   | `Var of 'name
   ] with show
\end{lstlisting}

Отделение этого типа выглядит логичной идей, так как потенциально в языке можеть появить множетсво констуркций, связывающих переменные 
($\lambda$-абстракции, \lstinline=let=-определения и т.д.) и комбинируя их с несвязывающей частью и с ними самими можно получать множетсво языков с согласованным поведением.

Тип ``\lstinline{lam}'' полиморфен. Первый параметр используется для представления имен или индексов де Брауна, второй необходим для открытой рекурсии (здесть мы следуем уже исследованому подходу по описанию расширяемых структур данных с помощью полиморфных 
вариантов~\cite{PolyVarReuse}).

Как долно выглядеть преобразование в безымянное представление для такого типа? А именно, как должен выглядет класс преобразвания? Это показано ниже:

\begin{lstlisting}
   class ['lam, 'nameless] lam_to_nameless
     (flam : string list -> 'lam -> 'nameless) =
   object
     inherit [string list, string, int,
              string list, 'lam, 'nameless,
              string list, 'lam, 'nameless] $\inbr{lam}$
     method $\inbr{App}$ env _ l r = `App (flam env l, flam env r)
     method $\inbr{Var}$ env _ x   = `Var (index env x)
   end
\end{lstlisting}

Здесь мы используем список строк для хранения подстановки переменных и  передаем его как наследуемый атрибут. Затем мы воспользуемся фукнцией 
``\lstinline{index}'' чтобы найти строку в подстановки, т.е.  эта функция преобразуем имея в индекс де Брауна. 
Интересной часть преобразования является типизация общего класса предка ``$\inbr{lam}$''. 
Первая тройка параметров описывает преобразвание первого типовго параметра. Как Вы видите, мы преобразуем строки в числа используя подстановку.
Здесь типовая переменная ``\lstinline{'lam}'', как мы знаем, приравняется открытой версии типа ``\lstinline{lam}''.
Наконец. результат преобразование типизируется с помощью типовой переменной ``\lstinline{'nameless}''. 
Так происходит именно так потому, что, как будет понятно позднее,  это будет действительно другой тип.
Так как второй типовый параметр обычно ссылается рекурсивно на себя, третья тройка типовых параметров совпадает со второй.

Давайте теперь добавим связывающую конструкцию -- $\lambda$-абстракцию:

\begin{lstlisting}
   @type ('name, 'lam) abs = [ `Abs of 'name * 'lam ] with show
\end{lstlisting}

Те же самые рассуждения применимы и тут: мы пользуется открытой рекурсией и параметризируем представление относительно имени.
Класс для преобразования будет выглядеть похожим образом:

\begin{lstlisting}
  class ['lam, 'nameless] abs_to_nameless
    (flam : string list -> 'lam -> 'nameless) =
  object
    inherit [string list, string, int,
             string list, 'lam, 'nameless,
             string list, 'lam, 'nameless] $\inbr{abs}$
    method $\inbr{Abs}$ env name term = `Abs (flam (name :: env) term)
  end
\end{lstlisting}

Заметьте, что метод ``$\inbr{Abs}$'' конструирует занчения \emph{другого} типа, чем любая возможная параметризация типа ``\lstinline{abs}''. Действително, безымянное представление типа не должно содержать никаких суррогатов имён.

Теперь мы можем объединить эти два типа, чтобы получить тип термов со связывающими конструкциями:

\begin{lstlisting}
   @type ('name, 'lam) term = [ ('name, 'lam) lam | ('name, 'lam) abs) ] with show
\end{lstlisting}

Мы можем предоставить два новых типа для именованого и безымянного представления\footnote{Нам понадобится использовать ключ компиляции
\cd{-rectypes}, чтобы эти определения типов скомпилировались .}:

\begin{lstlisting}
   @type named    = (string, named) term with show
   @type nameless = [ (int, nameless) lam | `Abs of nameless] with show
\end{lstlisting}

Наконец, мы может описать преобразвание, которое превращает именованые термы в их безымянное представление:

\begin{lstlisting}
   class to_nameless
     (fself : string list -> named -> nameless) =
   object
     inherit [string list, named, nameless] $\inbr{named}$
     inherit [named, nameless] lam_to_nameless fself
     inherit [named, nameless] abs_to_nameless fself
   end
\end{lstlisting}

Это преобразование получается путём наследования всех важных состовляющих: общего класса для всех трансформаций типа ``\lstinline{named}'' 
и двуз конкретных преобразований его состовляющих. Функция трансформации может быть получена стандартным способом:

\begin{lstlisting}
   let to_nameless term =
     transform(named) (fun fself -> new to_nameless fself) [] term
\end{lstlisting}

Только что мы построили реализацию, комбинируя реализации для его состовляющих. Эти частичные решения могут быть раздельно скомпонованы, а вся система при этом остается строго типизированной.

\subsection{Пример пользовательского плагина}
\label{pluginExample}

Наконец, мы продемонстрируем использование системы плагинов на свежем примере реализации плагина. Для этой цели мы выбрали широко известное преобразование \emph{hash-consing}~\cite{HC}. Это преобразование превращает структуры данных в их максимально компактное представление в памяти, при котором структурно равные части представляются в памяти как один физический объект. Например, синтаксическое дерево выражения

\begin{lstlisting}
   let t =
     Binop ("+",
       Binop ("-",
         Var "b",
         Binop ("*", Var "b", Var "a")),
       Binop ("*", Var "b", Var "a"))
\end{lstlisting}

может быть переписано  как

\begin{lstlisting}
   let t =
     let b  = Var "b" in
     let ba = Binop ("*", b, Var "a") in
     Binop ("+", Binop ("-", b, ba), ba)  
\end{lstlisting}

где равные 
where equal sub expressions are represented by shared sub trees.

Our plugin for a type ``\lstinline|$\left\{\alpha_i\right\}$ t|'' will provide a hash-consing function ``\lstinline{hc(t)}'' of the type

\begin{lstlisting}
    $\{$ H.t -> $\alpha_i$ -> H.t * $\alpha_i$ $\}$ -> H.t -> $\left\{\alpha_i\right\}$ t -> H.t * $\left\{\alpha_i\right\}$ t
\end{lstlisting}

where ``\lstinline{H.t}''~--- a heterogeneous hash table for values of arbitrary types. The interface for the hash table is
as follows:

\begin{lstlisting}
   module H :
   sig
     type t
     val hc : t -> 'a -> t * 'a
   end
\end{lstlisting}

The function ``\lstinline{H.hc}'' takes a hash table and some value and returns a possibly updated table and a structurally equivalent value
of the same type. For now we postpone the description of this module implementation and consider an example of constructor transformation
method:

\begin{lstlisting}   
   method $\inbr{Binop}$ h _ op l r =
     let h, op = hc(string) h op in
     let h, l  = fself h l in
     let h, r  = fself h r in
     H.hc h (Binop (op, l, r))
\end{lstlisting}

The method takes an inherited attribute~---this time a hash table ``\lstinline{h}'',~--- the whole expressions node (which we do not
need in this case, hence underscore), and three arguments of the constructor: ``\lstinline{op}'' of type \lstinline{string}, and
``\lstinline{l}'' and ``\lstinline{r}'' of type \lstinline{expr}. We first hash-cons all three arguments (which gives us a possibly updated
hash table and three hash-consed values of the same types), then we apply the constructor and hash-cons the value again. To hash-cons
the arguments of the constructor we can use the functions provided by the framework~--- for the type \lstinline{string} it is
``\lstinline{hc(string)}''\footnote{Generally speaking, we would need to implement a hash-consing function for each primitive type; in
  our case, however, we could equally use ``\lstinline{H.hc}''.}, and for both sub expressions it is ``\lstinline{fself}''.

As a final component we need to decide on the type parameters for a plugin class for a type ``\lstinline|$\{\alpha_i\}$ t|''. Clearly,
all inherited attribute types has to be ``\lstinline{H.t}'', and synthesised attribute types has to be ``\lstinline{H.t * $a$}'' for the
type of interest ``$a$''. This gives us the following plugin class definition:

\begin{lstlisting}
   class [$\{\alpha_i\}$, $\epsilon$] $\inbr{hc_t}$ $\dots$ =
   object
     inherit [$\{$ H.t, $\alpha_i$, H.t * $\alpha_i$ $\}$, H.t, $\epsilon$, H.t * $\epsilon$] $\inbr{t}$
     $\dots$
   end
\end{lstlisting}

For simplicity we omitted the specification of functional parameters for the class since their types can be trivially
recovered.

Now we need to generate this logic using a plugin.

The infrastructure code for the plugin implementation is shown below:

\begin{lstlisting}
   let trait_name = "hc"
  
   module Make (AstHelpers : GTHELPERS_sig.S) =
     struct
     
       open AstHelpers

       module P = Plugin.Make (AstHelpers)

       class g tdecls =
       object (self : 'self)
         inherit P.with_inherited_attr tdecls as super
         $\ldots$
       end

     end

   let _ =
     Expander.register_plugin trait_name (module Make : Plugin_intf.Plugin)
\end{lstlisting}

To implement a plugin, one needs to implement a functor parameterised by a helper module, which resembles ``\cd{Ast_builder}'' from
\cd{ppxlib} to create \textsc{OCaml} syntax trees. We need to use a functor since we have to provide two implementations for
a plugin~--- for \cd{camlp5} syntax extension as well as for \cd{ppxlib} itself. The main entity in the body of the functor is
a class ``\lstinline{g}'' declaration (``generator''), which for simplicity can be inherited from one of generic classes 
from the framework. In this case we, first, instantiate the generic plugin ``\lstinline{P}'' for ``\lstinline{AstHelpers}'' and
then inherit from the class ``\lstinline{P.with_inherited_attr}'', which means that we are going to implement a plugin
making use of inherited attribute. The class takes a type declaration as a parameter. Finally, we register the functor as a
first-class module in the framework to make it accessible.

Now we show what the methods of the generator class look like. First, we need to specify what are the types of inherited and
synthesised attributes for the plugin:

\begin{lstlisting}
   method main_inh ~loc _tdecl = ht_typ ~loc

   method main_syn ~loc ?in_class tdecl =
     Typ.tuple ~loc
       [ ht_typ ~loc
       ; Typ.use_tdecl tdecl
       ]

   method inh_of_param tdecl _name =
       ht_typ ~loc:(loc_from_caml tdecl.ptype_loc)

   method syn_of_param ~loc s =
     Typ.tuple ~loc
       [ ht_typ ~loc
       ; Typ.var ~loc s
       ]
\end{lstlisting}

where we assume ``\lstinline{ht_typ}'' is defined as

\begin{lstlisting}
   let ht_typ ~loc =
     Typ.of_longident ~loc (Ldot (Lident "H", "t"))
\end{lstlisting}

In other words, we say here that the type of inherited attribute is always ``\lstinline{H.t}'' and the type of a synthesised attribute for
a type of interest ``\lstinline{t}'' is ``\lstinline{H.t * t}''.

The next group of methods specifies the behaviour of plugin class type parameters:

\begin{lstlisting}
   method plugin_class_params tdecl =
     let ps =
       List.map tdecl.ptype_params ~f:(fun (t, _) -> typ_arg_of_core_type t)
     in
     ps @
     [ named_type_arg ~loc:(loc_from_caml tdecl.ptype_loc) @@
       Naming.make_extra_param tdecl.ptype_name.txt
     ]

   method prepare_inherit_typ_params_for_alias ~loc tdecl rhs_args =
     List.map rhs_args ~f:Typ.from_caml
\end{lstlisting}

The first method specifies the type parameters for the plugin class itself: this time they are exactly the type parameters of the type declaration plus
the extra parameter ``$\epsilon$''. The second one describes the method of recalculation of type parameters for application of type constructor: when
the type declaration looks like

\begin{lstlisting}
   type $\{\alpha_i\}$ t = $\{a_i\}$ tc
\end{lstlisting}

we need to acquire the implementation of the plugin for ``\lstinline{t}'' from the implementation of the same plugin for ``\lstinline{tc}'', inheriting
from properly instantiated corresponding class. As for our plugin the class is parameterised by the same types as the type, we just keep the parameters.

The last group of methods generate the bodies of constructor transformation. As we support regular constructors with both tuple and record
argument specifications as well as top-level tuples and records, there are four methods, which as a rule share many details of implementation. We show the
skeleton for one of them:

\begin{lstlisting}
method on_tuple_constr ~loc ~is_self_rec ~mutual_decls ~inhe tdecl constr_info ts =
  $\dots$ 
  match ts with
  | [] -> Exp.tuple ~loc [ inhe; c [] ]
  | ts ->
     let res_var_name = sprintf "%s_rez" in
     let argcount = List.length ts in
     let hfhc =
       Exp.of_longident ~loc (Ldot (Lident "H", "hc"))
     in
     List.fold_right
       (List.mapi ~f:(fun n x -> (n, x)) ts)
       ~init:$\dots$
       ~f:(fun (i, (name, typ)) acc ->
            Exp.let_one ~loc
              (Pat.tuple ~loc [ Pat.sprintf ~loc "ht%d" (i+1)
                              ; Pat.sprintf ~loc "%s" @@ res_var_name name])
              (self#app_transformation_expr ~loc
                 (self#do_typ_gen ~loc ~is_self_rec ~mutual_decls tdecl typ)
                 (if i = 0 then inhe else Exp.sprintf ~loc "ht%d" i)
                 (Exp.ident ~loc name)
              )
              acc
          )
  $\dots$
\end{lstlisting}

This implementation makes use of the generic method ``\lstinline{self#app_transformation_expr}'' from the framework, which generates an application of
the transformation in question for a given type.

The final component for the implementation is module ``\lstinline{H}'' itself. The standard functor ``\lstinline{Hashtbl.Make}'' instantiates a
hash table making use of some hash function and equality predicate, supplied by an end user. In a whole, we follow a conventional pattern:
for the hash function we use polymorphic ``\lstinline{Hashtbl.hash}'' and for the equality we use physical equality ``\lstinline{==}''. There are, however, two
subtleties:

\begin{itemize}
\item Since our hash table is heterogeneous, we have to utilise unsafe coercion ``\lstinline{Obj.magic}''.
\item Our implementation for equality has to be a little more complex than simple ``\lstinline{==}'': we need to compare the top-level constructors and
  the number of their arguments \emph{structurally}, and only then compare the corresponding arguments by physical equality. Technically this
  may result in hash-consing structurally equal values of \emph{different} types.
\end{itemize}

We rely here on the follow observation: as hash-consing is only consistent with referentially-transparent data structures, we can assume
that structurally equal data structures can be interchangeable regardless their types. The complete implementation for this plugin can be seen in the main project
repository; it occupies 164 LOC, including comments and blank lines.
