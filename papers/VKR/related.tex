\section{Related Works}
\label{sec:relatedworks}

В данной работе использованы одновременно и функциональные (комбинаторы), и объектно-ориентированные возможности языка \textsc{OCaml}. Можно найти связанные работы  одновременно и в области типизированного функционального и объектно-ориентированного программирования. Наиболее близкой, использующий язык \textsc{OCaml} и имеющей отношение к этой работе, библиотекой является \textsc{Visitors}~\cite{Visitors}, которая использует те же самые идеи, но принимает существенно другие дизайнерские решения. Детальное сравнение с \textsc{Visitors} вы найдете в конце данного раздела.

Во-первых, сущестсвует несколько билиотек для обощенного программирования для \textsc{OCaml}, которые используют полностью генеративный подход~\cite{Yallop,PPXLib}~--- все необходимые обобщенные функции для всех типов генерируются по-отдельности. Этот подход очень практичен до тех пор, пока набор предоставляемых трансформаций удовлетворяет всем нуждам. Однако, если это не так, необходимо расширить кодовую базу, реализовав все отсутсвующие функции заново
(с потенциально очень малым переиспользовыванием кода). К тому же, те функции,
которые получаются в результате, нерасширяемы. В нашем подходе, во-первых,
множетсво полезных обощенных функций может быть получено из сгенерированных. Во-вторых, чтобы получить полностью новый плагин, достаточно только ``интересные'' части, так как функции обхода и класс для объекта преобразования создает библиотека сама.

Несколько подходов для функционального обобщенного программирования используют 
\emph{представление типов}~\cite{Hinze}. В основе лежит идея разработки универсального представления для произвольного типа (для которого необходимо получить преобразование) и предоставления двух функций преобразования: в универсальное представление и обратно (в идеале образующих изоморфизм). Обобщенные функции преобразуют представление истинных типов данных, что позволяет реализовать все необходимые преобразования один раз. Функции трансляции в универсальное представление и обратно могут быть получены (полу)автоматически, используя такие особенности системы типов  как классы типов~\cite{Hinze,ALaCarte} и семейства типов~\cite{InstantGenerics} в языке Haskell, или  используя синтаксические расширения~\cite{GenericOCaml} в языке \textsc{OCaml}. Хотя некоторые из этих подходов позволяют модификацию (например, обработка некоторых типов особым образом) и поддерживают расширяемые типы, наш подход более гибок, так как позволяет модификацию на уровне отдельных конструкторов. К тому же, мы позволяем сосоществовать нескольким видам трансформаций для одного типа.

Другой подход был задействован в ``Scrap Your Boilerplate'', или SYB~\cite{SYB}, изначально разработанного для  \textsc{Haskell}. Он делает возможным реализовать трансформации,  которые обнаруживают вхождения конкретного типа в произвольной структуре данных. Поддерживаются два основных вида действий: \emph{запросы}, которые выбирают значения конкретного типа данных на основе критериев, заданных пользователем, и \emph{преобразования}, которые единообразно применяют преобразование, сохраняющее тип, в конкретной структуре данных. В последующих статьях этот подход был расширен для трансформаций, которые обходят пару структур данных одновременно~\cite{SYB1}, а также поддержкой расширения уже сущетвующих транформаций новыми случаями~\cite{SYB2}. Позднее, данных полход был реализован в других языках, включая \textsc{OCaml}~\cite{SYBOCaml,Staged}. В отличие от нашего случая, SYB позволяет применять трансформации к конкретным типам целиком, а не отдельным кострукторам. К тому же, вид получающихся трансформаций выглядит достаточно ограниченным. Также, потенциально, функции трансформации в SYB-стиле могут сломать барьер инкапсуляции, так как могут обнаруживать вхождения значений нужно типа в структуре данных \emph{произвольного} типа. Таким образом, поведение зависит от особенностей внутренней реализации структуры данных, даже от тех, что были скрыты при инкапсуляции. Это может привести, во-первых, к возможности нежелаемой обратной разработки (путём применения различных, чувствительных к типу, преобразований и анализа результатов) и, во-вторых, к ненадежности интерфейсов~--- после модификации структуры данных реализация обобщенной функции для \emph{старой} версии всё ещё может быть применена без статических или динамических ошибок, но с неправильным (или нежелательным) результатом.

Сущетсвует определенное сходство между нашим подходом и \emph{алгебрами объектов}~\cite{ObjectAlgebras}. Алгебры объектов были предложены как решение проблемы выражения (expression problem) в распространенных объектно-ориентированных языках  (\textsc{Java}, \textsc{C++}, \textsc{C\#}), которые не требуют продвинутых особенностей системы типов кроме наследования и шаблонов. В оригинальном представлении алгебры объектов были преподнесены как шаблон проектирования и реализации; в последующих работах изначальная идея была улучшена различными способами~\cite{ObjectAlgebrasAttribute,ObjectAlgebrasSYB}. При использовании алгебр объектов преобразуемая структура данных также кодируется с использованием идеи ``методы и варианты (конструкты) один к одному'', которая предоставляет расширяемость в обоих направлениях, а также ретроактивную реализацию. Однако, будучи  разработанной для совершенно другого языкового окружения, решение с использование алгебр объектов существенно отличается от нашего. Во-первых, с использованием алгебр объектов ``форма'' структуры данных должна быть представлена в виде обощенной функции, которая принимает конкретный экземпляр алгебры объектов как параметер (кодирование Чёрча для типов~\cite{Hinze}). Применяя данную функцию к различным реализациям алгебры объектов можно получать различные преобразования (например, распечатывание). Чтобы инстанциировать саму структуру данных нужно предоставить особый экземляр алгебры объектов~---~\emph{фабрику}. Однако, после инстанциации структура данных больше не может быть трансформирована обобщенным образом. Следовательно, алгебры объектов заставляют пользователя переключиться на представление данных с помощью функций, которое можеть быть, а может не быть удобно в зависимости от обстоятельств.  Наш же подход недеструктивно добавляет новую функциональность к уже знакомому миру алгебраических типов данных, сопоставления с образцом и рекурсивных функций. Обобщенные реализации преобразований полностью отделены от представления данных и пользователи могут свободно преобразовывать их стурктуры данных привычным способом  без потери возможности объявлять (и расширять) обощенные функции. Другой особенностью OCaml, в отличии от распространенных языков объектно-ориентированного программирования, является то, что для написания расширяемого кода в основном используются полиморфные вариантные типы, а не классы. Поддержка полиморфных вариантных типов для написания расширяемых типов данных требует нового подхода.


Итого, среди уже сущетсвующих библиотек для обощенного программирования для \textsc{OCaml} мы можем называть две, которые напопинают нашу:: \cd{ppx\_deriving}/\cd{ppx\_traverse} (часть \cd{ppxlib}~\cite{PPXLib}) и \textsc{Visitors}~\cite{Visitors}.

\cd{ppx\_deriving} является наипростейшим подходом: объявления типов данных отображаются один к одному в рекурсивные функции, представляющие конкретный вид преобразования. Это наиболее эффективная реализация (функции вызываются напрямую, без позднего связывания), но нерасширяемая. Если пользователю понадобится слегка модифицировать сгенерированную функцию, то он должен будет полность скопировать реализацию функции и изменить её. Количество работы по программированию нового преобразования может сущетсвенно увеличиться, если тип данных будет видоизменяться во время цикла разработки.

In \cd{ppx\_traverse} extensible transformations are represented as objects; unlike our case, method-per-type approach is used. In addition 
\cd{ppx\_traverse} does not make use of inherited attributes, thus some transformations like equality or comparison are not representable.

\textsc{Visitors}, on the other hand, explores a similar to ours object-oriented approach, in which many decisions, rejected by us, were taken (and vice versa). Here
we summarise the main differences:

\begin{itemize}
   \item \textsc{Visitors} is excessively object-oriented~--- in order to use it one needs to instantiate some object and call proper method. In our case as long as
     only predefined features are required one can use a more native combinatorial interface.
     
   \item \textsc{Visitors} implements a number of useful transformations in an \emph{ad-hoc} manner; in our case all transformations are instances of the
     same generic scheme. It is possible to combine different transformations via inheritance as long as the types of underlying scheme unify. We also argue, that
     in our framework the implementation of user-defined plugins is much easier.
     
   \item Following SYB, \textsc{Visitors} takes a type-discriminating route: for each type of interest (including the built-in ones) there is a dedicated
     transformation method in each object, representing a transformation. While this solution indeed adds some flexibility, we firmly oppose it, since it
     breaks the encapsulation: inspecting the methods of a transformation (which cannot be hidden in a module signature) one can retrieve some
     information about the implementation of encapsulated types. Even worse, the data structures of abstract types can be manipulated in an unprescribed
     manner using the public type-transforming interface.

   \item In our case the type parameters for transformation classes have to be specified by an end user. With \textsc{Visitors} this burden is offloaded to the
     compiler with the aid of some neat trick. However, this trick makes it impossible to use \textsc{Visitors} syntax extension in module signatures. There is no
     such problem in our case~--- our framework can be equally used in both implementation and interface files.

   \item \textsc{Visitors} in its current state\footnote{The latest available version is 20180513} does not support polymorphic variants.
   
   \item \textsc{GT} supports arbitrary type constructor applications but \textsc{Visitors} in its current state doesn't (both in monomorphic and polymorphic mode).
     For instance, the following example doesn't compile:
     
   \begin{lstlisting}
      type ('a,'b) alist = Nil | Cons of 'a * 'b
      [@@deriving visitors { variety = "map"; polymorphic = true }]

      type 'a list = ('a, 'a list) alist
      [@@deriving visitors { variety = "map"; polymorphic = false }]
   \end{lstlisting}
   
   Moreover, adding an extra construct doesn't solve the problem:
   
    \begin{lstlisting}
       type 'a list = L of ('a, 'a list) alist [@@unboxed]
       [@@deriving visitors { variety = "map"; polymorphic = false }]
    \end{lstlisting}
    
    There is also an issue with type aliases in polymorphic mode (monomorphic part of \textsc{Visitors} compiles successfully):
    
    \begin{lstlisting}
       type ('a,'b) t = Foo of 'a * 'b (* OK *)
       [@@deriving visitors { variety = "map"; polymorphic = true }]
       
       type 'a t2 = ('a, int) t
       [@@deriving visitors { variety = "map"; name="yyy"; polymorphic = true }]
    \end{lstlisting}
    
    The generated code can be fixed manually by removing explicit polymorphic type annotations from objects' methods, which leads to the code
    very similar to the one generated by \textsc{GT}. From these we can conclude that \textsc{GT} can be seen an a reimplementation of polymorphic
    mode of \textsc{Visitors} where more type declarations compile successfully.
    
\end{itemize}
