% !TeX encoding = UTF-8

В этом разделе мы презентуем подход обобщённого по типам данных программирования (datatype generic programming) но основе стандартной задачи суммирования чисел в различных контейнерах.

Рассмотрим стандартную реализацию связных списков, встроенных в \ocaml{}, и напишем функцию суммирования чисел в  списке. Реализация суммирования стандартная: 0 для пустых списков, а для непустых -- это сумма элемента \lstinline{n} и суммы хвоста списка.

\begin{lstlisting}
type 'a list = 'a List.t = 
  | [] 1
  | ( :: ) of 'a * 'a list

let rec sum_list = function 
  | [] -> 0 
  | n :: xs -> n + sum_list xs
\end{lstlisting}

Заметим, что функция суммирования списка является более частным случаем другого преобразования, так называемой "свертки" или катаморфизма~\cite{DGP}.

\begin{lstlisting}
let rec fold_list f acc = function 
| [] -> acc 
| x::tl -> fold_list f (f acc x) tl 

let sum_list xs = fold_list ( + ) 0 xs
\end{lstlisting}

Теперь рассмотрим ту же самую задачу, но для суммирования значений, хранящихся в листьях бинарного дерева типа \lstinline{btree}. Сумма листовой вершины будет значением, хранящимся в этой вершине, а сумма узла дерева будет суммой левого и правого по деревьев.

\begin{lstlisting}
type 'a btree = 
  | Leaf of 'a 
  | Node of 'a btree * 'a btree

let rec sum_btree = function
  | Leaf n -> n + 0
  | Node (l, r) -> sum_btree l + sum_btree
\end{lstlisting}

И cнова сумма элементов в дереве является частным случаем более общей операции --- свертки для типа \lstinline{btree}.
\begin{lstlisting}
let rec fold_btree f acc = function
  | Leaf _ -> f acc 1
  | Node (l, r) -> 
      fold_btree f (fold_btree f acc l) r

let sum_btree t = fold_btree (+) 0 t
\end{lstlisting}

Заметим, что в обоих случаях искомое преобразование для двух типов выражается с помощью более общего преобразования, которое реализуется отдельно для каждого из типов, но сходным образом. Обобщённое по типам данных программирование позволяет избежать написания программистом такого шаблонного (англ. boilerplate) кода, позволяя на основе соответствующего типа данных породить на стадии компиляции реализации преобразований \lstinline{fold_btree} и \lstinline{fold_list}.

\begin{lstlisting}
type 'a list = 'a List.t = 
  | [] 
  | ( :: ) of 'a * 'a list 
  [@@deriving fold]

type 'a btree = 
  | Leaf of 'a 
  | Node of 'a btree * 'a btree 
  [@@deriving fold]
\end{lstlisting}

\noindent Объявления типов данных проаннотированы указанием вида преобразованя, которое надо построить, а подход \textsc{ppx\_deriving}~\cite{ppxderiving} строит преобразования \lstinline{fold_btree} и \lstinline{fold_list}. Традиционно, библиотеки для обобщенного по типам данных программирования содержат способы автоматического получения не только \lstinline{fold}, но и других видов преобразований: \lstinline{show}, \lstinline{map} и т.д.




