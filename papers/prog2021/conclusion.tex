\section{Производительность}
\label{sec:performance}

При сравнении преобразований, реализованных в традиционном и расширяемом виде,
следует ожидать от первых большей производительности, так как дополнительный слой абстракции вносит некоторые накладные расходы.

При замерах использовались преобразования, реализованные четырьмя способами.
\begin{enumerate}
\item Нерасширяемые преобразования записанные традиционным способом с помощью рекурсивных функций. От них следует ожидать максимальную производительность.
\item Частично расширяемые преобразования, реализованные c помощью записей в стиле библиотеки \cd{ppx\_deriving\_morphism}. Этот  подход вносит накладные расходы на косвенный вызов преобразований подвыражений.% и неприменим, например, для полиморфных вариантых типов. 
\item Расширяемые преобразования в стиле \visitors{}, т.е. с использованием объектов. Вносит некоторые накладные расходы на косвенный вызов из-за таблицы виртуальных методов.
\item Метод из данной работы, сходный с предыдущим, но где обобщенная функция преобразования (раздел~\ref{transtypes}) реализована отдельно от объекта.
\end{enumerate}

Для замеров были выбраны два вида преобразований: копирование выражения и преобразование в текстовый формат.
Данные преобразования применялись к $\lambda$-выражению, которое состоит из некоторого количества $\lambda$-абстракций,  примененных к тождественной функции. Количество таких абстракций определяет размер выражения.

При замерах производительности были реализованы четыре метода, описанные выше. В таблице \ref{tab:caption} в процентах указана производительность методов относительного самого медленного (больше --- лучше), который обозначается прочерком.

Сделанные измерения показывают, что с добавлением возможностей видоизменения и объединения преобразований итоговая производительность уменьшается из-за накладных расходов. Для первого  преобразования, где измеряется производительность обхода выражения без полезной нагрузки,
эти накладных расходы значительны. Однако для второго вида преобразований обход структуры $\lambda$-выражения занимает малую часть, и поэтому накладные расходы на объявление расширяемых преобразований приемлемы.


\begin{table*}[t]
  \centering
  \begin{tabular}{l ccccc}
    \toprule
    \multirow{2}{*}{Вид преобразования}& \multirow{2}{*}{Размер} & \multicolumn{4}{c}{Метод реализации и улучшение (\%)} \\\cline{3-6}
     & & \GT & \visitors & \PPXMorphism  & Default \\\hline
    \multirow{5}{*}{Копирование}  
      & 300  & --  & 149 & 220  & 311 \\
      & 500  & --  & 146 & 218  & 246 \\
      & 700  & -- & 143 & 212  & 244 \\
      & 900  & --  & 141 & 210  & 243 \\
      & 1000 & --  & 140 & 205  & 233 \\\hline
    \multirow{5}{*}{Форматирование}  
      & 300  & 0  & -- & 1  & 3 \\
      & 500  & 0  & -- & 1  & 4 \\
      & 700  & 1  & -- & 1  & 4 \\
      & 900  & -- & 1  & 2  & 3 \\
      & 1000 & -- & 0  & 1  & 3 \\ 
    \bottomrule
  \end{tabular}
\caption{Caption below table.}
\label{tab:caption}
\end{table*}

\section{Заключение}
\label{sec:futurework}

В данной работе представлено подход на основе обобщенного программирования, который кодирует преобразования значений типов данных с помощью объектов, что позволяет видоизменять построенные преобразования, не описывая их заново.

Существует несколько возможны направлений для дальнейшего развития проекта. Во-первых, можно снижать накладные раходы на реализацию расширяемых преобразований 
%в данной работе мы не касались вопросов производительности. Мы представляем преобразования в очень обобщенном виде, с несколькими слоями косвенности. Очевидно, что преобразования, реализованные с помощью нашей библиотеки будут работать медленнее, чем написанные вручную. Мы предполагаем, что 
%производительность может быть улучшено 
с помощью, так называемого, staging~\cite{Staged} или, возможно, с помощью оптимизаций, специфичных для объектов.
%  \textcolor{blue}{Как-то сказать, что тормоза не важны и более-менее приемлемы. Может сделать раздел про производительность}

Другим важным направлением является поддержка большего разнообразия объявлений типов, а именно GADT и нерегулярных типов. Хотя уже сделаны некоторые наработки, получившиеся решение делает интерфейс всей библиотеки чересчур сложным даже для простых случаев.

Наконец, структура с информацией о типе, которую мы генерируем, может быть использована, чтобы сымитировать \emph{ad-hoc} полиморфизм, так как они содержит реализацию функций, индексированных типами. Это в сумме с недавно предложенными расширениями~\cite{ModularImplicits} может открыть интересные перспективы.

