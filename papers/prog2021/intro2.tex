% !TeX encoding = windows-1251
\section{Введение старое}

\begin{comment}
 Фредерк Брукс (Frederic Brooks) в своей известной книге по инженерии
 программ  "Мифический человеко-месяц" ("The Mythical Man-Month")~\cite{MMM} охарактеризовал сущность программирования следующим образом:
 
 \blockquote{"Программист, подобно поэту, работает почти непосредственно с чистой мыслью. Он строит свои замки в воздухе и из воздуха, творя силой воображения. Трудно найти другой материал, используемый в творчестве, который столь же гибок, прост для шлифовки или переработки и доступен для воплощения грандиозных замыслов. (Как мы позднее увидим, такая податливость таит свои проблемы.)"}
 
 Действительно, нематериальность программ и гибкость их представления  призывает к структурированию; отсутствие подходящей структуры легко может привести к катастрофическим последствиям
 (как это случалось с некоторыми промышленными проектами в прошлом). 
 \end{comment}
 
 Одной из проблем в современной разработке программного обеспечения является неправильно разработанная архитектура, которая может привести к плохой структуре программного продукта. Отсутствие подходящей структуры легко может привести к катастрофическим последствиям
 (как это случалось с некоторыми промышленными проектами в прошлом). 
 Одним из наиболее распространенных способов структурировать программы является использование \emph{типов данных}. Они позволяют описывать свойства данных; что можно с ними сделать, а что нельзя; а также в некоторой степени описывают семантику структур данных. Если информация о типах данных присутствует во время работы программы, то становится возможным реализовать мета-преобразования путём анализа типов (\emph{интроспекция}) или путём создания новых типов данных на лету (\emph{рефлексия}).
 
 Однако, в статически типизированных функциональных языках, как правило, типы полностью стираются 
 после фазы компиляции и отсутствуют во время исполнения. Статическая типизация обладает серьёзным преимуществом по сравнению с динамической, потому что программам
 не нужно инспектировать типы во время выполнения и больше количество плохих поведений программ -- ошибок типизации -- не случается. С другой стороны, некоторые преобразования, которые в динамических языках могли быть реализованы ``раз и навсегда'' не проходят проверку типов и должны быть перереализованы для каждого конкретного типа по отдельности. Одни из подходов к преодолению этого недостатка является разработка более выразительной системы типов, где большее количество функций может быть протипизировано. Примером этому подходу будет поддержка перегрузки (\emph{ad hoc} полиморфизма) в языке \haskell в виде классов 
 типов~\cite{TypeClasses} и семейств типов~\cite{TypeFamilies}. Однако, по причине требования тотальности к алгоритму проверки типов и фундаментальной неразрешимости проблемы проверки типов, всегда будут существовать ``хорошие'' программы, которые
 не могут быть протипизированы. Другим подходом является \emph{обобщенное программирование}~\cite{DGP} (\emph{datatype-generic programming}), целью которого является разработка методов для реализации практически важных семейств функций
 индексированных типами, использую имеющиеся возможности языка. Например, типы могут быть закодированы на внутреннем языке~\cite{Hinze,InstantGenerics,GenericOCaml}, либо часть информации о типах может быть сделана доступной во время исполнения, или 
 обобщенные функции для конкретного типа данных могут быть сгенерированы во время
 компиляции автоматически~\cite{Yallop,PPXLib}. Два похода, описанные нами, дополняют друг друга: чем более мощной является система типов, тем больше возможностей для обобщенного программирования язык может предложить. Например, параметрический полиморфизм позволяет естественно выразить функцию для вычисления длины списка произвольных элементов и т.п.
 
 %Отдельно стоит отметить подход под названием  ``Scrap Your Boilerplate''~\cite{SYB,SYB1,SYB2}, который позволяет и извлекать из значений некоторые из части, удовлетворяющие условию. Однако, наш опыт показал, что выразительность и расширяемость SYB недостаточна, к тому же преобразования, которые зависят только от типа, не очень удобно использовать. 
 
 В предыдущих подходах переиспользование преобразований достигается только путём их композиции. Таким образом, если 
 сгенерированное преобразование не вполне устраивает программиста, то он должен либо реализовать генерацию нового вида преобразований, либо написать код вручную. Иными словами, нет предусмотренного способа видоизменять уже сгенерированные преобразования, кроме совершения композиции преобразований.
 
 Другой возможной идеей является использование  позднего связывания (late binding) для того, чтобы видоизменять части сгенерированных преобразований под нужды программиста. Традиционно эта идея ассоциируется с объектно-ориентированным программированием, редко встречаясь в функциональном.
 
 
 В данной работе мы представляем подход, совмещающий в себе идею 
 позднего связывания для осуществления небольших модификаций преобразований, и композициональные преобразования, привычные для функционального программирования. Для апробирования данного подхода была реализована библиотека для обобщенного программирования \textsc{GT}\footnote{\url{https://github.com/kakadu/GT/tree/ppx}} (\emph{Generic Transformers}), а также некоторое количество плагинов для неё, реализующих минимальный общепринятый набор преобразований.
 
 
 %которая находится в активной разработке с 2014 года. В ней используется идея позднего связывания на основе объектов в языке \ocaml, как и в~\visitors. Однако, некоторые дизайнерские решения в \visitors, которые мы считаем непреодолимыми,   не позволяют нам использовать её в некоторых случаях, в частности в  проекте \ocanren~\cite{OCanren}.
 
 