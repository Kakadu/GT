% !TeX encoding = windows-1251
\section{Введение}

При разработке программного обеспечения на функциональных языках программирования, зачастую бывает необходимо реализовывать однотипные преобразования для различных структур данных. Для динамически типизированных языков (например, \scheme{} и его диалекты) иногда можно реализовать одну функцию-метапреобразование, подходящую для всех структур данных. В языках, среды исполнения которых содержат информацию о типах (например, \Scala{}), порою возможно построить метапреобразования во время исполнения, полагаясь на анализ типов во время исполнения (интроспеция) и создание новых типов данных на лету (рефлексия). 
 Для статически типизированных языков программирования, в средах исполнения которых информация о типах обычно не доступна во время исполнения (например, \ocaml{} и \haskell{}), применяется подход под названием 
\emph{обобщенное (generic) программирование}~\cite{Yallop,PPXLib}: %Его суть заключается в том, что 
на стадии компиляции  по описанию типа данных автоматически генерируется нужные преобразования, специализированные для указанных типов данных. 
Обобщённое программирование является стандартным подходом для этих языков, поэтому различным его модификациям крайне желательно, как минимум, повторять его функциональность, а также предоставлять такой же интерфейс использования, чтобы выглядеть знакомыми и понятными практикующему разработчику.

При использовании обобщённого программирования переиспользование кода достигается путём композиции порождённых на стадии компиляции преобразований с другими преобразованиями и прочими функциями. 
%Этот подход хорошо себя показывает в большинстве случаев, однако, иногда его может быть недостаточно. 
В некоторых случаях этого подхода не достаточно, и
если разработчика не вполне устраивает порождённое преобразование, %(например, если ему необходимо немного видоизменить обработку одного алгебраического конструктора из десяти),
то он может действовать двумя способами. Во-первых, он может реализовать новый вид преобразования для своих нужд. В этом случае у разработчика могут возникнуть трудности, так как создание новых преобразований требует специфической экспертизы,
%знаний (например, об абстрактном синтаксическом дереве языка программирования), 
мало применимой при повседневной разработке программного обеспечения. Другим способом решения проблемы является реализация необходимого преобразования вручную без использования подхода обобщённого программирования. В этом случае увеличится размер кодовой базы и усложнится поддержка программного продукта в долгосрочной перспективе. 

Эта проблема не является таковой в традиционных объектно-ориентированных языках программирования, где разработчику легко удается воспользоваться \emph{поздним связыванием}. Этот приём в функциональных языках программирования используется редко либо по причине отсутствия языковой поддержки объектно-ориентированного программирования (\haskell{}), либо потому, что объектно-ориентированных подход нарочно избегается и используется только в тех случаях, когда он существенно удобнее~\cite{modules-vs-objects}. 
%Поэтому, открытым вопросом\footnote{research question 1} (\textit{все проблемы во втором абзаце}) является поиск способа использования объектно-ориентированных идей в функциональном программировании на \ocaml{} так, чтобы получившийся результат выглядел знакомо и естественно для практикующего разработчика на функциональном языке.
В данной работе предлагается представление преобразований с помощью объектов таким образом, что минимальной видоизменяемой единицей является код, обрабатывающий отдельный конструктор алгебраического типа данных. 
%В процессе изложения мы продемонстрируем, что кодирование преобразований дает достаточно свободы, чтобы видоизменять преобразования желаемым способом\footnote{research question 2, хотя RQ у нас можно в evaluation} (что предлагается сделать в 4й абзац, RQ хз куда).

В работе представлен подход, кодирующий преобразования типов данных с помощью объектов, что зачастую свойственно объектно-ориентированному программированию. Благодаря ему открываются возможности по видоизменению построенных преобразований, не описывая их целиком заново. При этом сохраняются основные особенности обобщённого программирования, что позволяет получить преобразования, которые выглядят для практикующего программиста на \ocaml{} знакомо и естественно. Для испытания подхода была спроектирована библиотека \GT{}\footnote{\url{https://github.com/kakadu/GT/tree/ppx}} (\emph{Generic Transformers}) для языка \ocaml{}, где реализованы методы получения стандартных преобразований, аналогичных тем, что предоставляются популярными библиотеками обобщенного программирования, а также методы получения других преобразований.

