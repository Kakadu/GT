% !TeX encoding = windows-1251
\section{Введение}

При разработке программного обеспечения на функциональных языках программирования, зачастую бывает необходимо реализовывать однотипные преобразования для различных структур данных. Для динамически типизированных языков (например, \scheme ~и его диалекты) иногда можно реализовать одну функцию-метапреобразование, подходящую для всех структур данных. В языках, среды исполнения которых содержат информацию о типах (например, Scala), порою возможно построить метапреобразования во время исполнения, полагаясь на анализ типов во время исполнения (интроспеция) и создание новых типов данных на лету (рефлексия). 
 Для статически типизированных языков программирования, в средах исполнения которых информация о типах обычно не доступна во время исполнения (например, \ocaml~и \haskell), применяется подход под названием 
\emph{обобщенное (generic) программирование}~\cite{Yallop,PPXLib}. Его суть заключается в том, что на стадии компиляции  по описанию типа данных автоматически генерируется нужные преобразования, специализированные для указанных типов данных.

При использовании обобщенного программировании переиспользование кода достигается путём композиции порождённых на стадии компиляции преобразований с другими преобразованиями и прочими функциями. Это достаточно гибкий подход, который хорошо себя показывает в большинстве случаев, и поэтому он довольно популярен у разработчиков на \ocaml~и \haskell. Однако, в некоторых случаях его может быть недостаточно. Если разработчика не вполне устраивает порожденное преобразование, (например, если ему необходимо немного видоизменить обработку одного алгебраического конструктора из десяти), то он может действовать двумя способами. Во-первых, он может реализовать новый вид преобразования для своих нужд. В этом случае у разработчика могут возникнуть трудности, так как разработка новых преобразований требует некоторых специфических знаний (например, об абстрактном синтаксическом дереве языка программирования), мало применимых при повседневной разработке программного обеспечения. Другим способом решения проблемы может быть реализация необходимого преобразования вручную без использования подхода обобщённого программирования. В этом случае увеличится размер кодовой базы и может усложниться поддержка программного продукта в долгосрочной перспективе.

Заметим, что данная проблема не является таковой в традиционных объектно-ориентированных языках программирования, где разработчику легко удается воспользоваться \emph{поздним связыванием}. Этот приём в функциональных языках программирования используется редко либо по причине отсутствия языковой поддержки объектно-ориентированного программирования (\haskell), либо потому, что объектно-ориентированных подход нарочно избегается и используется только в тех случаях, когда он существенно удобнее~\cite{modules-vs-objects}. Поэтому, открытым вопросом\footnote{research question 1} является поиск способа использования объектно-ориентированных идей в функциональном программировании на \ocaml~ так, чтобы получившийся результат выглядел знакомо и естественно для практикующего разработчика на функциональном языке.
В данной работе предлагается представление преобразований с помощью объектов таким образом, что минимальной видоизменяемой единицей является код, обрабатывающий отдельный конструктор алгебраического типа данных. В процессе изложения мы продемонстрируем, что кодирование преобразований дает достаточно свободы, чтобы видоизменять преобразования желаемым способом\footnote{research question 2}.

В данной работе представлен подход, добавляющий к обобщенному  программированию идею \emph{позднего связывания}, зачастую свойственную объектно-ориентированному программированию. При этом сохраняются основные особенности обобщённого программирования, что позволяет получить преобразования, которые выглядят для практикующего программиста на \ocaml~знакомо и естественно. Для испытания подхода была спроектирована библиотека \textsc{GT}\footnote{\url{https://github.com/kakadu/GT/tree/ppx}} (\emph{Generic Transformers}) для языка \ocaml, где реализованы методы получения стандартных преобразований, аналогичных тем, что предоставляются популярными библиотеками обобщенного программирования, а также методы получения других стандартных преобразований.

