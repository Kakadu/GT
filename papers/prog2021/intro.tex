% !TeX encoding = windows-1251
\section{Введение}


\begin{comment}

Фредерк Брукс (Frederic Brooks) в своей известной книге по инженерии
программ  "Мифический человеко-месяц" ("The Mythical Man-Month")~\cite{MMM} охарактеризовал сущность программирования следующим образом:

\blockquote{"Программист, подобно поэту, работает почти непосредственно с чистой мыслью. Он строит свои замки в воздухе и из воздуха, творя силой воображения. Трудно найти другой материал, используемый в творчестве, который столь же гибок, прост для шлифовки или переработки и доступен для воплощения грандиозных замыслов. (Как мы позднее увидим, такая податливость таит свои проблемы.)"}

Действительно, нематериальность программ и гибкость их представления  призывает к структурированию; отсутствие подходящей структуры легко может привести к катастрофическим последствиям
(как это случалось с некоторыми промышленными проектами в прошлом). 
\end{comment}

Одной из проблем в современной разработке программного обеспечения является неправильно разработанная архитектура, которая может привести к плохой структуре программного продукта. Отсутствие подходящей структуры легко может привести к катастрофическим последствиям
(как это случалось с некоторыми промышленными проектами в прошлом). 
Одним из наиболее распространенных способов структурировать программы является использование \emph{типов данных}. Они позволяют описывать свойства данных; что можно с ними сделать, а что нельзя; а также в некоторой степени описывают семантику структур данных. Если информация о типах данных присутствует во время работы программы, то становится возможным реализовать мета-преобразования путём анализа типов (\emph{интроспекция}) или путём создания новых типов данных на лету (\emph{рефлексия}).

Однако, в статически типизированных языках, как правило, типы полностью стираются 
после фазы компиляции и отсутствуют во время исполнения. Статическая типизация обладает серьёзным преимуществом по сравнению с динамической, потому что программам
не нужно инспектировать типы во время выполнения и больше количество плохих поведений программ -- ошибок типизации -- не случается. С другой стороны, некоторые преобразования, которые в динамических языках могли быть реализованы ``раз и навсегда'' не проходят проверку типов и должны быть перереализованы для каждого конкретного типа по отдельности. Одни из подходов к преодолению этого недостатка является разработка более выразительной системы типов, где большее количество функций может быть протипизировано. Примером этому подходу будет поддержка перегрузки (\emph{ad hoc} полиморфизма) в языке \haskell в виде классов 
типов~\cite{TypeClasses} и семейств типов~\cite{TypeFamilies}. Однако, по причине требования тотальности к алгоритму проверки типов и фундаментальной неразрешимости проблемы проверки типов, всегда будут существовать ``хорошие'' программы, которые
не могут быть протипизированы. Другим подходом является \emph{обобщенное программирование}~\cite{DGP} (\emph{datatype-generic programming}), целью которого является разработка методов для реализации практически важных семейств функций
индексированных типами, использую имеющиеся возможности языка. Например, типы могут быть закодированы на внутреннем языке~\cite{Hinze,InstantGenerics,GenericOCaml}, либо часть информации о типах может быть сделана доступной во время исполнения, или 
обобщенные функции для конкретного типа данных могут быть сгенерированы во время
компиляции автоматически~\cite{Yallop,PPXLib}. Два похода, описанные нами, дополняют друг друга: чем более мощной является система типов, тем больше возможностей для обобщенного программирования язык может предложить. Например, параметрический полиморфизм позволяет естественно выразить функцию для вычисления длины списка произвольных элементов и т.п.

Отдельно стоит отметить подход под названием  ``Scrap Your Boilerplate''~\cite{SYB,SYB1,SYB2}, который позволяет и извлекать из значений некоторые из части, удовлетворяющие условию. Однако, наш опыт показал, что выразительность и расширяемость SYB недостаточна, к тому же преобразования, которые зависят только от типа, не очень удобно использовать. 

В предыдущих подходах переиспользование преобразований достигается путём их композиции. Другой возможной идеей является использование  позднего связывания (late binding) для того, чтобы видоизменять части сгенерированных преобразований под нужды программиста. Эта идея была использована про реализации библиотеки  \textsc{Visitors}~\cite{Visitors}.




Мы представляем библиотеку для обобщенного программирования \textsc{GT}\footnote{\url{https://github.com/kakadu/GT/tree/ppx}} (\emph{Generic Transformers}), которая находится в активной разработке с 2014 года. В ней используется идея позднего связывания на основе объектов в языке \ocaml, как и в~\visitors. Однако, некоторые дизайнерские решения в \visitors, которые мы считаем непреодолимыми,   не позволяют нам использовать её в проекте \ocanren.

