\section{Введение}


Обобщённое программирование нацелено на предание  языкам программирования большей гибкими без потери  типовой безопасности~\cite{DGP}.
%{\color {blue} нужна ссылка на классическую работу по обобщенному программированию}. 
В частности, предлагается  на стадии компиляции программы автоматическое порождение   для её типов данных ряда преобразований с целью инкапсуляции работы с этими типами. Обобщённое программирование широко применяется  к алгебраическим типам данных в  классических типизированных функциональных языках программирования (\ocaml{}, \haskell{}), а также начинает использоваться в объектно-ориентированных языках и платформах, например, \textsc{.NET Source Generators}~\cite{dotNetSG}.

При использовании обобщённого программирования бывают ситуации, когда автоматически сгенерированные преобразования не имеют необходимой для данной задачи функциональности. В объектно-ориентированных языках программирования  преобразования представляются в виде расширяемых объектов, и у программиста имеется возможность их менять. Но в функциональных языках такие преобразования генерируются в виде готовых функций, и менять их не представляется возможным.  Соответственно, применение обобщённого программирования для получения расширяемых преобразований в функциональных языках наталкивается на препятствия.

В~\cite{Visitors} предложена идея применить в \ocaml{} %\footnote{Там только про \ocaml{}, поэтому я исправил {\sout{функциональных языках}}}
 элементы объектно-ориентированного подхода для решения этой проблемы.%\footnote{{\color {blue} Возможно, еще кого-то процитировать, кто пытался делать это же - и так бы даже лучше было бы.} Ссылки на другие статьи не дам, потому что для \ocaml{} никто больше не пытался применять объекты для этого. }. 
Однако указанный подход страдает несколькими недостатками. Во-первых, 
%в только что порожденных объектах отсутствует реализация некоторых методов, поэтому их нельзя немедленно создавать и применять. По этой же причине 
подход~\cite{Visitors} не предоставляет привычный разработчику интерфейс в виде функций-преобразований. Во-вторых, подход систематически нарушает барьер абстракции: в порожденных объектах появляется доступ к деталям реализации типа, которые разработчик пожелал оставить скрытыми.
%, а также из-за особенности типизации порождаемых объектов порождение исходного кода в интерфейсах модулей \ocaml{} не применимо в принципе.


В данной работе\!\blfootnote{Данная работа была представлена на ML Family Workshop при конференции ICFP 2018.} идея применять в функциональных языка  элементы объектно-ориентированного подхода существенно дорабатывается гибким сочетанием объектов и функций для представления типовых преобразователей с возможностью их изменения программистом под особенности решаемой задачи. Мы ограничились языком \ocaml{}, но подход должен быть легко применим и к другим языкам, где есть поддержка объектно-ориентированного программирования, например, \Scala{}. %\footnote{Я не очень хочу писать про адаптацию в других языках, потому что, например, в \haskell{} объектов вообще нет, поэтому подход плохо адаптируемый. А в \Scala{} поддержка объектов выпячивается, наоборот, чересчур сильно, в то время как в \ocaml{} наоборот, систематически придумываются фичи, чтобы полезность объектов сходила на нет. Да и алгебраических данных, в Scala, формально говоря, нет -- они эмулируются объектами}.
Мы реализуем  минимально необходимый интерфейс доступа к преобразованию в  случаях, когда разработчик желает скрывать реализацию исходного типа данных.
Функции-преобразования, построенные из объектов, имеют интерфейс привычный для пользователей~\cite{ppxderiving}.
%На основе объектов строим функции, представляющие преобразования, которые имеют такой же интерфейс, как при использовании стандартных подходов~\cite{ppxderiving} к обобщенному программированию на \ocaml{}. Благодаря этому, порожденные преобразования будут иметь знакомый разработчику интерфейс, в отличие случая, когда используется~\cite{Visitors}.
%{\color {blue} тут не хватает какого то коротенького заключения}. 
Предложенный подход был реализован в  библиотеке \GT{}\footnote{\url{https://github.com/kakadu/GT/tree/ppx}} (\emph{Generic Transformers}) для языка \ocaml{}. Мы  реализовали методы получения стандартных преобразований, аналогичных тем, что предоставляются популярными библиотеками обобщенного программирования, а также методы получения других преобразований.
Наш подход позволил, в отличие от~\cite{Visitors},  поддержать полиморфные вариантные типы  \ocaml{}. Но эксперименты показали, что  работать с нерегулярными~\cite{irregular} алгебраическими типами данных стало не так удобно.
%{\color{blue} что это означает? осложнилась работа - как это?} 

\begin{comment}
\section{Введение от 26.11}

Обобщённое программирование нацелено на предание  языкам программирования большей гибкими без потери  типовой безопасности {\color {blue} нужна ссылка на классическую работу по обобщенному программированию}. В частности, предлагается  на стадии компиляции программы автоматическое порождение   для её типов данных ряда преобразований с целью инкапсуляции работы с этими типами~\cite{DGP}. Обобщённое программирование широко применяется  к алгебраическим типам данных в  классических типизированных функциональных языках программирования (\ocaml{}, \haskell{}), а также начинает использоваться в объектно-ориентированных языках и платформах, например, \textsc{.NET Source Generators}~\cite{dotNetSG}.


При разработке программного обеспечения на функциональных языках программирования, зачастую бывает необходимо реализовывать однотипные преобразования для различных структур данных. Для динамически типизированных языков (например, \scheme{}) есть возможность  реализовать одну функцию-метапреобразование, подходящую для всех структур данных. В языках, среды исполнения которых содержат информацию о типах (например, \Scala{}), имеется  возможность построить метапреобразование во время исполнения, полагаясь на динамический анализ типов  (интроспецию) и создание новых типов данных "на лету" (рефлексия). 
 Для статически типизированных языков программирования, в средах исполнения которых информация о типах обычно не доступна во время исполнения (например, \ocaml{} и \haskell{}), применяется подход под названием 
\emph{обобщенное (generic) программирование}~\cite{Yallop,PPXLib}: 
на стадии компиляции  по описанию типа данных автоматически генерируется нужные преобразования, специализированные для указанных типов данных. 
Обобщённое программирование является стандартным подходом для этих языков, поэтому различным его модификациям крайне желательно, как минимум, повторять его функциональность, а также предоставлять такой же интерфейс использования, чтобы выглядеть знакомыми и понятными практикующему разработчику.


При использовании обобщённого программирования бывают ситуации, когда автоматически сгенерированные преобразования не имеют необходимой для данной задачи функциональности. В объектно-ориентированных языках программирования  преобразования представляются в виде расширяемых объектов, и у программиста имеется возможность их менять. Но в функциональных языках такие преобразования генерируются в виде готовых функций, и менять их не представляется возможным.  Соответственно, применение обобщённого программирования в функциональных языках наталкивается на препятствия.

В ~\cite{Visitors} предложена идея применить в функциональных языках элементы объектно-ориентированного подхода для решения этой проблемы. Однако {\color {blue} ......И тут надо описать, чем эта идея недостаточна, плоха. Возможно, еще кого-то процитировать, кто пытался делать это же - и так бы даже лучше было бы.} 

В данной работе идея применять в функциональных языка  элементы объектно-ориентированного подхода существенно дорабатывается гибким сочетанием объектов и функций для представления типовых преобразователей с возможностью их изменения программистом под особенности решаемой задачи. Мы ограничились языком \ocaml{}, но {\color {blue} тут бы заявить, что все тоже может использоваться и в других функциональных языках, и мы обсуждаем, как наше решение может быть адаптировано для Haskell и ряда других языков. Причем тут вполне можно ограничиться небольшим обсуждением. Но, конечно, в ситуации, когда все предложенное в принципе переносится на другие функциональные языки.}  

В объектам мы реализуем  минимально необходимый интерфейс {\color {blue} интерфей к чему?}, чтобы не показывать детали реализации типа данных {\color {blue} кому не показывать}, которые разработчик желает держать скрытыми. Далее, на основе объектов мы строим функции, представляющие преобразования, чтобы преобразования  выглядели в обычной для  \ocaml{} стиле. {\color {blue} тут не хватает какого то коротенького заключения}. Предложенный подход был реализован в  библиотеке \GT{}\footnote{\url{https://github.com/kakadu/GT/tree/ppx}} (\emph{Generic Transformers}) для языка \ocaml{}. Мы  реализовали методы получения стандартных преобразований, аналогичных тем, что предоставляются популярными библиотеками обобщенного программирования, а также методы получения других преобразований.
Наш подход позволил, в отличие от~\cite{Visitors},  поддержать полиморфные вариантные типы  \ocaml{}. Но наши эксперименты показали, что осложнилась работа с нерегулярными~\cite{irregular} алгебраическими типами данных. {\color{blue} что это означает? осложнилась работа - как это?} 

\end{comment}
