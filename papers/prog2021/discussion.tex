% !TeX encoding = UTF-8
\section{Обсуждение результатов}
\label{sec:discussion}

Наиболее близком аналогом нашего подхода является подход
 \visitors{}, который также кодирует конструкторы алгебраических типов один к одному в методы объектов. %, но при этом в этих объектах также присутствуют другие методы.

Основным достоинством подхода, предложенного в \visitors{}~\cite{Visitors}, является поддержка нерегулярных типов данных. Чтобы её реализовать, при автоматическом построении объектов к типам методов добавляются \emph{явные аннотации полиморфизма (explicit polymorphism)\footnote{\url{https://caml.inria.fr/pub/docs/manual-ocaml/polymorphism.html\#s\%3Apolymorphic-recursion}}}. Однако, данная особенность не позволяется выразить пример с логическими списками (раздел \ref{sec:lists}), и поэтому подход \visitors{} не применим для \OCanren{}.
%При использовании нашего подхода порождать преобразования для нерегулярных типов не получится, но если эти типы разработчик описывает сам, то он может абстрагировать тип от нерегулярного вхождения. Это позволит разбить определение типа на несколько более мелких, для которых, по-отдельности, предложенный в данной работе метод, будет работать. Мы также хотим отметить, что в нашей практике нерегулярные типы данных встречаются редко, поэтому мы считаем это недостаток нашего подхода не очень существенным.

Наш подход позволяет порождать преобразования для полиморфных вариантных типов языка \ocaml{}, в то время как эти типы в \visitors{} не поддерживаются. С помощью  подхода  \visitors{} это сделать невозможно.

Стандартные подходы к обобщенному программированию на \ocaml{} порождают преобразования, представленные функциями. Наш подход представляет преобразования как объекты, и по этим объектам также строит функции-преобразования, поэтому наш подход предоставляет тот же интерфейс для разработчика, как и стандартные~\cite{PPXLib,ppxderiving} подходы к обобщённому программированию на \ocaml{}. В \visitors{} функции-преобразования не создаются, а иногда даже не могут быть построены, и поэтому использование этого подхода будет менее привычно для разработчика.

В нашем подходе у классов, представляющих преобразование, может быть очень много типовых параметров, что увеличивает размер порождаемого кода. В \visitors{} это неудобство частично исправлено: там применен особый способ указания одного типового параметра вместо $3*n$, где $n$ -- это количество типовых параметров. Однако, такое решение не позволяет порождать код в файлах интерфейса языка \ocaml{}, что может оказаться существенным недостатком при промышленной разработке программного обеспечения.

При использовании \visitors{} в порожденных классах также будут присутствовать методы для преобразования отдельных типов данных. Подход \GT{} не позволяет переопределять преобразования кокретных типов в рамках объекта-преобразования, поэтому сигнатура объектов компактнее.
%это вынесено отдельно \textcolor{red}{НАВОРОЧЕНО} для удобного получения функций-преобразований из классов.
Недостатком подхода \visitors{} является нарушение принципа абстракции: разработчику разрешено переопределять преобразования отдельных типов, что потенциально может нарушить инварианты, которые проверяются про построении значений типов данных. С другой стороны, такой дизайн позволяет реализовать преобразования, для которых хорошо себя показывается подход \cite{SYB}, но мы считаем, что такого рода преобразования имеют малую практическую ценность.

Сделанные измерения производительности показывают, что при построении расширяемых преобразований итоговая производительность уменьшается по сравнению с нерасширяемыми. Для первого  преобразования, где измеряется производительность обхода выражения без полезной нагрузки, эти накладные расходы значительны. Однако, для второго вида преобразований обход структуры $\lambda$-выражения занимает малую часть, и поэтому накладные расходы на объявление расширяемых преобразований приемлемы.

