% !TeX encoding = windows-1251
Наиболее близком аналогом нашего подхода является метод, предложенный в библиотеке \visitors{}, который также кодируется конструкторы алгебраических типов один-к-одному в методы объектов, но при этом там также присутствуют другие методы.

Основным достоинством подхода, предложенного в \visitors{}~\cite{visitors}, является поддержка нерегулярных типов данных. Чтобы её реализовать, при автоматическом построении объектов к типу методов добавляются \emph{явные аннотации полиморфизма (explicit polymorphism)\footnote{\url{https://caml.inria.fr/pub/docs/manual-ocaml/polymorphism.html\#s\%3Apolymorphic-recursion}}}. Однако, данная особенность не позволяется выразить пример с логическими списками (раздел \ref{sec:lists}), и поэтому подход \visitors{} не применим для \OCanren{}.

При использовании нашего подхода порождать преобразования для нерегулярных типов не получится, но если эти типы разработчик описывает сам, то он может абстрагировать тип от нерегулярного вхождения. Это позволит разбить определение типа на несколько более мелких, для которых, по-отдельности, предложенный в данной работе метод, будет работать. Мы также хотим отметить, что в нашей практике нерегулярные типы данных встречаются редко, поэтому мы считаем это недостаток нашего подхода не очень существенным.

Наш подход позволяет порождать преобразования для полиморфных вариантных типов языка \ocaml{}, в то время как эти типы в \visitors{} не поддерживаются. Мы изучили реализацию \visitors{} и не знаем простого способа добавить туда поддержку этих типов.

Стандартные подходы к обобщённому программированию на \ocaml{} порождают преобразования, представленные функциями. Наш подход представляет преобразования как объекты, и по этим объектам также строит функции-преобразования, поэтому наш подход предоставляет тот же интерфейс для разработчика, как и стандартные~\cite{ppxderiving,PPXLib} подходы к обобщённому программированию на \ocaml{}. В \visitors{} функции-преобразования не создаются, и поэтому использование этого подхода будет менее привычно для разработчика.

В нашем подходе в классов, представляющих преобразование, может быть очень много типовых параметров, что увеличивает размер порождаемого кода. В \visitors{} это неудобство частично исправлено: там применен особый способ указания одного типового параметра вместо $3\cdot(n+1)$, где $n$ -- это количество типовых параметров. Однако, такое решение не позволяет порождать код в файлах интерфейса языка \ocaml{}, что может оказаться существенным недостатком при промышленной разработке программного обеспечения.

При использовании \visitors{} в порожденных классах также будут присутствовать методы для преобразования отдельных типов данных, в то время как в \GT{} это вынесено отдельно для удобного получения функций-преобразований из классов. Недостатком подхода в \visitors{} является нарушение принципа абстракции: разработчику разрешено переопределять преобразования отдельных типов, что потенциально может нарушить инварианты, которые проверяются про построении значений типов данных. С другой стороны, такой дизайн позволяет реализовать преобразования, для которых хорошо себя показывается подход \cite{SYB}, хотя мы считаем, что полезность такого рода преобразований достаточно редка.

