% !TeX encoding = windows-1251
\section{План}



\subsection{Метод}
В статье на ML Workshop мы писали тут детали реализации, а именно какой код стоит генерировать по типам данных, чтобы получилось сделать то, что хочется сделать. Как это написать, не скатившись в детали реализации -- мне пока не понятно.
\subsection{Результаты}



\subsection{Background}

Описание предметной области и Используемые технологии есть во введении

Результаты предыдущих (собственных) исследований отсутсвуют.

Не знаю что тут писать


\subsection{Related works}
\begin{itemize}
\item  Стандартные подходы про обобщённое программирование, в том числе ppx\_deriving, который все сейчас в \ocaml используют
\item Обощенное программирование с использование "представлений типов"
\item Scrap Your Boilerplate -- специфический вид обобщенного программирования
\item Алгебры объектов -- что-то подобное тому, что мы хотим, но чисто в ОО-стиле
\item \cd{ppx\_traverse} делает примерно то же, что и мы, только кодирует типы как попало, без идеи "один конструктор -- один метод"
\item \visitors~главный конкурент, так как он использует ту же идею, но реализованную по-другому. Предлагаю здесь их просто упомянуть и содержательно сравниваться с ними в evaluation 
\end{itemize}

\subsection{Evaluation}
Здесь планируется \textbf{пример №1}, чтобы показать, что наше видоизменение трансформаций в принципе работает (ответ на RQ 2)

У нас основной конкурент -- это \visitors, поэтому здесь сравниваемся в основном с ними
\begin{itemize}
\item[$\star$] У них чисто ОО подход, а у нас совмещенный, поэтому получающийся в  итоге код выглядит привычнее для функционального программирования (+ к ответу на RQ1)

\item[$\star\star$] У них добавляются некоторые искусственные методы в объекты, что позволяет из-за чего "протекает" абстракция и открываются возможности "сломать" преобразования

\item[$\star\star\star$] В \visitors~два немного отличающихся подхода к созданию преобразований, а одном получается выразить одни преобразования, а в другом другие. По сути в визиторах мы не можем выразить то,что нам надо для~\cite{OCanren} (про это можно сделать \textbf{пример №2}).
 У нас  же один подход, при котором получается выразить всё что надо. (Это к ответу на RQ1)

\item[$\star\star\star\star$] \visitors~ не поддерживают полиморфные вариантные типы, мы поддерживаем. Про это будет \textbf{пример №3} в на основе~\cite{PolyVarReuse,PolyVar}
\end{itemize}

\subsection{Discussion}
Обсуждение результатов+Полемика: \emph{пока плохо понимаю, что тут писать}.

\begin{enumerate}
\item Не смотря на то, что библиотека \visitors~не предоставляет привычный комбинаторный интерфейс, доработка её в этом аспекте не должна вызвать серьёзных проблем.
\item "Протекание" абстракции в библиотеке \visitors~ (а также в подходе SYB~\cite{SYB}) позволяет удобно реализовывать некоторые преобразования, типичные для подхода SYB. При нашем подходе реализация таких преобразований вызовет сложности, однако, мы находим преобразования в стиле SYB чересчур специфическими и мало полезными на практике.
\item Сейчас реализация \visitors~полагается на использование \emph{явного полиморфизма}\footnote{\url{https://caml.inria.fr/pub/docs/manual-ocaml/polymorphism.html\#s\%3Apolymorphic-recursion}} при указании типа методов объектов. При таком подходе не понятно как добавлять поддержку полиморфных вариантных типов. Наш опыт говорит, что ради поддержки полиморфных вариантных типов от явного полиморфизма придется отказаться, но тогда новая реализация \visitors~будет почти в точности повторять подход \GT.
\end{enumerate}



