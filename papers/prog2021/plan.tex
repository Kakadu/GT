% !TeX encoding = windows-1251
\section{План}



\subsection{Метод}
В статье на ML Workshop мы писали тут детали реализации, а именно какой код стоит генерировать по типам данных, чтобы получилось сделать то, что хочется сделать. Как это написать, не скатившись в детали реализации -- мне пока не понятно.
\subsection{Результаты}
\emph{Пока плохо понимаю, что тут писать}.

Был представлен подход по представлению преобразований с помощью объектов языка \ocaml. В данном представлении конструкторы алгебраических типов данных кодируются один к одному в методы, таким образом программист достаточно легко может изменить преобразование для некоторого конструктора алгебраического типа. Для испытания подхода была спроектирована библиотека обобщённого программирования \GT, в рамках которой реализован типичный набор преобразований.


\subsection{Background}

Описание предметной области и используемые технологии есть во введении

Результаты предыдущих (собственных) исследований отсутствуют.

\textit{Не знаю что тут писать}


\subsection{Related works}
\begin{itemize}
\item  Стандартные подходы про обобщённое программирование, в том числе ppx\_deriving, который все сейчас в \ocaml~используют
\item Обощенное программирование с использование "представлений типов"
\item Scrap Your Boilerplate -- специфический вид обобщенного программирования
\item Алгебры объектов -- что-то подобное тому, что мы хотим, но чисто в ОО-стиле для С\#/Java
\item \cd{ppx\_traverse} делает примерно то же, что и мы, только кодирует типы без  нашей идеи "один конструктор -- один метод"
\item \visitors~главный конкурент, так как он использует ту же идею, но реализованную по-другому. Предлагаю здесь их просто упомянуть и содержательно сравниваться с ними в evaluation.
\end{itemize}

\subsection{Evaluation}
Здесь планируется \textbf{пример №1}, чтобы показать, что наше видоизменение трансформаций в принципе работает (ответ на RQ 2)

У нас основной конкурент -- это \visitors, поэтому здесь сравниваемся в основном с ней
\begin{itemize}
\item[$\star$] У них чисто ОО подход, а у нас совмещенный, поэтому получающийся в  итоге код выглядит привычнее для функционального программирования (+ к ответу на RQ1)

\item[$\star\star$] У них добавляются некоторые искусственные методы в объекты, что позволяет из-за чего "протекает" абстракция и открываются возможности "сломать" преобразования

\item[$\star\star\star$] В \visitors~два немного отличающихся подхода к созданию преобразований, а одном получается выразить одни преобразования, а в другом другие. Важно то, что в  \visitors~мы не можем выразить то, что нам надо для~\cite{OCanren} (про это можно сделать \textbf{пример №2}).
 У нас  же один подход, при котором получается выразить всё что надо. (+ к ответу на RQ2)

\item[$\star\star\star\star$] \visitors~ не поддерживают полиморфные вариантные типы, мы поддерживаем. Про это будет \textbf{пример №3} на тему \emph{expression problem}~\cite{ExpressionProblem}  на основе~\cite{PolyVar,PolyVarReuse}. Этот пример хочется включить, так как expression problem достаточно известная тема в сообществе и много кто предлагал различные подходы к её решению.
\end{itemize}

Также сюда можно добавить сравнение производительности нашего подхода с наивным подходом, где не подразумевается возможность последующего видоизменения преобразований (мы буквально это делаем для гранта).

\subsection{Discussion}
Обсуждение результатов+полемика: \emph{пока плохо понимаю, что тут писать}.

\begin{enumerate}
\item Не смотря на то, что библиотека \visitors~не предоставляет привычный комбинаторный интерфейс, доработка её в этом аспекте не должна вызвать серьёзных проблем.
\item ``Протекание'' абстракции в библиотеке \visitors~ (а также в подходе SYB~\cite{SYB}) позволяет удобно реализовывать некоторые преобразования, типичные для подхода SYB. При нашем подходе реализация таких преобразований вызовет сложности, однако, мы находим преобразования в стиле SYB чересчур специфическими и мало полезными для наших нужд.
\item Сейчас реализация \visitors~полагается на использование \emph{явного полиморфизма}\footnote{\url{https://caml.inria.fr/pub/docs/manual-ocaml/polymorphism.html\#s\%3Apolymorphic-recursion}} при указании типа методов объектов. При таком подходе не понятно как добавлять поддержку полиморфных вариантных типов. Наш опыт говорит, что ради поддержки полиморфных вариантных типов от явного полиморфизма придется отказаться, но тогда новая реализация \visitors~будет почти в точности повторять подход \GT.
\end{enumerate}



