\section{Введение в обобщенное программирование }
\label{sec:tutorial}

В этом разделе мы кратко представляем  подход обобщенного программирования по типам данных (datatype generic programming). В качестве примеров мы рассмотрим преобразования арифметических выражений.  Сначала -- самое простое преобразование в текстовое представление для демонстрации возможностей непосредственно обобщённого программирования. Затем рассмотрим другие преобразования, где мы будем представлять их с помощью объектов, а также покажем полезность расширяемых.


%В этом разделе мы постепенно представим наш подход используя несколько примеров. Хотя изложение не предоставляет конкретных деталей и не может использоваться как точная спецификация, мы здесь предоставляем основные составляющие решения и мотивацию, которая привела к ним.

В этой работе мы используем следующее соглашение: будем обозначать $\inbr{\dots}$ представление некоторого понятия в конкретном синтаксисе языка \textsc{OCaml}. Например, ``$\inbr{f_t}$`` является обозначением конкретной функции индексированной типом  ``$f$'' для типа ``$t$''. 
В конкретном синтаксисе оно может быть выражено как ``\lstinline{f_t}'', но мы пока воздержимся от указания конкретной формы.

%TODO: Подробнее написать где есть что, для людей, которые не очень 

\subsection{Преобразование ``\texttt{show}''}

Мы будем работать только с типом данных для арифметических выражений, которые состоят из констант, переменных и бинарных операций.

\begin{lstlisting}
type expr =
| Const of int
| Var   of string
| Binop of string * expr * expr
\end{lstlisting}

%TODO: Попытаться заострить "первый" уровень

Для него можно реализовать преобразование в строковое представление ``\lstinline{show}''
%``$\inbr{show_{expr}}$'' 
(наиболее естественный кандидат на реализацию),
которое преобразует выражение в строку: 

\begin{lstlisting}
let rec show = function
| Const  n         -> sprintf "Const %d" n
| Var    x         -> sprintf "Var %s" x
| Binop (op, l, r) ->
    sprintf "Binop (%S, %s, %s)" 
      op (show l) (show r)
\end{lstlisting}

Преобразования данного вида не очень сложно реализовывать вручную, но воспользоваться обобщённым программированием предпочтительнее. Чтобы это сделать (например, с использованием~\cite{ppxderiving})  необходимо проаннотировать тип данных и подключить специальный препроцессор времени компиляции. 

\begin{lstlisting}
type expr =
| Const of int
| Var   of string
| Binop of string * expr * expr
[@@deriving show]
\end{lstlisting}

\noindent В итоге, во время компиляции по типу данных ``\lstinline{expr}'' построится функция-преобразование ``\lstinline{show}'', которое можно будет использовать в остальной кодовой базе.

Преобразование 
``\lstinline{show}'',
%``$\inbr{show_{expr}}$'', 
сохраняет имена конструкторов, оно может быть
полезно при отладке или сериализации. Однако, как правило, также требуется иное преобразование, более ``красивое'' (\emph{pretty-printed}) и удобное для чтения человеком. 
В нём выражение представляется в ``естественном синтаксисе'': с использованием инфиксных операций, без имён конструкторов, и скобки расставлены только там, где они действительно нужны. Это преобразование может быть реализовано следующим образом:

\begin{lstlisting}
let pretty e =
  let rec helper p = function
    | Const n -> string_of_int n
    | Var x -> x
    | Binop (o, l, r) ->
        let po = prio o in
        sprintf "%s %s %s" 
          (helper po l) o (helper po r)
        |> if po <= p then br else Fun.id 
  in
  helper min_int e
\end{lstlisting}

\noindent Здесь мы пользуемся функциями ``\lstinline{prio}'', ``\lstinline{br}'' и ``\lstinline{id}'', доступными из вне. Функция ``\lstinline{prio}''
возвращает приоритет бинарной операции, ``\lstinline{br}'' окружает свой аргумент скобками, а ``\lstinline{id}'' --- тождественная функция.
Дополнительная функция ``\lstinline{helper}'' принимает числовой параметр, который обозначает приоритет окружающей операции (если такая имеется). Если приоритет текущей операции меньше или равен переданному, тогда выражение окружается скобками. На верхнем уровне мы передаем наименьшее возможное число как приоритет, чтобы убедиться, что мы не получим скобок, окружающих выражение целиком. Для простоты мы считаем, что все операции неассоциативны, но такой же шаблон кода может быть использован для поддержки ассоциативных операций.

Преобразование ``\lstinline{pretty}'' можно было бы реализовать тоже с помощью обобщённого программирования, но в имеющихся библиотеках~\cite{PPXLib,ppxderiving} \OCaml{} такой вид преобразований не поддерживается.

В оставшейся части главы мы расскажем, как можно представлять преобразования по-другому, а именно с помощью объектов, что позволит получать расширяемые преобразования. Более строгое изложения того, как должны быть устроены классы и объекты, можно найти в разделе~\ref{sec:implementation}.

Реализации этих двух функций имеют очень мало общего. Обе возвращают строки, но вторая принимает дополнительный аргумент, и 
правые части сопоставления с образцом для соответствующих конструкторов различаются. Единственной общей частью является
сопоставление с образцом само по себе. Мы можем реализовать его как отдельную функцию (\emph{обобщённый катаморфизм}, раздел~\ref{transtypes}) и параметризовать эту функцию набором  преобразований, 
соответствующих конструкторам:

% $\inbr{gcata_{expr}}$
\begin{lstlisting}
let gcata $\omega$ $\iota$ = function
| Const n         -> $\omega$#$\inbr{Const}$ $\iota$ n
| Var   x         -> $\omega$#$\inbr{Var}$   $\iota$ x
| Binop (o, l, r) -> $\omega$#$\inbr{Binop}$ $\iota$ o l r
\end{lstlisting}

Здесь мы представляем множество семантически связанных функций объектом ``$\omega$'', где методы соответствуют конструкторам
один к одному. \emph{Наследуемый атрибут} (раздел~\ref{transtypes}) ``$\iota$'' представляет дополнительный параметр, который может как использоваться функциями (например, ``pretty''), так и игнорироваться функциями (``show'').

Упомянутая выше функция ``show'' может быть реализована следующим образом\footnote{Для ясности понимания мы опустили некоторые аннотации типов, которые помогают этому листингу кода пройти проверку типов.}:

\begin{lstlisting}
let rec show e = gcata
  (object
    method $\inbr{Const}$ _ n = 
      sprintf "Const %d" n
    method $\inbr{Var}$  $\enspace$ _ x = sprinf "Var %s" x
    method $\inbr{Binop}$ _ o l r =
      sprintf "Binop (%S, %s, %s)" 
        op (show l) (show r)
  end)
  ()
  e
\end{lstlisting}

\noindent Функция ``\lstinline{pretty}'' может быть реализована аналогично.

%И, разумеется, всё то же  самое применимо к 

Заметим, что оба объекта, необходимые для реализации этих функций, могут быть экземплярами общего виртуального класса:

\begin{lstlisting}
class virtual [$\iota$, $\sigma$] $\inbr{expr}$ = object
  method virtual $\inbr{Const}$ : $\iota$ -> int -> $\sigma$
  method virtual $\inbr{Var}\enspace\;\;$ : $\iota$ -> string -> $\sigma$
  method virtual $\inbr{Binop}$ :
    $\iota$ -> string -> expr -> expr -> $\sigma$  
end
\end{lstlisting}

Конкретный класс, представляющий преобразование, будет наследоваться от этого общего предка. Чтобы иметь возможность 
вызывать рекурсивно данное преобразование, мы параметризуем класс функцией самотрансформации ``\lstinline{fself}'' 
(\emph{открытая рекурсия}). 
Написание в стиле открытой рекурсии необходимо для возможности поддержки полиморфных вариантных типов и рекурсивных определений.
Теперь преобразование выражений в удобный человеку формат может быть реализовано не в виде функции, а в виде расширяемого объекта  (обратите внимание на использование ``\lstinline{fself}''):

\begin{lstlisting}
class pretty (fself : $\iota$ -> expr -> $\sigma$) = 
object 
  inherit [int, string] $\inbr{expr}$ 
  method $\inbr{Const}$ _ n = sprintf "%d" n
  method $\inbr{Var}$ _ x = x
  method $\inbr{Binop}$ p o l r =
    let po = prio o in
    sprintf "%s %s %s" 
      (fself po l) o (fself po r)
    |> if po <= p then br else Fun.id
end
\end{lstlisting}

Функция-преобразование выражения  в строковый  формат может быть  описана с использованием класса, представленного выше, и обобщенной  функции-преобразования\footnote{Так как имена функций и классов находятся в разных пространствах имен в \textsc{OCaml}, мы можем использовать одно и то же имя для класса и функции-преобразования.}.

\begin{lstlisting}
let pretty e =
  let rec pretty_prio p = 
    gcata (new pretty pretty_prio) p 
  in
  pretty_prio min_int e
\end{lstlisting}

Также мы можем избежать объявления вложенной функции с помощью комбинатора неподвижной точки\footnote{Обычно, комбинатор неподвижной точки используется для определения рекурсивных функций, если не возможно вызывать определяемую функцию явно. В данном конкретном случае он также применяется для оптимизации, а именно экономии на создании объектов-преобразований.} ``\lstinline{fix}'' (раздел \ref{memofix}): 

\begin{lstlisting}
let pretty e = fix 
  (fun fself -> gcata (new pretty fself))
  min_int e
\end{lstlisting}

\subsection{Преобразование ``\texttt{fold}''} 

Выше мы смогли выделить две общие части для двух существенно различных преобразований: функцию обобщенного обхода
( ``\lstinline{gcata}'') и такой виртуальный класс (``\lstinline{expr}''), что все преобразования можно представить как его экземпляры.
Но стоило ли это того? В действительности, в этом примере мы добились не очень большого переиспользования кода путём добавления
большого количества абстракций. Итоговый код получился по размеру даже больше исходного.

Мы утверждаем, что преобразования в данном конкретном случае были недостаточно обобщенные. Чтобы оправдать описанный подход,
давайте рассмотрим более оптимистичный сценарий. Широко известно, что многие трансформации могут быть представлены 
(по понятным причинам) как \emph{катаморфизмы}, т.е. как ``свёртки''~\cite{CalculatingFP,Fold,Bananas}. 
Формально, чтобы определить канонический катаморфизм нам нужно абстрагировать тип ``\lstinline{expr}'' 
от самого себя\footnote{Подробнее см. в~\cite{CalculatingFP}}, но здесь мы воспользуемся более легковесным решением:


% ссылаться на разделы цитируемых у нас не принято
\begin{lstlisting}
class [$\iota$] fold (fself : $\iota$ -> expr -> $\iota$) = 
object 
  inherit [$\iota$, $\iota$] $\inbr{expr}$ 
  method $\inbr{Const}$ i n = i
  method $\inbr{Var}$ i x = i
  method $\inbr{Binop}$ i o l r = 
    fself (fself i l) r
end
\end{lstlisting}

\noindent Эта реализация просто передает ``$\iota$'' сквозь все узлы трансформируемого значения, что на первый взгляд выглядит довольно бесполезно.
Однако, слегка изменив поведение, можно получить кое-что полезное:

\begin{lstlisting}
let fv e = fix (fun fself ->
  gcata (object 
    inherit [string list] fold fself
    method $\inbr{Var}$ i x = x :: i
  end)) 
  [] e
\end{lstlisting}

\noindent Эта функция создает список всех свободных переменных в выражении, а так как в языке выражений нет способа связывать переменные, 
то это просто список всех переменных. Объект, который мы сконструировали, наследуется от ``бесполезного'' класса 
``\lstinline{fold}'' 
%``$\inbr{fold_{expr}}$'' 
и переопределяет только один метод -- метод для обработки переменных.
Весь остальной код уже работает так, как нам нужно~---
``\lstinline{gcata}''
%``$\inbr{gcata_{expr}}$'' 
обходит выражение, 
а остальные метода объекта аккуратно передают построенный список дальше.
Таким образом, мы смогли реализовать интересное преобразование с помощью очень малой модификации существующего кода, 
предоставленного уже имеющимся классом ``\lstinline{fold}''. 
%``$\inbr{fold_{expr}}$''. 

Чтобы избежать впечатления, что мы аккуратно подготавливались к
представлению именно этого примера, мы покажем ещё один:

\begin{lstlisting}
let height e = fix (fun fself ->
  gcata (object 
    inherit [int] fold fself
    method $\inbr{Binop}$ i _ l r = 
        1 + max (fself i l) (fself i r) 
  end)) 
  0 
  e
\end{lstlisting}

\noindent Здесь мы вычисляем высоту дерева выражения, используя  для другого самостоятельно объекта тот же самый базовый класс ``\lstinline{fold}''.
%``$\inbr{fold_{expr}}$'' 
Затем мы переопределяем метод для бинарного оператора, который теперь будет вычислять высоты поддеревьев, выбирать из них максимальную высоту и прибавлять единицу.

\subsection{Преобразование ``\lstinline{map}''} 

Одной из других всеми известных обобщенных функций является ``map'', которую мы строим в предположении, что тип ``\lstinline{expr}'' является функтором:

\begin{lstlisting}
class map fself = object 
  inherit [unit, expr] $\inbr{expr}$
  method $\inbr{Var}$ _ x = Var x
  method $\inbr{Const}$ _ n = Const n
  method $\inbr{Binop}$ _ o l r = 
    Binop (o, fself () l, fself () r)
end
\end{lstlisting}

\noindent У данного типа нет типовых параметров, поэтому для данного случая преобразование ``\lstinline{map}'' ---~это тривиальное копирование. Но это преобразование может служить основой для некоторых других преобразований, например, 
новый вид преобразования может быть получен, как результат наследования от этого класса и переопределения метода $\inbr{Binop}$:

%Так как нам не известно, что ``\lstinline{expr}'' -- это функтор, то всё, что мы можем сделать в функции ``\lstinline{map}'' --- 
%это копирование. \footnote{Тут надо подробнее почему функциторность важна и почему мы не можем что-то сделать} \textcolor{red}{ Однако, отнаследовавшись от этого класса, мы может получить новый вид преобразований}\footnote{Новый вид преобразования может быть получен, как результат наследования от этого класса или типа того}:

\begin{lstlisting}
class simplify fself = object 
  inherit map fself
  method $\inbr{Binop}$ _ o l r =
    match fself () l, fself () r with
    | Const l, Const r -> 
        Const ((op o) l r)
    | l, r -> 
        Binop (o, l, r)
end
\end{lstlisting}

\noindent Данный класс производит упрощение выражения: если оба аргумента бинарной операции вычисляются в константу тем же самым преобразованием, тогда 
мы можем произвести операцию сразу. Функция ``\lstinline{op}'' объявлена где-то ещё, она возвращает функцию, которая будет производить вычисление данного бинарного оператора.

Вот ещё один пример:

\begin{lstlisting}
class substitute fself state = object 
  inherit map fself
  method $\inbr{Var}$ _ x = Const (state x)  
end
\end{lstlisting}

\noindent Здесь мы выполняем подстановку переменных в выражении на значения, определенные в некотором состоянии, представленном функций ``\lstinline{state}''. Два класса, объявленных выше могут быть скомбинированы для получения интерпретатора выражений:

\begin{lstlisting}
class eval fself state =  object
  inherit substitute fself state
  inherit simplify   fself
end

let eval state e =
  fix (fun fself ->
    gcata (new eval fself state)) () e  
\end{lstlisting}

Во всех примерах мы выбрали достаточно стандартные преобразования и можно сказать, что реализовали всё достаточно малыми усилиями,
если закрыть глаза на несколько многословный синтаксис классов и объектов в  \textsc{OCaml}. В каждом случае было необходимо переопределить
только один метод и воспользоваться функцией, однозначно получаемой по типу. 
С другой стороны, мы работали с очень просто устроенным типом, он даже не был полиморфным, а поддержка полиморфизма может привести к 
специфическим проблемам. В оставшейся части работы мы покажем, что идеи, представленные выше, могут быть реализованы с помощью обобщенного программирования, где все компоненты могут быть синтезированы из объявления типа. 

\begin{comment}



В частности, наш подход предоставляет полную поддержку:

\begin{itemize}
\item полиморфизма;
\item применения типовых операторов (type operators);
\item взаимной рекурсии, где поддержка воистину \emph{расширяемых} преобразований потребует некоторых усилий;
\item полиморфных вариантных типов, с которыми будет необходимо позаботиться о гладкой интеграции возможностей полиморфных вариантом и наследования классов;
\item раздельной компиляции --- мы можем сгенерировать код по определениям типов не заглядывая внутрь модулей, от которых зависит обрабатываемый тип;
\item инкапсуляции, а именно поддержки сигнатур модулей, включая абстрактные типы и приватные определения. Обобщенные функции для абстрактных типов могут использоваться из вне модуля, но не позволят инспектировать или изменять содержимое абстрактного типа.
\end{itemize}

Что касается вопросов производительности, то как Вы могли заметить, во всех примерах мы создавали большое количество 
\emph{идентичных} объектов во время преобразования (под одному на каждый узел структуры данных). Далее мы увидим, что с этим можно побороться
с помощью мемоизации. Наконец, наш подход предоставляет система плагинов, которые могут быть использованы для генерации большого количества преобразований, как, например, ``\lstinline{show}'', ``\lstinline{fold}'' или ``\lstinline{map}''. Система плагинов расширяема, т.е. пользователи могут  реализовать их собственные плагины с помощью небольших усилий, так большая часть функциональности по обходу структуры данных предоставляется библиотекой. 
\end{comment}