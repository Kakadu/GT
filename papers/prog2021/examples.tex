\section{Реализация и примеры}
\label{sec:Evaluation}

Представленный метод был реализован в библиотеке Generic Transformers\footnote{\url{https://github.com/Kakadu/GT/tree/v0.3.0}} (\GT). Библиотека  поддерживает два наиболее распространенных вида синтаксических расширений языка \ocaml{}: \textsc{PPX}~\cite{PPXLib} и \camlpfive~\cite{camlp5}. Библиотека \GT{} является расширяемой: к ней прилагается интерфейс для добавления пользовательских плагинов, реализующих порождение новых видов преобразований, а также набор стандартных преобразований, использующихся в других подобных библиотеках.


В этом разделе мы представим несколько примеров, реализованных с помощью нашего подхода. В них используются синтаксические расширения \camlpfive{}, но это же может быть реализовано также с использованием \PPX{}. Данные примеры продемонстрируют практическую полезность предлагаемого метода для полиморфных вариантных типов языка \OCaml{} и типов с неограниченной рекурсией, а также  помогут ответить на \emph{RQ1: <<Какие виды расширяемых преобразований можно реализовывать с нашим интерфейсом объектов-преобразований, а какие нет?>>}
%Эффективно ли  кодирование конструкторов один к одному в методы объектов, позволяет ли оно описывать достаточно разнообразные расширяемые преобразования?>>}.

%\textcolor{red}{Сложносочиненные предложения в RQ плохо.}

Предложенный в работе метод позволяет получать расширяемые преобразования путём непрямого вызова частей преобразования. Такой подход приносит некоторые потери производительности. В разделе ~\ref{sec:performance} мы оценим производительность четырех методов построения расширяемых преобразований, что поможет ответить на 
\emph{RQ2: <<Какова скорость выполнения расширяемых преобразований по сравнению с нерасширяемыми?>>}
%\textcolor{red}{Сказать про производительность}

\subsection{Рассмотренные примеры}

Сначала (раздел~\ref{sec:lists}) мы продемонстрируем совместимость 
нашего подхода для \emph{типов данных с неограниченной рекурсией}
(ключ компилятора \texttt{-rectypes}), 
реализовав
представление логических значений, использующихся в  библиотеке реляционного программирования \OCanren{}~\cite{OCanren}. %Особенностью данного примера является то, что в нём используется относительно редкий ключа компилятора \texttt{-rectypes} для объявления типов данных. Не всякое представление объектов-преобразований будет работать с типами данных, для которых необходим этот ключ компиляции.

Затем мы решим <<The Expression Problem>>~\cite{ExpressionProblem}
%, с помощью полиморфных вариантных типов и нашего подхода
 (раздел~\ref{sec:nameless}). Эта задача часто используется как ``лакмусовый тест'' для оценки подходов к обобщенному программированию~\cite{ObjectAlgebras,ALaCarte}. В литературе встречается различные подходы к решению этой задачи, но наша реализация данного примера интересна тем, что использует  и обобщенное программирование, и \emph{полиморфные вариантные типы} языка \OCaml{}.

Эти два примера демонстрируют использование предложенного метода с теми типами данных \OCaml{}, которые в данный момент не поддерживаются другими подходами к построению расширяемых преобразований (в частности, \visitors~\cite{Visitors}). 
%Также данные примеры помогут обосновать наш дизайн  интерфейса объектов, а именно ответить на вопрос: <<Эффективно ли  на практике кодирование конструкторов один к одному в методы объектов, позволяет ли оно описывать достаточно разнообразные расширяемые преобразования?>>.

%Убрать то, что справа:
%В нём мы будем отдельно описывать преобразования для различных частей языка, а потом объединять их с помощью наследования. Это пример также не может быть переписан с использованием \visitors{}, так как та не поддерживает полиморфные вариантные типы языка \ocaml{}.

В разделе~\ref{sec:irregular} мы обсудим работу с нерегулярными типами данных~\cite{irregular}, которые не поддерживаются нашим методом непосредственно, а требуют некоторого изменения способа объявления типов данных, чтобы наш метод был применим. %но поддерживаются при использовании \visitors{}.

% нерегулярными типами данных~\cite{irregular}
% вместо "нерегулярными~\cite{irregular} типами данных"
% потому что термин разрывается 

%Кроме того, перечисленные выше примеры важны для сравнения с подходом~\cite{Visitors}, который  в данный момент не поддерживает использование ключа \texttt{-rectypes} и полиморфные вариантные типы.

В разделе~\ref{sec:design} мы коснемся вопросов дизайна расширяемых преобразований, которые могут упростить или усложнить использование  разработчиками полученных преобразований. В заключительном разделе \ref{sec:performance} ---~вопросов производительности.

%TODO: вообще сравниваться непосредственно с Visitors не хорошо, будет выглядет как мелкое улучшение примеров.

%Может быть другого сорта мотивацию, сказать почему примеры важны (а в конце, "кроме того, примеры важны для сравнения с взиторами, потому что...)

%\subsection{Research Questions}
%Данные примеры помогут ответить на исследовательский вопрос:

%\textcolor{red} {Это не вопрос!!!} Также важно ответить на вопрос: <<Является ли предоставляемый интерфейс достаточно знакомым для практикующего разработчика на \ocaml{}?>>

%TODO: Тут сказать почему они важны

%\parbox{\textwidth}{
%\textcolor{blue} {Запихнуть RQ в предыдущий раздел}
%}

\subsection{Типизированные логические значения}
\label{sec:lists}

Этот пример появился во время работы над строго типизированным встроенным логическим предметно-ориентированным языком на основе \textsc{OCaml}~\cite{OCanren}. 
В нём одной из самых важных конструкций является унификация термов, содержащих свободные логические переменные. Работать с такими структурами данных сложно, а допустить ошибку --- легко. 
Типичным сценарием взаимодействия  
%между логическими и нелогическими (\textcolor{red}{ПЕРЕФРАЗИРОВАТЬ})  
% частями программ 
cо встроенным языком 
является 
создание так называемых \emph{целей вычислений} (goal), содержащих структуры данных со свободными логическими переменными.
Решением логической цели является подстановка переменных, правые части которой в идеальном случае не содержат свободных переменных. 
Чтобы сконструировать цель вычислений необходимо уметь систематически вводить логические переменные в типизированную структуру данных,  а для восстановления ответа -- систематически извлекать из представления, подходящего для работы с \OCanren{}, ответы в обыкновенном
%нелогическом(\textcolor{red}{ПЕРЕФРАЗИРОВАТЬ})  
представлении (т.е. без логических переменных).

Упрощенный тип для логических переменных может быть описан следующим образом:

\begin{lstlisting}
@type 'a logic =
| V     of int
| Value of 'a       with show
\end{lstlisting}
Логическое значение может быть либо свободной логической переменной (``\lstinline{V}'') или каким-то другим значением (``\lstinline{Value}''), которое не является свободной переменной, но потенциально может содержать свободные переменные.
\begin{comment}

Чтобы преобразовывать в и из логических значений, можно воспользоваться следующими функциями:

\begin{lstlisting}
let lift x = Value x

let reify  = function
| V     _ -> invalid_arg "Free variable"
| Value x -> x
\end{lstlisting}

Функция ``\lstinline{reify}'' бросает исключение для свободных переменных, так как в присутствии вхождений свободных переменных
логическое значение нельзя рассматривать как обыкновенную (нелогическую) структуру данных.
\end{comment}


Когда мы работем с логическими структурами данных, нам необходима возможность вставлять логические переменные в произвольные позиции.
Это означает, что мы должны использовать другой тип данных, подходящий для использования 
с точки зрения системы типов. Например,
для списков нам придется абстрагироваться от рекурсии, чтобы иметь возможность описать тип логических списков \lstinline{llist}\footnote{Этот способ применим только при использовании ключа компиляции \texttt{-rectypes}.}:

\begin{lstlisting}
type ('a, 'self) list_like = 
    | Nil 
    | Cons of 'a * 'self
type 'a list = ('a, 'a list) list_like
type 'a llist = 
    ('a, 'a llist) list_like logic
\end{lstlisting}
%которые будут иметь тип ``\lstinline{lexpr}'', объявленный как
%
%\begin{lstlisting}
%type expr' = Var of string logic | Const of int logic 
%           | Binop of lexpr * lexpr
%and  lexpr = expr' logic
%\end{lstlisting}

Если мы захотим, чтобы списки типа \lstinline{llist} без логических значений преобразовывались в строковое представление также, как списки типа \lstinline{list}, необходимо модифицировать преобразование типа \lstinline{logic} в строку, убрав название конструктора \lstinline{Value}:

\begin{lstlisting}
class ['a, 'self] my_show fa fself = 
object
  inherit ['a, 'self] $\inbr{show_{logic}}$ fa fself
  method c_Value () _ x = fa () x
end
\end{lstlisting}
В такой реализации преобразования логических значений, где мы изменили только один конструктор, мы можем объявить тип логических списков заново, и получить для него преобразование в строку, которое на списках без переменных работает так же, как и для типа \lstinline{list}.

Особенностью данного подхода является, во-первых, получение нового преобразования в строку путём изменения одного метода, а, во-вторых, способ объявления типов \lstinline{list} и \lstinline{llist}, который не удается переиспользовать при использовании подхода, предоставляемого \visitors{}.

%Нам также нужно реализовать две функции преобразования. Все эти определения представляют собой типичный пример однотипного (boilerplate) кода.
%
%С изпользованием нашего подхода решение почти полностью декларативно\footnote{При условии включения ключа компиляции \cd{-rectypes}}.
%Во-первых, мы абстрагируемся от интересующего нас типа, заменяя все его вхождения типовой переменной с не встречающимся ранее именем:

%\begin{lstlisting}
%@type ('string, 'int, 'expr) a_expr =
%| Var   of 'string
%| Const of 'int
%| Binop of 'string * 'expr * 'expr with show, gmap
%\end{lstlisting}
%
%Здесь мы абстрагировали тип от всего конкретного, но мы могли обойтись абстрагированием только от самого себя. Заметьте, что 
%мы воспользовались двумя видами обобщенных преобразований~--- ``\lstinline{show}'' и ``\lstinline{gmap}''. 
%Первое будет полезно для отладочных целей, а второе является необходимым для нашего решения.
%
%Теперь мы можем объявить логические и нелогические составляющие как специализации исходного типа:
%
%\begin{lstlisting}
%@type expr  = (string, int, expr) a_expr 
%  with show, gmap
%@type lexpr = (string logic, int logic, lexpr) a_expr logic 
%  with show, gmap
%\end{lstlisting}

%Обратите внимание, что ``новый'' тип ``\lstinline{expr}'' эквивалентен старому, следовательно, такое переписывание типов не нарушает существующий код.
%
%Наконец, определения функций преобразования воспользуются преобразованием, полученным с помощью плагина ``\lstinline{gmap}'', предоставляемого библиотекой:
%
%\begin{lstlisting}
%let rec to_logic   expr = gmap(a_expr) lift  lift  to_logic  expr
%let rec from_logic expr = gmap(a_expr) reify reify from_logic @@ 
%                           reify expr
%\end{lstlisting}
%
%Как вы видите, поддержка типовых операторов существенна для этого примера. В предыдущей реализации~\cite{TransformationObjects} типовые операторы не были поддержаны и их было не так просто добавить.

\subsection{Преобразование в безымянное представление}
\label{sec:nameless}

Полиморфные вариантные типы в языке \ocaml{} позволяют описывать структуры данных композиционально, статически типизировано и в разных модулях компоновки~\cite{PolyVarReuse}.
Целесообразно объявлять преобразования таких структур данных отдельно друг от друга. Задача конструирования преобразований для 
раздельно объявленных и строго типизированных компонент известна как ``проблема выражений'' (``The Expression Problem''~\cite{ExpressionProblem}).
%которая часто используется (\textcolor{red}{Убрать в 5.1}) как ``лакмусовый тест'' для оценки подходов к обобщенному программированию~\cite{ObjectAlgebras,ALaCarte}. 
В этом подразделе мы представим решение этой задачи в рамках нашего подхода. В качестве конкретной задачи мы реализуем преобразование $\lambda$-выражений в безымянное представление.

Во-первых, опишем часть языка выражений без связывающих конструкций:

\begin{lstlisting}
@type ('name, 'lam) lam = 
[ `App of 'lam * 'lam
| `Var of 'name
] with show
\end{lstlisting}

\noindent Выделение этого типа выглядит логично, так как 
кроме указанных двух конструкций, потенциально в языке могут появиться другие, которые будут связывать переменные 
($\lambda$-абстракции, \lstinline{let}-определения и т.д.). Комбинируя различные типы и преобразования этих типов, можно получать различные расширения деревьев абстрактного синтаксиса и преобразований для $\lambda$-выражений.
%, их с несвязывающими конструкциями, а также с ними самими, можно получать различные языки с согласованным поведением \textcolor{red}{ПЕРЕФРАЗИРОВАТЬ}.

Введенный выше тип ``\lstinline{lam}'' является полиморфным: первый параметр используется для представления имен или индексов %(или уровней) 
де Брёйна\footnote{Способ представления лямбда-выражений в безымянном виде предложенный де Брёйном в~\cite{deBruijn}.}, второй необходим для открытой рекурсии (здесь мы следуем  подходу к описанию расширяемых структур данных с помощью полиморфных 
вариантных типов~\cite{PolyVarReuse}).

Для данного типа преобразование в безымянное представление можно определить следующим образом:
%Рассмотрим как для такого типа должны выглядеть преобразование в безымянное представление, а именно, как должен выглядеть класс преобразования.
%Как должно выглядеть преобразование в безымянное представление для такого типа? А именно, как должен выглядеть класс преобразования? Это показано ниже:

\begin{lstlisting}
class ['lam, 'nless] lam_to_nameless
 (flam : string list -> 'lam -> 'nless) =
object
  inherit 
    [ string list, string, int
    , string list, 'lam, 'nless
    , string list, 'lam, 'nless] $\inbr{lam}$
  method $\inbr{App}$ env _ l r = 
    `App (flam env l, flam env r)
  method $\inbr{Var}$ env _ x   = `Var (index env x)
end
\end{lstlisting}

% TODO: Здесь у нас нет call-by-value, поэтому это нифига не интерпретатор

\noindent Здесь мы используем список строк для хранения подстановки переменных и  передаем его как наследуемый атрибут. Затем мы пользуемся функцией 
``\lstinline{index}'' чтобы найти строку в подстановке, т.е.  эта функция преобразует имя в индекс де Брёйна. 
Интересной частью преобразования является типизация общего класса предка ``$\inbr{lam}$''. 
Первая тройка параметров описывает преобразование первого типового параметра. Можно заметить, что мы преобразуем строки в числа используя подстановку.
Здесь типовая переменная ``\lstinline{'lam}'', 
%как мы знаем, 
приравнивается (раздел~\ref{pv}) открытой версии типа ``\lstinline{lam}''. %(ДОИСПРАВИТЬ)
Наконец, результат преобразования типизируется с помощью переменной ``\lstinline{'nless}'', введение которой необходимо для правильной реализации преобразования объединения типов.
%Так происходит именно так потому, что, как будет понятно позднее,  это будет действительно другой тип. (\textcolor{blue}{Сказать прямее, может даже лишнее предложение})
Так как второй типовый параметр обычно ссылается рекурсивно на себя, третья тройка типовых параметров совпадает со второй.

Давайте теперь добавим в язык связывающую конструкцию --- $\lambda$-абстракцию:

\begin{lstlisting}
@type ('name, 'lam) abs = 
  [ `Abs of 'name * 'lam ] with show
\end{lstlisting}

Те же самые рассуждения применимы и тут: мы пользуемся открытой рекурсией и параметризируем представление относительно имени.
Класс для преобразования будет выглядеть похожим образом:

\begin{lstlisting}
class ['lam, 'nless] abs_to_nameless
 (flam : string list -> 'lam -> 'nless) =
object
  inherit [string list, string, int
          , string list, 'lam, 'nless
          , string list, 'lam, 'nless] $\inbr{abs}$
  method $\inbr{Abs}$ env name term = 
    `Abs (flam (name :: env) term)
end
\end{lstlisting}

Заметьте, что метод ``$\inbr{Abs}$'' конструирует значения \emph{другого} типа, чем любая возможная параметризация типа ``\lstinline{abs}''. Действительно, безымянное представление типа не должно содержать никаких суррогатов имён.

Теперь мы можем объединить эти два типа, чтобы получить тип выражений со связывающими конструкциями.

\begin{lstlisting}
@type ('name, 'lam) term = 
  [ ('name, 'lam) lam 
  | ('name, 'lam) abs) ] with show
\end{lstlisting}

Представим два новых типа для именованного и безымянного представления\footnote{Для того чтобы эти определения типов скомпилировались, необходимо использовать ключ компиляции \cd{-rectypes}.}:

\begin{lstlisting}
@type named = (string, named) term 
  with show
@type nameless = 
  [ (int, nameless) lam | `Abs of nameless] 
  with show
\end{lstlisting}

Наконец, мы можем описать преобразование, которое превращает именованные термы в их безымянное представление:

\begin{lstlisting}
class to_nameless
(f : string list -> named -> nameless) = 
object
 inherit 
   [string list, named, nameless] $\inbr{named}$
 inherit 
   [named, nameless] lam_to_nameless f
 inherit 
   [named, nameless] abs_to_nameless f
end
\end{lstlisting}

Это преобразование получается путём наследования поределеннных выше компонент: общего класса для всех преобразований типа ``\lstinline{named}'' 
и двух конкретных преобразований его составляющих: 
``\lstinline{lam_to_nameless}'' и ``\lstinline{abs_to_nameless}''.
Функция-преобразование может быть получена стандартным способом:

\begin{lstlisting}
let to_nameless term =
  transform(named) 
    (fun fself -> new to_nameless fself) 
    [] 
    term
\end{lstlisting}

Только что мы построили реализацию преобразования типа, комбинируя реализации преобразований его составляющих. Эти  реализации могут быть раздельно скомпонованы, но вся система при этом останется строго типизированной. В этом примере демонстрируются возможности подхода по раздельному и модульному представлению преобразований с помощью объектов, а также возможности по использованию полиморфных вариантных типов языка \ocaml{}, которые не доступны в подходе \visitors{}.

\subsection{Нерегулярные типы данных}
\label{sec:irregular}

Основным достоинством подхода \visitors{} является поддержка нерегулярных типов данных с некоторой оговоркой: поддерживаются преобразования в так называемом ``полиморфном режиме''~\cite{Visitors}. Наш метод не позволяет построить преобразования для уже описанных нерегулярных типов данных. Однако, если разработчик проектирует типы с нуля, то у него есть возможность описать их так, чтобы они были регулярными и были совместимы с нашим подходом. 

Рассмотрим объявления нерегулярного типа данных  из работы~\cite{irregular}.

\begin{lstlisting}
type 'a tree = N | C of 'a * ('a * 'a) tree
\end{lstlisting}
\noindent Для этого типа метод на основе \GT{} не сможет построить преобразование, так в языке \ocaml{} не поддерживается нерегулярная типизация объектов. Необходимо переписать это тип, абстрагировавшись от вхождения типа \lstinline{'a * 'a}, и описать тип \lstinline{t}, и уже с помощью него описать  необходимый тип \lstinline{tree} (потребуется использование ключа компилятора \texttt{-rectypes}).
\begin{lstlisting}
type ('a, 'b) t = N | C of 'a * ('a, 'b)
type 'a tree = ('a, 'a * 'a) t 
\end{lstlisting}
\noindent Для этих двух типов предлагаемый метод уже сможет построить требуемые преобразования.

\subsection{Особенности дизайна}
\label{sec:design}

В данном разделе мы рассмотрим пример построения расширяемых преобразований с помощью \visitors~\cite{Visitors}, ещё одного подхода по построению раширяемых преобразований в \OCaml{} с помощью объектов.

\begin{lstlisting}
(struct 
  type 'a menu = ('a * int) list
  [@@deriving visitors 
    { variety = "map"
    ; name = "map_menu"
    ; polymorphic = true }]
  ...
end : sig 
  type 'a menu 
  val add_exn
    : 'a menu -> 'a -> int -> 'a menu
    
  class virtual ['c] map_menu : object ('c)
    constraint 'c = ...
    method private visit_int : 
      'env. 'env -> int -> int
    method visit_menu :
      ('env -> 'a -> 'b) -> 
      'env -> 'a menu -> 'b menu
    ...
end)
\end{lstlisting}

\noindent Вы видите тип данных \lstinline{'a menu}, аннотированный для использования \visitors{}, который реализует ресторанное меню как список блюд и цен. Предположим, разработчик решил скрыть детали реализации меню, объявив тип абстрактным и предоставив функцию добавления в меню, которая, например, в случае указания отрицательной цены, приводит к исключительной ситуации.

Мы хотим обратить внимание на несколько недостатков данной реализации, которые отсутствуют в методе, предложенном в данной работе.

Во-первых, объект-преобразование реализует приватный метод \lstinline{visit_int}, для преобразования чисел, который разрешается переопределять при наследовании. Это позволяет определять преобразования, которые нарушают внутреннюю целостность типа \lstinline{'a menu}, например, которые создают пункты меню с отрицательными ценами. Данный недостаток хорошо известен среди исследователей обобщенного программирования~\cite{SYB} для языка \haskell{}, и порицается~\cite{SafeHaskell}.

Во-вторых, класс-преобразование кодирует свой интерфейс в единственном типовом параметре с помощью ключевого слова \lstinline{constraint}. Преимуществом такого кодирования является некоторое сокращение порождаемого объема кода. Недостатком является невозможность породить тип объекта преобразования в файлах-интерфейсах языка \OCaml{}, что заставляет выписывать типы вручную. Стандартные~\cite{ppxderiving} подходы к обобщенному программированию, как и предложенный в данной работе метод, не страдают от этого недостатка.

В-третьих, порожденный с помощью \visitors{} объект-преобразование, является виртуальным классом, и поэтому не готов к немедленному использованию пользователем. Другие подходы к обобщенному программированию сразу предоставляет готовые к использованию функции-преобразования.

%\subsection{Метрики}

%\textcolor{red}{Объединить со следующим}

%Наши измерения показывают, что относительная производительность методов незначительно зависит от размера входных данных для преобразований, и может существенно разниться между различными видами преобразований.

\subsection{Производительность}
\label{sec:performance}

%При сравнении преобразований, реализованных в традиционном и расширяемом виде,
%следует ожидать от первых большей производительности, так как дополнительный слой абстракции вносит некоторые накладные расходы.
%
%\textcolor{red}{Что стоит ожидать не писать. Пункты тоже убрать, уместить в 1 абзац}

%Тут минимум объяснений про процедуру...

%Были проведены замеры бла-бла...

При замерах были использованы преобразования, построенные с использованием четырёх методов:
нерасширяемые преобразования записанные с помощью рекурсивных функций;
расширяемые преобразования на основе данной работы; 
а также два метода с использованием популярных библиотек.
%частично расширяемые преобразования, реализованные c помощью записей в стиле библиотеки \cd{ppx\_deriving\_morphism};
%расширяемые преобразования по методу \visitors{};

Для ответа на \textit{RQ2} осуществлялись замеры производительности различных преобразований. Непосредственно измерялось количество преобразований, которые удается осуществить за единицу времени, а затем нормировалось относительно базового уровня, в качестве которого был выбран \GT{}.

Измерения осуществлялись на машине с процессором i7-4790K и версии компилятора \texttt{4.10.1+flambda} с помощью одной из распространенных библиотек\footnote{\url{https://github.com/Chris00/ocaml-benchmark}} для оценки производительности. Реализация тестов находится в том же репозитории\footnote{\url{https://github.com/JetBrains-Research/GT/tree/0.4.0/bench}}, что и сам \GT{}.

Для замеров были выбраны два вида преобразований: копирование выражения и преобразование в текстовый формат.
Данные преобразования применялись к $\lambda$-выражениям, состоящим состоит из вложенных $\lambda$-абстракций.
Количество таких абстракций определяет размер выражения. Для тестирования использовались различные размеры от 100 до 1000.

Результаты указаны в таблице \ref{tab:caption}.

\subsection{Анализ результатов}
\emph{RQ1: <<Эффективно ли  на практике кодирование конструкторов один к одному в методы объектов, позволяет ли оно описывать достаточно разнообразные расширяемые преобразования?>>} Приведенные примеры показывают применимость  предлагаемого метода для типичных задач обобщенного программирования. Предлагаемый метод применим для полиморфных вариантных типов \OCaml{} и типов с неограниченной рекурсией, а \Visitors{} не применим. Однако, метод на основе \Visitors{} несколько удобнее для поддержки нерегулярных типов данных, а также \Visitors{} применимы для построения преобразований в стиле SYB\cite{SYB}, но это достигается нарушением принципов абстракции данных.

\emph{RQ2: <<Какова скорость выполнения расширяемых преобразований по сравнению с нерасширяемыми?>>} Сделанные измерения производительности показывают, что при построении расширяемых преобразований итоговая производительность уменьшается по сравнению с нерасширяемыми. Для первого  преобразования (копирование), где измеряется производительность обхода выражения без полезной нагрузки, эти накладные расходы значительны для любого проверенного метода реализации. Однако, для второго вида преобразований (форматирование) обход структуры $\lambda$-выражения занимает малую часть, и поэтому накладные расходы на использование расширяемых преобразований приемлемы. 

При реализации различных преобразований единственным различием между предлагаемым подходом и \Visitors{} находится в обобщенной функция преобразования. В \Visitors{} она реализована как метод объекта, а в \GT{}  виде отдельной функции, которая вызывается не напрямую, что влияет на производительность для некоторых видов преобразований.

Метод \cd{ppx\_deriving\_morphism} не использует представление в виде объектов, поэтому в нём нет накладных расходов на работу с таблицей виртуальных методов, и поэтому он показывает лучшую производительность чем преобразования на основе объектов. Но в нём, как и в \Visitors{}, не поддерживаются полиморфные вариантные типы \OCaml{}.

Стандартный метод построения преобразований напрямую вызывает код для обработки отдельных конструкторов, и поэтому показывает наилучшую производительность. Однако, такие преобразования не являются расширяемыми.




\begin{table*}[t]
  \centering
  \begin{tabular}{l cccc}
    \toprule
    \multirow{2}{*}{Вид преобразования}&  \multicolumn{3}{c}{Метод реализации и улучшение (\%)} \\\cline{2-4}
     &  \visitors & \PPXMorphism  & Стандарт \\\hline
    %\multirow{5}{*}
    {Копирование}  
%      & 300  & --  & 149 & 220  & 311 \\
%      & 500  & --  & 146 & 218  & 246 \\
%      & 700  & -- & 143 & 212  & 244 \\
%      & 900  & --  & 141 & 210  & 243 \\
     &  +(14-17)\% & +(120-131)\% & +(292-305)\% \\\hline
    %\multirow{5}{*}
    {Форматирование}  
%      & 300  & 0  & -- & 1  & 3 \\
%      & 500  & 0  & -- & 1  & 4 \\
%      & 700  & 1  & -- & 1  & 4 \\
%      & 900  & -- & 1  & 2  & 3 \\
     &  не значимо  & +(2-3)\% & +(3-7)\% \\ 
    \bottomrule
  \end{tabular}
\caption{}{Производительность преобразований, реализованных по-разному. Базовая линия -- реализация методом \GT{}. Промежуток в скобках -- изменение производительности (больше -- лучше). Конкретное значение в промежутке определяется размером входных данных для преобразования. Измерения показывают, что для вырожденного преобразования (копирование) накладные расходы существенны, для для содержательного -- приемлемы.
}
\label{tab:caption}
\end{table*}



