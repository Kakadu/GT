\section{Реализация и примеры}
\label{sec:Evaluation}

Представленный метод был реализован в библиотеке Generic Transformers\footnote{\url{https://github.com/Kakadu/GT/tree/v0.3.0}} (\GT). Библиотека  поддерживает два наиболее распространенных вида синтаксических расширений языка \ocaml{}: \textsc{PPX}~\cite{PPXLib} и \camlpfive~\cite{camlp5}. Библиотека \GT{} является расширяемой: к ней прилагается интерфейс для добавления пользовательских плагинов, реализующих порождение новых видов преобразований, а также набор стандартных преобразований, использующихся в других подобных библиотеках.


В этом разделе мы представим несколько примеров, реализованных с помощью нашего подхода. В них используются синтаксические расширения \camlpfive{}, но это же может быть реализовано также с использованием \PPX{}. %Данная работа является прямым наследником~\cite{SCICO} и все примеры из той статьи работают и в этой версии. 

\subsection{Рассмотренные примеры}

Первым примером (раздел~\ref{sec:lists}) является представление логических значений, использующиеся в  библиотеке реляционного программирования \OCanren{}~\cite{OCanren}. Особенностью данного примера является то, что в нём используется относительно редкий ключа компилятора \texttt{-rectypes} для объявления типов данных. Не всякое представление объектов-преобразований будет работать с типами данных, для которых необходим этот ключ компиляции.

Другим примером является решение задачи <<The Expression Problem>>~\cite{ExpressionProblem}, реализованное с использованием нашего подхода (раздел~\ref{sec:nameless}). Эта задача часто используется как ``лакмусовый тест'' для оценки подходов к обобщенному программированию~\cite{ObjectAlgebras,ALaCarte}. В литературе встречается различные подходы к решению этой задачи, но наша реализация данного примера интересна тем, что использует полиморфные вариантные типы языка \ocaml{}.
%Убрать то, что справа:
%В нём мы будем отдельно описывать преобразования для различных частей языка, а потом объединять их с помощью наследования. Это пример также не может быть переписан с использованием \visitors{}, так как та не поддерживает полиморфные вариантные типы языка \ocaml{}.

В конце, в разделе~\ref{sec:irregular} мы коснёмся работы с нерегулярными типами данных~\cite{irregular}, которые не поддерживаются нашим методом непосредственно, а требуют некоторого изменения способа объявления типов данных, чтобы наш метод был применим. %но поддерживаются при использовании \visitors{}.

% нерегулярными типами данных~\cite{irregular}
% вместо "нерегулярными~\cite{irregular} типами данных"
% потому что термин разрывается 

Кроме того, перечисленные выше примеры важны для сравнения с подходом~\cite{Visitors}, который 
%проектировался ради поддержки нерегулярных типов данных, и
 в данный момент не поддерживает использование ключа \texttt{-rectypes} и полиморфные вариантные типы. 

Также данные примеры помогут обосновать наш дизайн  интерфейса объектов, а именно ответить на вопрос: <<Эффективно ли  на практике кодирование конструкторов один к одному в методы объектов, позволяет ли оно описывать достаточно разнообразные расширяемые преобразования?>>.

%TODO: вообще сравниваться непосредственно с Visitors не хорошо, будет выглядет как мелкое улучшение примеров.

%Может быть другого сорта мотивацию, сказать почему примеры важны (а в конце, "кроме того, примеры важны для сравнения с взиторами, потому что...)

%\subsection{Research Questions}
%Данные примеры помогут ответить на исследовательский вопрос:

%\textcolor{red} {Это не вопрос!!!} Также важно ответить на вопрос: <<Является ли предоставляемый интерфейс достаточно знакомым для практикующего разработчика на \ocaml{}?>>

%TODO: Тут сказать почему они важны

%\parbox{\textwidth}{
%\textcolor{blue} {Запихнуть RQ в предыдущий раздел}
%}

\subsection{Типизированные логические значения}
\label{sec:lists}

Этот пример появился во время работы над строго типизированным встроенным логическим предметно-ориентированным языком на основе \textsc{OCaml}~\cite{OCanren}. 
В нём одной из самых важных конструкций является унификация термов, содержащих свободные логические переменные. Работать с такими структурами данных сложно, а допустить ошибку --- легко. 
Типичным сценарием взаимодействия  
%между логическими и нелогическими (\textcolor{red}{ПЕРЕФРАЗИРОВАТЬ})  
% частями программ 
cо встроенным языком 
является 
создание так называемых \emph{целей вычислений} (goal), содержащих структуры данных со свободными логическими переменными.
Решением логической цели является подстановка переменных, правые части которой в идеальном случае не содержат свободных переменных. 
Чтобы сконструировать цель вычислений необходимо уметь систематически вводить логические переменные в типизированную структуру данных,  а для восстановления ответа -- систематически извлекать из представления, подходящего для работы с \OCanren{}, ответы в обыкновенном
%нелогическом(\textcolor{red}{ПЕРЕФРАЗИРОВАТЬ})  
представлении (т.е. без логических переменных).

Упрощенный тип для логических переменных может быть описан следующим образом:

\begin{lstlisting}
@type 'a logic =
| V     of int
| Value of 'a       with show
\end{lstlisting}
Логическое значение может быть либо свободной логической переменной (``\lstinline{V}'') или каким-то другим значением (``\lstinline{Value}''), которое не является свободной переменной, но потенциально может содержать свободные переменные.
\begin{comment}

Чтобы преобразовывать в и из логических значений, можно воспользоваться следующими функциями:

\begin{lstlisting}
let lift x = Value x

let reify  = function
| V     _ -> invalid_arg "Free variable"
| Value x -> x
\end{lstlisting}

Функция ``\lstinline{reify}'' бросает исключение для свободных переменных, так как в присутствии вхождений свободных переменных
логическое значение нельзя рассматривать как обыкновенную (нелогическую) структуру данных.
\end{comment}


Когда мы работем с логическими структурами данных, нам необходима возможность вставлять логические переменные в произвольные позиции.
Это означает, что мы должны использовать другой тип данных, подходящий для использования 
с точки зрения системы типов. Например,
для списков нам придется абстрагироваться от рекурсии, чтобы иметь возможность описать тип логических списков \lstinline{llist}\footnote{Этот способ применим только при использовании ключа компиляции \texttt{-rectypes}.}:

\begin{lstlisting}
type ('a, 'self) list_like = 
    | Nil 
    | Cons of 'a * 'self
type 'a list = ('a, 'a list) list_like
type 'a llist = 
    ('a, 'a llist) list_like logic
\end{lstlisting}
%которые будут иметь тип ``\lstinline{lexpr}'', объявленный как
%
%\begin{lstlisting}
%type expr' = Var of string logic | Const of int logic 
%           | Binop of lexpr * lexpr
%and  lexpr = expr' logic
%\end{lstlisting}

Если мы захотим, чтобы списки типа \lstinline{llist} без логических значений преобразовывались в строковое представление также, как списки типа \lstinline{list}, необходимо модифицировать преобразование типа \lstinline{logic} в строку, убрав название конструктора \lstinline{Value}:

\begin{lstlisting}
class ['a, 'self] my_show fa fself = 
object
  inherit ['a, 'self] $\inbr{show_{logic}}$ fa fself
  method c_Value () _ x = fa () x
end
\end{lstlisting}
В такой реализации преобразования логических значений, где мы изменили только один конструктор, мы можем объявить тип логических списков заново, и получить для него преобразование в строку, которое на списках без переменных работает так же, как и для типа \lstinline{list}.

Особенностью данного подхода является, во-первых, получение нового преобразования в строку путём изменения одного метода, а, во-вторых, способ объявления типов \lstinline{list} и \lstinline{llist}, который не удается переиспользовать при использовании подхода, предоставляемого \visitors{}.

%Нам также нужно реализовать две функции преобразования. Все эти определения представляют собой типичный пример однотипного (boilerplate) кода.
%
%С изпользованием нашего подхода решение почти полностью декларативно\footnote{При условии включения ключа компиляции \cd{-rectypes}}.
%Во-первых, мы абстрагируемся от интересующего нас типа, заменяя все его вхождения типовой переменной с не встречающимся ранее именем:

%\begin{lstlisting}
%@type ('string, 'int, 'expr) a_expr =
%| Var   of 'string
%| Const of 'int
%| Binop of 'string * 'expr * 'expr with show, gmap
%\end{lstlisting}
%
%Здесь мы абстрагировали тип от всего конкретного, но мы могли обойтись абстрагированием только от самого себя. Заметьте, что 
%мы воспользовались двумя видами обобщенных преобразований~--- ``\lstinline{show}'' и ``\lstinline{gmap}''. 
%Первое будет полезно для отладочных целей, а второе является необходимым для нашего решения.
%
%Теперь мы можем объявить логические и нелогические составляющие как специализации исходного типа:
%
%\begin{lstlisting}
%@type expr  = (string, int, expr) a_expr 
%  with show, gmap
%@type lexpr = (string logic, int logic, lexpr) a_expr logic 
%  with show, gmap
%\end{lstlisting}

%Обратите внимание, что ``новый'' тип ``\lstinline{expr}'' эквивалентен старому, следовательно, такое переписывание типов не нарушает существующий код.
%
%Наконец, определения функций преобразования воспользуются преобразованием, полученным с помощью плагина ``\lstinline{gmap}'', предоставляемого библиотекой:
%
%\begin{lstlisting}
%let rec to_logic   expr = gmap(a_expr) lift  lift  to_logic  expr
%let rec from_logic expr = gmap(a_expr) reify reify from_logic @@ 
%                           reify expr
%\end{lstlisting}
%
%Как вы видите, поддержка типовых операторов существенна для этого примера. В предыдущей реализации~\cite{TransformationObjects} типовые операторы не были поддержаны и их было не так просто добавить.

\subsection{Преобразование в безымянное представление}
\label{sec:nameless}

Полиморфные вариантные типы в языке \ocaml{} позволяют описывать структуры данных композиционально, статически типизировано и в разных модулях компоновки~\cite{PolyVarReuse}.
Целесообразно объявлять преобразования таких структур данных отдельно друг от друга. Задача конструирования преобразований для 
раздельно объявленных и строго типизированных компонент известна как ``проблема выражений'' (``The Expression Problem''~\cite{ExpressionProblem}).
%которая часто используется (\textcolor{red}{Убрать в 5.1}) как ``лакмусовый тест'' для оценки подходов к обобщенному программированию~\cite{ObjectAlgebras,ALaCarte}. 
В этом подразделе мы представим решение этой задачи в рамках нашего подхода. В качестве конкретной задачи мы реализуем преобразование $\lambda$-выражений в безымянное представление.

Во-первых, опишем часть языка выражений без связывающих конструкций:

\begin{lstlisting}
@type ('name, 'lam) lam = 
[ `App of 'lam * 'lam
| `Var of 'name
] with show
\end{lstlisting}

\noindent Выделение этого типа выглядит логично, так как 
кроме указанных двух конструкций, потенциально в языке могут появиться другие, которые будут связывать переменные 
($\lambda$-абстракции, \lstinline{let}-определения и т.д.). Комбинируя различные типы и преобразования этих типов, можно получать различные расширения деревьев абстрактного синтаксиса и преобразований для $\lambda$-выражений.
%, их с несвязывающими конструкциями, а также с ними самими, можно получать различные языки с согласованным поведением \textcolor{red}{ПЕРЕФРАЗИРОВАТЬ}.

Введенный выше тип ``\lstinline{lam}'' является полиморфным: первый параметр используется для представления имен или индексов %(или уровней) 
де Брёйна\footnote{Способ представления лямбда-выражений в безымянном виде предложенный де Брёйном в~\cite{deBruijn}.}, второй необходим для открытой рекурсии (здесь мы следуем  подходу к описанию расширяемых структур данных с помощью полиморфных 
вариантных типов~\cite{PolyVarReuse}).

Для данного типа преобразование в безымянное представление можно определить следующим образом:
%Рассмотрим как для такого типа должны выглядеть преобразование в безымянное представление, а именно, как должен выглядеть класс преобразования.
%Как должно выглядеть преобразование в безымянное представление для такого типа? А именно, как должен выглядеть класс преобразования? Это показано ниже:

\begin{lstlisting}
class ['lam, 'nless] lam_to_nameless
 (flam : string list -> 'lam -> 'nless) =
object
  inherit 
    [ string list, string, int
    , string list, 'lam, 'nless
    , string list, 'lam, 'nless] $\inbr{lam}$
  method $\inbr{App}$ env _ l r = 
    `App (flam env l, flam env r)
  method $\inbr{Var}$ env _ x   = `Var (index env x)
end
\end{lstlisting}

% TODO: Здесь у нас нет call-by-value, поэтому это нифига не интерпретатор

\noindent Здесь мы используем список строк для хранения подстановки переменных и  передаем его как наследуемый атрибут. Затем мы пользуемся функцией 
``\lstinline{index}'' чтобы найти строку в подстановке, т.е.  эта функция преобразует имя в индекс де Брёйна. 
Интересной частью преобразования является типизация общего класса предка ``$\inbr{lam}$''. 
Первая тройка параметров описывает преобразование первого типового параметра. Можно заметить, что мы преобразуем строки в числа используя подстановку.
Здесь типовая переменная ``\lstinline{'lam}'', 
%как мы знаем, 
приравнивается (раздел~\ref{pv}) открытой версии типа ``\lstinline{lam}''. %(ДОИСПРАВИТЬ)
Наконец, результат преобразования типизируется с помощью переменной ``\lstinline{'nless}'', введение которой необходимо для правильной реализации преобразования объединения типов.
%Так происходит именно так потому, что, как будет понятно позднее,  это будет действительно другой тип. (\textcolor{blue}{Сказать прямее, может даже лишнее предложение})
Так как второй типовый параметр обычно ссылается рекурсивно на себя, третья тройка типовых параметров совпадает со второй.

Давайте теперь добавим в язык связывающую конструкцию --- $\lambda$-абстракцию:

\begin{lstlisting}
@type ('name, 'lam) abs = 
  [ `Abs of 'name * 'lam ] with show
\end{lstlisting}

Те же самые рассуждения применимы и тут: мы пользуемся открытой рекурсией и параметризируем представление относительно имени.
Класс для преобразования будет выглядеть похожим образом:

\begin{lstlisting}
class ['lam, 'nless] abs_to_nameless
 (flam : string list -> 'lam -> 'nless) =
object
  inherit [string list, string, int
          , string list, 'lam, 'nless
          , string list, 'lam, 'nless] $\inbr{abs}$
  method $\inbr{Abs}$ env name term = 
    `Abs (flam (name :: env) term)
end
\end{lstlisting}

Заметьте, что метод ``$\inbr{Abs}$'' конструирует значения \emph{другого} типа, чем любая возможная параметризация типа ``\lstinline{abs}''. Действительно, безымянное представление типа не должно содержать никаких суррогатов имён.

Теперь мы можем объединить эти два типа, чтобы получить тип выражений со связывающими конструкциями.

\begin{lstlisting}
@type ('name, 'lam) term = 
  [ ('name, 'lam) lam 
  | ('name, 'lam) abs) ] with show
\end{lstlisting}

Представим два новых типа для именованного и безымянного представления\footnote{Для того чтобы эти определения типов скомпилировались, необходимо использовать ключ компиляции \cd{-rectypes}.}:

\begin{lstlisting}
@type named = (string, named) term 
  with show
@type nameless = 
  [ (int, nameless) lam | `Abs of nameless] 
  with show
\end{lstlisting}

Наконец, мы можем описать преобразование, которое превращает именованные термы в их безымянное представление:

\begin{lstlisting}
class to_nameless
(f : string list -> named -> nameless) = 
object
 inherit 
   [string list, named, nameless] $\inbr{named}$
 inherit 
   [named, nameless] lam_to_nameless f
 inherit 
   [named, nameless] abs_to_nameless f
end
\end{lstlisting}

Это преобразование получается путём наследования поределеннных выше компонент: общего класса для всех преобразований типа ``\lstinline{named}'' 
и двух конкретных преобразований его составляющих: 
``\lstinline{lam_to_nameless}'' и ``\lstinline{abs_to_nameless}''.
% (\textcolor{red}{УТОЧНИТЬ}). 
Функция-преобразование может быть получена стандартным способом:

\begin{lstlisting}
let to_nameless term =
  transform(named) 
    (fun fself -> new to_nameless fself) 
    [] 
    term
\end{lstlisting}

Только что мы построили реализацию преобразования типа, комбинируя реализации преобразований его составляющих. Эти  реализации могут быть раздельно скомпонованы, но вся система при этом останется строго типизированной. В этом примере демонстрируются возможности подхода по раздельному и модульному представлению преобразований с помощью объектов, а также возможности по использованию полиморфных вариантных типов языка \ocaml{}, которые не доступны в подходе \visitors{}.

\subsection{Нерегулярные типы данных}
\label{sec:irregular}

Основным достоинством подхода \visitors{} является поддержка нерегулярных типов данных с некоторой оговоркой: поддерживаются преобразования в так называемом ``полиморфном режиме''~\cite{Visitors}. Наш метод не позволяет построить преобразования для уже описанных нерегулярных типов данных. Однако, если разработчик проектирует типы с нуля, то у него есть возможность описать их так, чтобы они были регулярными и были совместимы с нашим подходом. 

Рассмотрим объявления нерегулярного типа данных  из работы~\cite{irregular}.

\begin{lstlisting}
type 'a tree = N | C of 'a * ('a * 'a) tree
\end{lstlisting}
\noindent Для этого типа метод на основе \GT{} не сможет построить преобразование, так в языке \ocaml{} не поддерживается нерегулярная типизация объектов. Необходимо переписать это тип, абстрагировавшись от вхождения типа \lstinline{'a * 'a}, и описать тип \lstinline{tree_list}, и уже с помощью него описать  необходимый тип \lstinline{tree} (потребуется использование ключа компилятора \texttt{-rectypes}).
\begin{lstlisting}
type ('a, 'b) t = N | C of 'a * ('a, 'b)
type 'a tree = ('a, 'a * 'a) t 
\end{lstlisting}
\noindent Для этих двух типов метод уже сможет построить требуемые преобразования.

\begin{comment}

\subsection{Пример пользовательского плагина}
\label{pluginExample}

Наконец, мы продемонстрируем использование системы плагинов на свежем примере реализации плагина. Для этой цели мы выбрали широко известное преобразование \emph{hash-consing}~\cite{HC}. Это преобразование превращает структуры данных в их максимально компактное представление в памяти, при котором структурно равные части представляются в памяти как один физический объект. Например, синтаксическое дерево выражения

\begin{lstlisting}
let t =
  Binop ("+",
    Binop ("-",
      Var "b",
      Binop ("*", Var "b", Var "a")),
    Binop ("*", Var "b", Var "a"))
\end{lstlisting}
может быть переписано  как

\begin{lstlisting}
let t =
  let b  = Var "b" in
  let ba = Binop ("*", b, Var "a") in
  Binop ("+", Binop ("-", b, ba), ba)  
\end{lstlisting}
где равные подвыражения представляются как равные поддеревья.
 
Наш плагин по типу  ``\lstinline|$\left\{\alpha_i\right\}$ t|'' предоставит функцию для 
hash-consing ``\lstinline{hc(t)}'' с сигнатурой 

\begin{lstlisting}
$\{$ H.t -> $\alpha_i$ -> H.t * $\alpha_i$ $\}$ -> H.t -> $\left\{\alpha_i\right\}$ t -> H.t * $\left\{\alpha_i\right\}$ t
\end{lstlisting}
где ``\lstinline{H.t}''~--- это гетерогенная хэш таблица для произвольных типов. Интерфейс у неё следующий:

\begin{lstlisting}
module H : sig
  type t
  val hc : t -> 'a -> t * 'a
end
\end{lstlisting}

Функция  ``\lstinline{H.hc}'' принимает хэш таблицу и некоторое значение и возвращает потенциально обновленную хэш таблицу и значение, которое структурно эквивалентно поданному на вход. Мы не будет описывать реализацию этого модуля, а приведем пример использования в конструкторе:

\begin{lstlisting}
method $\inbr{Binop}$ h _ op l r =
  let h, op = hc(string) h op in
  let h, l  = fself h l in
  let h, r  = fself h r in
  H.hc h (Binop (op, l, r))
\end{lstlisting}

Этот метод принимает как наследуемый атрибут хэш таблицу ``\lstinline{h}'', преобразуемое целиком, которое здесь не потребуется; три аргумента конструктора:наследуемыех и синтезированных атрибутов:


Здесь мы предполагаем, что тип ``\lstinline{ht_typ}'' объявлен как

\begin{lstlisting}
let ht_typ ~loc =
  Typ.of_longident ~loc (Ldot (Lident "H", "t"))
\end{lstlisting}

Другими словами, мы объявляем, что типом наследуемого атрибут всегда будет 
 ``\lstinline{H.t}'', а типом синтезированного атрибута будет пара
``\lstinline{H.t * t}''.

Следующая группа методов описывает параметры классов плагина:

\begin{lstlisting}
method plugin_class_params tdecl =
  let ps = List.map tdecl.ptype_params 
             ~f:(fun (t, _) -> typ_arg_of_core_type t)
  in
  ps @
  [ named_type_arg ~loc:(loc_from_caml tdecl.ptype_loc) @@
    Naming.make_extra_param tdecl.ptype_name.txt
  ]

method prepare_inherit_typ_params_for_alias ~loc tdecl rhs_args =
  List.map rhs_args ~f:Typ.from_caml
\end{lstlisting}

Первый метод описывает типовые параметры класса плагина: для данного случая это типовые параметры самого объявления типа плюс дополнительный типовый параметр 
``$\varepsilon$''. Второй метод описывает вычисление типовых параметров для применения конструктора типа. В случае, если объявление типа выглядит как 

\begin{lstlisting}
type $\{\alpha_i\}$ t = $\{a_i\}$ tc
\end{lstlisting}

нам необходимо построить реализацию преобразовния для типа ``\lstinline{t}'' 
из реализации оного для типа  ``\lstinline{tc}'', наследуясь от правильного 
инстанциированного соответвующего класса. Для нашего случая класс параметризуется теми же 
типовыми параметрами, что и объяляемый тип, поэтому мы оставляем их как есть.

Последняя группа методов отвечает за генерацию тел методов для тра2нсформаций  конструкторов.
Мы поддерживаем регулярные конструкторы алгебраических типов, где аргументами может быть и кортеж, и запись, а также записи и кортежи на верхнем уроне, преобразование которые, как правило, имеет много общих частией. Всего за это отвечают 4 метода, но здесь мы покажем только один:

\begin{lstlisting}
method on_tuple_constr ~loc ~is_self_rec ~mutual_decls 
                            ~inhe tdecl constr_info ts =
  $\dots$ 
  match ts with
  | [] -> Exp.tuple ~loc [ inhe; c [] ]
  | ts ->
     let res_var_name = sprintf "%s_rez" in
     let argcount = List.length ts in
     let hfhc = Exp.of_longident ~loc (Ldot (Lident "H", "hc")) in
     List.fold_right
       (List.mapi ~f:(fun n x -> (n, x)) ts)
       ~init:$\dots$
       ~f:(fun (i, (name, typ)) acc ->
            Exp.let_one ~loc
              (Pat.tuple ~loc 
                 [ Pat.sprintf ~loc "ht%d" (i+1)
                 ; Pat.sprintf ~loc "%s" @@ res_var_name name])
              (self#app_transformation_expr ~loc
                 (self#do_typ_gen ~loc ~is_self_rec 
                                  ~mutual_decls tdecl typ)
                 (if i = 0 then inhe else Exp.sprintf ~loc "ht%d" i)
                 (Exp.ident ~loc name)
              )
              acc
          )
  $\dots$
\end{lstlisting}

Реализация использует заранее заготовленный метод нашей библиотеки
``\lstinline{self#app_transformation_expr}'', который генерируется применение функции преобразования к соответствующему типу.

Конечной компонентой реализации является сам  модуль ``\lstinline{H}''. Стандартный функтор ``\lstinline{Hashtbl.Make}'' создает хэш таблицы, используя некотрую хэш фукнцию и предикат равенства, предоставленные пользователем. В целом, следуем мы следуем такому соглашению: как хэш фукнцию используем полиморфную ``\lstinline{Hashtbl.hash}'', а качестве равенства используем физическое равенство ``\lstinline{==}''. Однако, присутсвуют две сложности:

\begin{itemize}
\item Так как таблице гетерогенная нам необходимо использовать небезопасное приведение типов ``\lstinline{Obj.magic}''.
\item Наша реализация равенства чуть более сложная, чем обычное ``\lstinline{==}''. Нам необходимо стравнивать верхнеуровневые конструкторы и количества их аргументов  \emph{структурно}, а только затем сравнивать соответствующие аргументы взическим равенством. Технически, мы может считать равными структурно равные значения   \emph{различных} типов.
\end{itemize}

Мы полагаемся здесь на следующее наблюдение: hash-consing корректно использовать тольео для структур данных, которые прозрачны по ссылкам, мы предполагаем что равные структуры данных взаимозаменяемы не смотря на их типы. 

Полную реализацию плагина может быть увидеть в главном репозитории. Она занимает 164 строчки кода, учитывая комментарии и пустые строки.
\end{comment}
