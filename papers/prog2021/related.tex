% !TeX encoding = windows-1251

В данной работе использованы одновременно и функциональные (комбинаторы), и объектно-ориентированные возможности языка \textsc{OCaml}. Можно найти связанные работы  одновременно и в области типизированного функционального и объектно-ориентированного программирования. Наиболее близкой, использующий язык \textsc{OCaml} и имеющей отношение к этой работе, библиотекой является \textsc{Visitors}~\cite{Visitors}, которая использует те же самые идеи, но принимает существенно другие дизайнерские решения. Детальное сравнение с \textsc{Visitors} вы найдете в конце данного раздела.

Во-первых, существует несколько библиотек для обобщенного программирования для \textsc{OCaml}, которые используют полностью генеративный подход~\cite{Yallop,PPXLib}~--- все необходимые обобщенные функции для всех типов генерируются по отдельности. Этот подход очень практичен до тех пор, пока набор предоставляемых преобразований удовлетворяет всем нуждам. Однако, если это не так, необходимо расширить кодовую базу, реализовав все отсутствующие функции заново
(с потенциально очень малым переиспользовыванием кода). К тому же, те функции,
которые получаются в результате, нерасширяемы. В нашем подходе, во-первых,
большое количество полезных обобщенных функций может быть получено из уже сгенерированных. Во-вторых, чтобы получить полностью новый плагин, достаточно модифицировать только ``интересные'' части, так как функции обхода и класс для объекта преобразования библиотека создает самостоятельно.

Несколько подходов для функционального обобщенного программирования используют 
\emph{представление типов}~\cite{Hinze}. В основе лежит идея разработки универсального представления для произвольного типа, преобразования которого необходимо получить, и предоставления двух функций, выполняющих преобразование в универсальное представление и обратно, и в идеале образующих изоморфизм. Обобщенные функции преобразуют представление исходных типов данных, что позволяет реализовать все необходимые преобразования один раз. Функции трансляции в универсальное представление и обратно могут быть получены (полу)автоматически, используя такие особенности системы типов  как классы типов~\cite{Hinze,ALaCarte} и семейства типов~\cite{InstantGenerics} в языке \textsc{Haskell}, или  используя синтаксические расширения~\cite{GenericOCaml} в языке \textsc{OCaml}. Хотя некоторые из этих подходов позволяют модификацию получаемых преобразований (например, обработка некоторых типов особым образом) и поддерживают расширяемые типы, наш подход более гибок, так как позволяет модификацию на уровне отдельных конструкторов. К тому же, мы позволяем сосуществовать нескольким видам преобразований для одного типа.

Другой подход был задействован в ``Scrap Your Boilerplate''~\cite{SYB} (для краткости SYB), изначально разработанного для языка \textsc{Haskell}. Он делает возможным реализовать преобразования,  которые обнаруживают вхождения конкретного типа в произвольной структуре данных. Поддерживаются два основных вида действий: \emph{запросы}, которые выбирают значения конкретного типа данных на основе критериев, заданных пользователем, и \emph{преобразования}, которые единообразно применяют преобразование, сохраняющее тип, в конкретной структуре данных. В последующих статьях этот подход был расширен для трансформаций, которые обходят пару структур данных одновременно~\cite{SYB1}, а также поддержкой расширения уже существующих преобразований новыми случаями~\cite{SYB2}. Позднее, данный подход был реализован в других языках, включая \textsc{OCaml}~\cite{SYBOCaml,Staged}. В отличие от нашего случая, SYB позволяет применять трансформации к конкретным типам целиком, а не отдельным конструкторам. К тому же, многообразие получающихся преобразований выглядит достаточно ограниченным. Также, потенциально, преобразования в SYB-стиле могут сломать барьер инкапсуляции, так как могут обнаруживать вхождения значений нужно типа в структуре данных \emph{произвольного} типа. Таким образом, поведение зависит от особенностей внутренней реализации структуры данных, даже от тех, что были скрыты при инкапсуляции. Это может привести, во-первых, к возможности нежелаемой обратной разработки (reverse engineering) путём применения различных чувствительных к типу, преобразований и анализа результатов. Во-вторых, к ненадежности интерфейсов: после модификации структуры данных реализация обобщенной функции для \emph{старой} версии всё ещё может быть применена без статических или динамических ошибок, но с неправильным (или нежелательным) результатом.

Существует определенное сходство между нашим подходом и \emph{алгебрами объектов}~\cite{ObjectAlgebras}. Алгебры объектов были предложены как решение проблемы выражения (expression problem) в распространенных объектно-ориентированных языках  (\textsc{Java}, \textsc{C++}, \textsc{C\#}), которые не требуют продвинутых особенностей системы типов кроме наследования и шаблонов. В оригинальном представлении алгебры объектов были преподнесены как шаблон проектирования и реализации; в последующих работах изначальная идея была улучшена различными способами~\cite{ObjectAlgebrasAttribute,ObjectAlgebrasSYB}. При использовании алгебр объектов преобразуемая структура данных также кодируется с использованием идеи ``методы и варианты (конструкторы) один к одному'', которая предоставляет расширяемость в обоих направлениях, а также ретроактивную реализацию. Однако, будучи  разработанной для совершенно другого языкового окружения, решение с использование алгебр объектов существенно отличается от нашего. Во-первых, с использованием алгебр объектов ``форма'' структуры данных должна быть представлена в виде обобщенной функции, которая принимает конкретный экземпляр алгебры объектов как параметр (кодирование Чёрча для типов~\cite{Hinze}). Применяя данную функцию к различным реализациям алгебры объектов можно получать различные преобразования (например, распечатывание). Чтобы инстанциировать саму структуру данных нужно предоставить особый экземпляр алгебры объектов~---~\emph{фабрику}. Однако, после инстанциации структура данных больше не может быть трансформирована обобщенным образом. Следовательно, алгебры объектов заставляют пользователя переключиться на представление данных с помощью функций, которое может быть, а может не быть удобно в зависимости от обстоятельств.  Наш же подход недеструктивно добавляет новую функциональность к уже знакомому миру алгебраических типов данных, сопоставления с образцом и рекурсивных функций. Обобщенные реализации преобразований полностью отделены от представления данных и пользователи могут свободно преобразовывать их структуры данных привычным способом  без потери возможности объявлять (и расширять) обобщенные функции. Другой особенностью \ocaml, в отличии от распространенных языков объектно-ориентированного программирования, является то, что для написания расширяемого кода в основном используются полиморфные вариантные типы, а не классы. Поддержка полиморфных вариантных типов для написания расширяемых типов данных требует нового подхода.


Итого, среди уже существующих библиотек для обобщенного программирования для \textsc{OCaml} мы можем называть две, которые напоминают нашу: \cd{ppx\_deriving}/\cd{ppx\_traverse}, последняя версия которых находится в кодовой базе \cd{ppxlib}~\cite{PPXLib}, и \textsc{Visitors}~\cite{Visitors}.

\cd{ppx\_deriving} является наипростейшим подходом: объявления типов данных отображаются один к одному в рекурсивные функции, представляющие конкретный вид преобразования. Это наиболее эффективная реализация, так как функции вызываются напрямую, без позднего связывания, но нерасширяемая. Если пользователю понадобится слегка модифицировать сгенерированную функцию, то он должен будет полностью скопировать реализацию функции и изменить её. Количество работы по программированию нового преобразования может существенно увеличиться, если тип данных будет видоизменяться во время цикла разработки.

В \cd{ppx\_traverse} расширяемые трансформации также представлены как объекты. В отличие от нашего подхода, там не используется кодирование конструкторов и методов один к одному. К тому же \cd{ppx\_traverse} не использует наследуемые атрибуты, следовательно некоторые преобразования, такие как проверка на равенство и сравнение, невыразимы.

\textsc{Visitors}, с другой стороны, использует сходный с нашим подход, в котором были приняты многие решения, отвергнутые нами, и наоборот. Основные отличия мы опишем в разделе~\ref{sec:discussion}.

\begin{comment}
Ниже мы подытожим главные различия:

\begin{itemize}
   \item \textsc{Visitors} полностью объектно-ориентированы. Чтобы воспользоваться преобразованием необходим создать некоторый объект и вызвать нужный метод. В нашем случае, если используются возможности, предусмотренные заранее, то можно использовать более естественный комбинаторный подход.
     
   \item \textsc{Visitors} реализуют некоторое количество преобразований в специфичной ad-hoc манере. В нашем случае все преобразования принадлежат некоторой обобщенной схеме. Различные трансформации можно скомбинировать с помощью наследования, если типы в схеме унифицируются. Мы также заявляем, что в нашей библиотека реализация пользовательских плагинов с трансформациями проще. 
     
   \item Как и  SYB, \textsc{Visitors} поддерживают указание способа трансформации для входящих в структуру данных типов: для каждого типа присутствует метод в объекте, представляющий трансформацию. Хотя такое представление добавляет некоторой гибкости мы осознанно отказывается от него, так как оно позволяет преодолеть инкапсуляционный барьер: изменяя методы преобразования (которые не могут быть скрыты в сигнатуре), можно получить некоторую информацию об внутреннем реализации инкапсулированной структуры данных. Более того, абстрактные структуры данных могут быть изменены способом, не предусмотренным публичным интерфейсом

   \item В нашем случае типовые параметры классов, представляющих трансформацию, должны быть указаны пользователем. В \textsc{Visitors} это работа возлагается на плечи компилятора, с помощью оригинального трюка. Однако, он не позволяет использовать \textsc{Visitors} в сигнатурах модулей. В нашем случае нет никаких проблем: поддерживается работа и с файлами реализации, и с файлами сигнатур.

   \item \visitors~на сегодняшний день\footnote{Последней доступной версией на данный момент является 20180513.} не поддерживает полиморфные вариантные типы.
   
   \item \textsc{GT} поддержает произвольные применения конструкторов типов, а  \textsc{Visitors} и в мономорфном, и в полиморфном режиме -- нет.
     Например, данный пример не компилируется:
     
   \begin{lstlisting}
type ('a,'b) alist = Nil | Cons of 'a * 'b
[@@deriving visitors 
  { variety = "map"
  ; polymorphic = true }]

type 'a list = ('a, 'a list) alist
[@@deriving visitors 
  { variety = "map"
  ; polymorphic = false }]
   \end{lstlisting}
   
   Более того, добавление искусственного конструктора не решает проблему:
   
   \begin{lstlisting}
type 'a list = 
  L of ('a, 'a list) alist [@@unboxed]
[@@deriving visitors 
  { variety = "map"
  ; polymorphic = false }]
   \end{lstlisting}
    
    Также присутствуют сложности с переименованиями (aliases) типов в полиморфном режиме (мономорфная часть библиотеки \textsc{Visitors} компилируется успешно):
    
    \begin{lstlisting}
type ('a,'b) t = Foo of 'a * 'b (* OK *)
[@@deriving visitors 
  { variety = "map"
  ; polymorphic = true }]

type 'a t2 = ('a, int) t
[@@deriving visitors 
  { variety = "map"; name="somename"
  ; polymorphic = true }]
    \end{lstlisting}
    
    Сгенерированный код можно исправить вручную, путём удаления типовых аннотаций для явного полиморфизма (explicit polymorphism) у методов, что приведет к коду, который очень напоминает генерируемый  \GT. Из этого мы можем заключить, что на \GT~ можно смотреть как перереализацию полиморфного режима библиотеки  \visitors, где большее количество объявлений типов компилируется корректно.
\end{itemize}
\end{comment}