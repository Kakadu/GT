

%TODO: явно указать инновации

Сутью подхода обобщённого программирования является порождение <<правильного>> кода по типу данных, поэтому в данном разделе мы излагаем наш подход 
%с использованием позднего связывания 
в стиле близком к исходному коду на \ocaml{}.

%Основными компонентами нашего решения являются синтаксические расширения (и для \cd{camlp5}~\cite{Camlp5}, и для  \cd{ppxlib}~\cite{PPXLib}), библиотека времени исполнения и система плагинов. Синтаксическое расширение касается объявлений типов, аннотированных пользователем, и генерирует следующие сущности:

У нашего подхода две  основные особенности. Во-первых, при объявлении типа объектов мы требуем ограниченного набора методов, что позволяет избежать утечек абстракции при преобразованиях абстрактных типов данных. Во-вторых, на основе построенных классов и объектов мы строим (раздел~\ref{memofix}) преобразования-функции, чтобы интерфейс, предоставляемый подходом выглядел привычно для практикующего разработчика на \ocaml{}.

Обобщённое программирование применяется к объявлениям типов, аннотированных пользователем, и в нашем случае порождает следующие сущности.

\begin{itemize}
\item Виртуальный класс, который используется как общий предок для всех преобразований, один на каждый тип. Подход нацелен на то, чтобы определять минимально необходимое количество методов в классе, чтобы избежать утечек абстракции.
\item Некоторое количество конкретных классов, по одному на каждый вид требуемого преобразования. 

\item Обобщённая функция преобразования (\emph{generic catamorphism}, \emph{gcata}), одна на каждый тип.
\item Структуру данных \emph{typeinfo}, которая содержит в себе информацию, специфичную для данного типа, а именно обобщённую функцию преобразования и набор функций-преобразований, которые которые конструируются с помощью классов.
%; всё представлено как самостоятельный объект.
\end{itemize}




Мы поддерживаем различные варианты объявлений типов со следующими ограничениями:

\begin{itemize}
\item только регулярные алгебраические типы данных; GADT'ы обрабатываются как обычные алгебраические типы;
\item ограничения на типы (constraints) не учитываются;
\item объекты, модули и типы с ключевым словом ``\lstinline{nonrec}'' не поддерживаются;
\item расширяемые типы данных (``\lstinline{...}''/``\lstinline{+=}'') не поддерживаются.
\end{itemize}

К примеру, если для типа ``\lstinline{t}'' породить преобразование ``\lstinline{show}'', то в файле реализации появятся следующие сущности (с помощью ``$\dots$'' мы обозначаем части, объяснение которых пока опускаем):

\begin{comment}
\begin{figure}[t]
  \center
  \begin{tabular}{L{6cm}|l}
    \hline
    \multicolumn{2}{c}{С использованием \cd{camlp5}}\\
    \hline
    \lstinline|@type ... = ... | & синтаксическая конструкция для обработки  \\
    \lstinline|and  ... = ... | & типа с плагинами $p_1, p_2, \dots$; взаимно \\
    \lstinline|   $[$ with  $p_1, p_2, \dots$ $]$| & рекурсивные типы также поддерживаются; \\
    \lstinline|@$typ$| & название виртуального класса для типа $typ$; \\
    \lstinline|@$plugin$[$typ$]| & имя класса плагина для типа $typ$ и \\
                                 & плагина $plugin$\\
    \hline
        \multicolumn{2}{c}{С использованием \cd{ppxlib}}\\
    \hline
    \lstinline|type ... = ...|  & синтаксическая конструкция для \\
    \lstinline|and  ... = ...|  & обработки типа  с плагинами $p_1, p_2, \dots$  \\
    \lstinline|[@@deriving gt | & $ $ \\
    \lstinline|  ~options:{ $p_1, p_2, \dots$}]| & \\
  \end{tabular}
  \caption{Конструкции расширенного синтаксиса}
  \label{syntax}
\end{figure}
\end{comment}

\begin{lstlisting}
let $\inbr{gcata_t}$ $\dots$ = $\dots$

class virtual [$\dots$] $\inbr{t}$ = object  $\dots$ end

class [$\dots$] $\inbr{show_t}$ $\dots$ = object 
  inherit [$\dots$] $\inbr{t}$ $\dots$
  $\dots$
end

let t = {
  gcata   = $\inbr{gcata_t}$;
  $\dots$
  plugins = object method show = $\dots$ end
}
\end{lstlisting}

С помощью структуры ``\lstinline{t}'' с информацией о типе мы можем симитировать функции-преобразования, индексированные типами:

%\begin{lstlisting}
%let transform t = t.gcata
%let show      t = t.plugins#show
%\end{lstlisting}
\begin{lstlisting}
let show      t = t.plugins#show
\end{lstlisting}

Функция ``\lstinline{transform(t)}'' -- это функция верхнего уровня из библиотеки \GT{}, которая может быть инстанциирована для любого поддерживаемого типа  ``\lstinline{t}''. 

%\begin{comment}
%На рисунке~\ref{syntax} мы описываем конкретные синтаксические конструкции, реализованные как синтаксическое расширение. Обратите внимание, что конкретное представление имен для классов и функций трансформации (представленных выше как$\inbr{...}$) является несущественными пока используется \cd{camlp5}, так как предоставляется соответствующее синтаксическое расширение.
%\end{comment}

\subsection{Типы преобразований}

Дизайн подхода основан на идеи описания катаморфизмов~\cite{Bananas} с помощью атрибутных 
грамматик~\cite{AGKnuth,AGSwierstra,ObjectAlgebrasAttribute}.
Мы рассматриваем только трансформации следующего типа

\[
\iota \to t \to \sigma
\]
где $t$ -- это тип, значения которого мы преобразуем, $\iota$ и $\sigma$~--- типы \emph{наследуемых} и \emph{синтезируемых} атрибутов. 
Мы не будем использовать атрибутные грамматики, чтобы описывать алгоритмическую часть трансформаций, мы только переиспользуем терминологию для описания типов типов. 

Если рассматриваемый тип является параметрическим, то преобразование тоже будет параметрическим. Далее мы будет обозначать с помощью
$\left\{...\right\}$ множественное вхождение сущности в скобках. С помощью такой нотации мы сможем описать обобщенную форму преобразований, представимых с помощью нашей библиотеки, как

\[
  \left\{\iota_i \to \alpha_i \to \sigma_i\right\}\to\iota \to\left\{\alpha_i\right\}\;t \to \sigma
\]

Здесь $\iota_i\to\alpha_i\to\sigma_i$ является функцией-пре\-образованием для типового параметра $\alpha_i$. В общем, функции-преобразования структуры данных действуют на наследуемые атрибуты и конкретные значения и возвращают синтезируемые атрибуты для различных типов. Общий для всех преобразований класс-предок для $n$-параметрического типа имеет $3\cdot(n+1)$ типовых параметров:

\begin{itemize}
\item тройка $\iota_i$, $\alpha_i$, $\sigma_i$ для каждого типового параметра $\alpha_i$, где $\iota_i$ и $\sigma_i$ --- это типовые переменные наследуемого и синтезированного атрибутов для преобразования  $\alpha_i$;
\item пара дополнительных типовых переменных $\iota$ и $\sigma$ для представления наследуемого и синтезированного атрибутов трансформируемого типа;
\item дополнительная типовая переменная $\varepsilon$, которая приравнивается к ``\lstinline|$\{\alpha_i\}$ t|'' для типов отличных от полиморфных вариантные, и приравнивается к \emph{открытому} типу ``\lstinline|[> $\{\alpha_i\}$ t]|'' для полиморфных вариантных типов %(подробнее в разделе~\ref{pv})
.
\end{itemize}

Например, если нам дан двупараметрический тип \lstinline{($\alpha$, $\beta$) t}, то заголовком общего класса-предка будет 

\begin{lstlisting}
class virtual [$\iota_\alpha$, $\!\alpha$, $\!\sigma_\alpha$, $\!\iota_\beta$, $\!\beta$, $\!\sigma_\beta$, $\!\iota$, $\!\varepsilon$, $\!\sigma$] $\inbr{t}$
\end{lstlisting}

Конкретные преобразования будут наследоваться от этого класса и, возможно, конкретизировать некоторые из типовых параметров.
Дополнительно конкретные классы получают несколько аргументов-функций:

\begin{itemize}
\item $n$ функций, преобразующих типовые параметры: \lstinline|f$_{\alpha_i}$ : $\iota_i$ -> $\alpha_i$ -> $\sigma_i$|;
\item функция для реализации открытой рекурсии: \lstinline|fself : $\iota$ -> $\varepsilon$ ->  $\sigma$|.
\end{itemize}

Например, для типа, упомянутого выше и преобразования ``\lstinline{show}'' заголовок конкретного класс будет выглядеть как

\begin{lstlisting}
class [$\alpha$, $\beta$, $\varepsilon$] $\inbr{show_t}$ 
  (f$_\alpha$     : unit -> $\alpha$ -> string)
  (f$_\beta$     : unit -> $\beta$ -> string)
  (fself : unit -> $\varepsilon$ -> string) =
object 
  inherit [ unit, $\alpha$, string
          , unit, $\beta$, string
          , unit, $\varepsilon$, string] $\inbr{t}$
  $\dots$
end 
\end{lstlisting}

Обратите внимание, что мы поддерживаем эти соглашения для всех типов, хотя для некоторых типов некоторые компоненты могут быть излишни, например, ``\lstinline{fself}''
нужен только для рекурсивных типов. Объяснение этому простое: если мы \emph{используем} некоторый тип
то мы в общем случае не знаем его определения. Следовательно, для поддержки раздельной компиляции интерфейсы всех сущностей должны иметь общую структуру.

Эта схема типизации выглядит очень многословной и неочевидной. Присутствует большое количество типовых параметров в которых легко запутаться.
Однако, пользователям понадобится разбираться с ними только если они будут реализовывать преобразование \emph{вручную} с нуля путём 
наследования от общего класса-предка.
В большинстве случаев преобразование реализуется путём небольшой специализации конкретного плагина или используя систему плагинов. 
В первом случае многие типовые параметры будут уже специализированные (например, для  ``\lstinline{show}'' большинство типовых параметров конкретизируется в базовые типы), во втором система плагинов упрощает процесс правильной конкретизации типовых параметром. % (подробнее в разделе~\ref{plugins}).

Также необходимо описать сигнатуры методов общего класса. Метод для конструктора  ``\lstinline|C of a$_1$ * a$_2$ * ... * a$_k$|'' имеет следующую сигнатуру:

\begin{lstlisting}
method virtual $\inbr{C}$ 
  : $\iota$ -> $\varepsilon$ -> a$_1$ -> a$_2$ -> ... -> a$_k$ -> $\sigma$
\end{lstlisting}

\noindent Метод принимает не только наследуемый атрибут и аргументы, соответствующие конструктору, но и значение, которое сейчас преобразуется.

Наконец, мы опишем тип обобщенных функций преобразования. Тип слегка изменяется для случая полиморфных вариантных типов.

Для типа, не являющегося полиморфным вариантным типом, с именем ``\lstinline|$\{\alpha_i\}$ t|'' \emph{обобщенная функция преобразования} имеет следующий тип:

\begin{lstlisting}
val $\inbr{gcata_t}$ : [$\{\iota_{\alpha_i}$, $\!\!\alpha_i$, $\!\!\sigma_{\alpha_i}\}$, $\!\!\iota$, $\!\!\{\alpha_i\}$ t, $\sigma$] #$\inbr{t}$ 
                -> $\iota$ -> $\{\alpha_i\}$ t -> $\sigma$
\end{lstlisting}

Она принимает объект, представляющий преобразование, у которого типовые параметры, полученные путём наследования от базового класса, соответствующим образом конкретизированы, наследуемый атрибут, значение, которое будет преобразовано и возвращает синтезируемый атрибут.
Дополнительный параметр ``$\varepsilon$'' конкретизируется в обрабатываемый тип, а 
для полиморфных вариантных типов ---~в \emph{открытую}
версию типа:  ``\lstinline|[> $\!\!\{\alpha_i\}$ t]|''. 

Это позволяет применять функцию преобразования к объекту, представляющего преобразование расширенного типа с
большим
количеством конструкторов.


\subsection{Комбинатор неподвижной точки и мемоизация}
\label{memofix}

В предыдущем разделе мы описали способ построения объектов, представляющих преобразования. Теперь необходимо воспользоваться только что построенными объектами, чтобы построить функции-преобразования. Их необходимо строить, чтобы наш подход с использованием обобщённого программирования предоставлял практикующему разработчику знакомый интерфейс.

Мы полагаемся  на открытую рекурсию: класс, реализующий конкретное преобразование принимает функцию преобразования самого себя как параметр.
Чтобы создать такую функцию необходим комбинатор неподвижной точки. В  этом разделе
мы рассмотрим только простой такой комбинатор, а именно для одиночного объявления типа.
Во взаимно рекурсивном случае понадобится чуть более сложная реализация (подробнее в 
разделе~\ref{murec}).

%Мы напоминаем вам пример из раздела~\ref{sec:expo}:

Преобразование $tr$ для типа $t$, представленное с помощью функции $\inbr{tr_{t}}$, реализуется следующим способом:

\begin{lstlisting}
let $\inbr{tr_{t}}$ $\{f_i\}$ $\iota$ x =
  transform $t$.gcata (new $\inbr{tr_{t}}$ $\{f_i\}$) $\iota$ x
\end{lstlisting}
\noindent Оно определяется с помощью класса  $\inbr{tr_{t}}$, представляющего преобразование для типа $t$, и обобщенной функции преобразования типа $t$. 

\begin{lstlisting}
let transform t = transform_gc t.gcata

let transform_gc gcata make_obj $\iota$ x =
  let rec obj = lazy (make_obj fself)
  and fself $\iota$ x = 
    gcata (Lazy.force obj) $\iota$ x in
  fself $\iota$ x
\end{lstlisting}

В этой реализации также используется комбинатор неподвижной точки \lstinline{transform_gc}, объявляемый один раз для всех типов. Она нужна для того, чтобы передавать в класс, описанный с помощью открытой рекурсии, функцию-преобразование типа $t$, которую мы хотим описать. В реализации используется ленивое создание объекта, представляющего преобразование, чтобы избежать создания этого объекта при каждом рекурсивном вызове. Эта экономия возможна по причине того, что во время применения преобразования объект, представляющий преобразование, не изменяется.

%\begin{comment}
%\begin{lstlisting}
%let $\inbr{pretty_{expr}}$ i e = 
%  fix (fun fself -> 
%         $\inbr{gcata_{expr}}$ (new $\inbr{pretty_{expr}}$ fself))
%  i e
%\end{lstlisting}
%\end{comment}


%\begin{comment}
%Здесь присутствует лямбда абстракции, тело которой вычисляется всякий раз, когда вызывается \lstinline{fself}'' в классе преобразования (по сути, для каждого узла в дереве трансформируемого значения). Так как все объекты одинаковы, то их создание можно соптимизировать.
%
%Мы мемоизируем создания объекта, представляющего преобразование, с помощью ленивых вычислений. Для этого мы абстрагируем создание объекта в функцию, которая принимает
%аргумент ``\lstinline{fself}''. Реализация комбинатора неподвижной точки выглядит следующим образом:
%
%\begin{lstlisting}
%let fix gcata make_obj $\iota$ x =
%  let rec obj = lazy (make_obj fself)
%  and fself $\iota$ x = gcata (Lazy.force obj) $\iota$ x in
%  fself $\iota$ x
%\end{lstlisting}
%
%Этот комбинатор может использоваться для всех типов и не является генерируемым по типу данных. Теперь мы может немного исправить объявление функции ``\lstinline{transform}'':
%
%\begin{lstlisting}
%let transform typeinfo = fix typeinfo.gcata
%\end{lstlisting}
%
%С помощью этого определения пользователю не нужно использовать комбинатор неподвижной точки явно:

%\begin{lstlisting}
%let $\inbr{show_{expr}}$ e =
%  transform(expr) (fun fself -> new $\inbr{show_{expr}}$ fself) () e
%\end{lstlisting}

%\end{comment}

\subsection{Взаимно рекурсивные определения}
\label{murec}

В случае, если необходимо построить преобразование для группы взаимно-рекурсивных определений типов, то порожденный код несколько усложнится. Во-первых классы преобразований также начнут получать преобразования для других типов, объявленных взаимно-рекурсивно, в следствие использования представления с открытой рекурсией. Во-вторых, для данной группы будет нужен специальный комбинатор неподвижной точки, который осуществляет <<завязывание в узел>> преобразований одного вида для данной группы типов. В третьих, будет необходимо объявить дополнительные классы преобразований, специализированные для только что построенных преобразований других типов, чтобы финальный интерфейс классов был одинаков для взаимно-рекурсивных и обычных определений.


\subsection{Реализация}
На основе описанного метода представления преобразований с помощью объектов была сконструирована библиотека Generic Transformers\footnote{\url{https://github.com/Kakadu/GT/tree/v0.3.0}} (GT), позволяющая с использованием обобщённого программирования порождать по типам данных расширяемые преобразования. В ней поддерживаются два наиболее распространенных вида синтаксических расширений для языка \ocaml{}: \textsc{PPX}~\cite{PPXLib} и \camlpfive~\cite{camlp5}. Библиотека \GT{} является расширяемой: к ней прилагается интерфейс добавления пользовательских плагинов, реализующих порождение новых видов преобразований, а также набор стандартных преобразований, использующихся в других подобных библиотеках.



\begin{comment}


\subsection{Система плагинов}
\label{plugins}


\subsection{Взаимная рекурсия}
%\label{murec}

%Опущены 2 страницы про них

Полная поддержка взаимно рекурсивных определений типов требует дополнительных усилий.
Формально, создание всех необходимых сущностей может быть произведена также, как и для 
одиночного случая, но это может нарушить расширяемость получаемых преобразований.
Мы продемонстрируем это феномен в примере ниже. Рассмотрим определение типа


\begin{lstlisting}
type expr = $\dots$ | LocalDef of def * expr
and  def  = Def of string * expr
\end{lstlisting}

где мы опустили неважные части (переменные, бинарные операции и т.д.) в объявлении типа выражений. Довольно очевидно, что обобщённые функции преобразований для обоих типов могут  быть оставлены как они есть, так как они по сути просто перекладывают работы про выполнению преобразования на плечи методов объекта и не зависят от наличия рекурсии в определениях типов.

\begin{lstlisting}
let $\inbr{gcata_{expr}}$ $\omega$ $\iota$ = function
$\dots$
| LocalDef (d, e) as x -> $\omega$#$\inbr{LocalDef}$ $\iota$ x d e

let $\inbr{gcata_{def}}$ $\omega$ $\iota$ = function
| Def (s, e) as x -> $\omega$#$\inbr{Def}$ $\iota$ x s e
\end{lstlisting}

То же самое верно и для общего класса-предка. Однако, если мы начнем реализовывать конкретные преобразования, то нам понадобится преобразование значений 
типа ``\lstinline{expr}'' внутри класса для ``\lstinline{def}'', и наоборот. Это может быть сделано с помощью взаимно рекурсивных определений классов (мы опять же опускаем неважные части кода):

\begin{lstlisting}
class $\inbr{show_{expr}}$ fself = object 
  inherit [unit, _, string] $\inbr{expr}$ fself
  $\dots$
  method $\inbr{LocalDef}$ $\iota$ x d e =
    $\dots$ (fix $\inbr{gcata_{def}}$ (fun fself -> new $\inbr{show_{def}}$ fself) $\dots$) $\dots$
end
and $\inbr{show_{def}}$ fself = object 
  inherit [unit, _, string] $\inbr{def}$ fself
  method $\inbr{Def}$ $\iota$ x s e =
    $\dots$ (fix $\inbr{gcata_{expr}}$ (fun fself -> new $\inbr{show_{expr}}$ fself) $\dots$) $\dots$
end
\end{lstlisting}

Заметьте, что в обоих аргументах ``\lstinline{fix}'' мы создаем \emph{конкретные} классы  (``$\inbr{show_{def}}$'' и ``$\inbr{show_{expr}}$''). На первый взгляд, это должно работать как полагается. Строго говоря, это \emph{конкретное} преобразование действительно работает.
Но что случится, если нам понадобится переопределить поведение в классе 
 ``$\inbr{show_{expr}}$''? Согласно подходу, определенному выше, на необходимо отнаследоваться от ``$\inbr{show_{expr}}$'', переопределить некоторые метода и сконструировать функцию с помощью комбинатора неподвижной точки:

\begin{lstlisting}
class custom_show fself = object 
  inherit $\inbr{show_{expr}}$ fself
  method $\inbr{Const}$ $\iota$ x n = "a constant"
end

let custom_show e = 
  fix $\inbr{gcata_{expr}}$ (fun fself -> new custom_show fself) () e
\end{lstlisting}

А это не будет работать так, как мы ожидаем, потому мы не определили метод
``$\inbr{LocalDef}$'', который использует класс по умолчанию для типа  ``\lstinline{def}'', который в свою очередь пользуется классом по умолчанию для типа  ``\lstinline{expr}''.
Получается, что мы переопределили поведение только одной компоненты взаимно рекурсивного преобразования типов, а именно для типа ``\lstinline{expr}''. 
Все вхождения типа ``\lstinline{expr}'' в других типах всё ещё преобразуются стандартным образом. Чтобы исправить это поведение, нам придется повторить реализацию взаимно рекурсивных классов \emph{целиком}, что обесценивает всю идею расширяемости.

Наше решение проблемы снова полагается на идею открытой рекурсии. Вкратце, мы параметризируем конкретный класс преобразования трансформациями \emph{всех} типов, участвующих во взаимно рекурсивном определении типов.
так как эта параметризация нарушает соглашение об интерфейсах классов, нам придется объявить эти классы как дополнительные. Для нашего примера они будут выглядит вот так:

\begin{lstlisting}
class $\inbr{show\_stub_{expr}}$ $f_{expr}$ $f_{def}$ = object 
  inherit [unit, _, string] $\inbr{expr}$ $f_{expr}$
  $\dots$
  method $\inbr{LocalDef}$ $\iota$ x d e = $\dots$ ($f_{def}$ $\dots$) $\dots$
end

class $\inbr{show\_stub_{def}}$ $f_{expr}$ $f_{def}$ = object 
  inherit [unit, _, string] $\inbr{def}$ $f_{def}$
  method $\inbr{Def}$ $\iota$ x s e = $\dots$ ($f_{expr}$ $\dots$) $\dots$
end
\end{lstlisting}

Обратите внимание на отсутствие рекурсивных классов.

Затем мы сгенерируем комбинатор неподвижной точки для этого взаимно рекурсивного определения:

\begin{lstlisting}
let $\inbr{fix_{expr, def}}$ ($c_{expr}$, $c_{def}$) =
  let rec $t_{expr}$ $\iota$ x = $\inbr{gcata_{expr}}$ ($c_{expr}$ $t_{expr}$ $t_{def}$) $\iota$ x
  and $t_{def}$ $\iota$ x = $\inbr{gcata_{def}}$ ($c_{def}$ $t_{expr}$ $t_{def}$) $\iota$ x in
  ($t_{expr}$, $t_{def}$)
\end{lstlisting}

Здесь $c_{expr}$ и $c_{def}$ являются генераторами объектов, которые принимают как параметры функции преобразования всех типов, которые встречаются во взаимно рекурсивном определении. Обратите внимание, что тот же самый комбинатор неподвижной точки может использоваться для того, чтобы сконструировать любое конкретное преобразование для данного взаимно рекурсивного определения типов.

С этими дополнительными классами мы может сконструировать реализации по умолчанию для любого конкретного преобразования:

\begin{lstlisting}
let $\inbr{show_{expr}}$, $\inbr{show_{def}}$ =
  $\inbr{fix_{expr,def}}$ (new $\inbr{show\_stub_{expr}}$, new $\inbr{show\_stub_{def}}$) 
\end{lstlisting}

Эти преобразования по умолчанию, во-первых, должны сохраниться во всех структурах с информацией о типах для соответствующих типов, и во-вторых, используются для создания классов трансформацией, с ожидаемым интерфейсом:

\begin{lstlisting}
class $\inbr{show_{expr}}$ fself = object 
  inherit $\inbr{show\_stub_{expr}}$ fself $\inbr{show_{def}}$ 
end
class $\inbr{show_{def}}$ fself = object 
  inherit $\inbr{show\_stub_{def}}$ $\inbr{show_{expr}}$ fself 
end
\end{lstlisting}

Здесь мы снова сделали взаимно рекурсивные типы неотличимыми от простых (в терминах интерфейсов классов), что позволяет единообразным способом конструировать преобразования этих типов в файлах, где эти типы используются, но не объявлены.

С другой стороны, чтобы расширить имеющееся преобразование, теперь необходимо наследоваться от \emph{дополнительных} классов и использовать специальный комбинатор неподвижной точки.
Для нашего предыдущего неудачного случая преобразование выглядит почти также просто, как и для одиночного объявления типа:

\begin{lstlisting}
let custom_show, _ =
  $\inbr{fix_{expr,def}}$ ((fun $f_{expr}$ $f_{def}$ ->
                  object inherit $\inbr{show\_stub_{expr}}$ $f_{expr}$ $f_{def}$
                    method $\inbr{Const}$ $\iota$ x n = "a constant"
                  end),
                new $\inbr{show\_stub_{def}}$) 
\end{lstlisting}

В конкретной реализации библиотеки мы генерируем мемоизирующий комбинатор неподвижной точки, который следует тому же шаблону, который был описан в разделе ~\ref{memofix}. К тому же, мы сохраняем данный комбинатор в структуре с информацией о типе, чтобы для 
типа ``\lstinline{t}'' этот комбинатор мог быть использован с помощью выражение 
``\lstinline{fix(t)}''. Пользователям, однако, придется держать в уме, что тип является взаимно рекурсивным, чтобы воспользоваться комбинатором правильно.

Однако присутствует одна сложность с поддержкой взаимной рекурсии: мы полагаемся на то свойства, что добавление одной функции преобразования для типа  достаточно, чтобы реализовать открытую рекурсию. Однако, строго говоря, это не так. Например, рассмотрим следующее объявление типа:

\begin{lstlisting}
type ($\alpha$, $\beta$) a = A of $\alpha$ b * $\beta$ b
and  $\alpha$ b = X of ($\alpha$, $\alpha$) a
\end{lstlisting}

В аргументах конструктора ``\lstinline{A}'' мы имеем \emph{различные} параметризации типа ``\lstinline{b}'', и поэтому нам понадобятся \emph{две} функции~--- для``\lstinline{$\alpha$ b}'' и для ``\lstinline{$\beta$ b}''. Однако, тип ``\lstinline{a}'' не является регулярным~--- начав преобразование типа ``\lstinline{($\alpha$, $\beta$) a}'' мы придём к необходимости преобразования значений типов ``\lstinline{($\alpha$, $\alpha$) a}'' и ``\lstinline{($\beta$, $\beta$) a}''.

Следовательно, мы уже отсеяли такие объявления типов. Получается, что взаимно рекурсивные объявления типов являются \emph{существенными} в том смысле, что они не всегда могут быть разделены на два не взаимно рекурсивных определения, а именно, когда каждая пара типов взаимно достижима. Если мы заменим второе объявление типа, скажем, на

\begin{lstlisting}
...
and $\alpha$ b = int
\end{lstlisting}

то мы получим объявление типов, которое не поддерживается у нас. Однако, так как типы ``\lstinline{a}'' и ``\lstinline{b}''  \emph{не являются}
по сути взаимно рекурсивными, то всё определение типов может быть переписано, что уже позволит воспользоваться нашими наработками.



\subsection{Полиморфные вариантные типы}
\label{pv}

Мы считаем поддержку полиморфных вариантных типов~\cite{PolyVar,PolyVarReuse} важной части нашей работы, так как она открывает возможности 
композиционального определения структур данных с возможность объявления композициональных преобразований.
Главным отличием между полиморфными вариантным типами  и алгебраическими, является возможность 
\emph{расширения} объявленных ранее полиморфных вариантных типов путём добавление новых конструкторов или комбинированием нескольких типов в один. 

Нашей задачей является предоставление  \emph{бесшовной} интеграции с обобщенными возможностями. Когда несколько типов будет скомбинированы, мы должны получить все обобщенные возможности простым наследование соответствующих типов.

Как мы сказали ранее, дополнительный параметр  ``$\varepsilon$'' вычисляется в открытую разновидность полиморфного вариантного типа. Следовательно, должно быть разрешено использовать ту же функцию обобщенного преобразования до для более \emph{широкого} типа\footnote{Мы воздерживаемся от использования термина ``подтип'' так как в \textsc{OCaml} нет настоящего подтипирования.}. 
Это может быть достигнуто специфической формой обобщенной функции трансформации, которая производит ``открытие'':

\begin{lstlisting}
let $\inbr{gcata_t}$ $\omega$ $\iota$ subj =
  match subj with
  $\dots$
  | C $\dots$ -> $\omega$#$\inbr{C}$ $\iota$ (match subj with #t as subj -> subj) $\dots$
  $\dots$
\end{lstlisting}

Это выливается в применении методов объекта, представляющего преобразование, к открытой разновидности типа, в то время как обобщенная функция преобразования принимает замкнутый тип.

Если несколько полиморфных вариантных типов объединяются, то обобщенная функция преобразования сопоставляем значение с образцами-типами и передает управление соответствующим обобщенными функциям преобразования.



\end{comment}