% !TeX encoding = windows-1251
\section{Реализация}
\label{sec:implementation}

Основными компонентами нашего решения являются синтаксические расширения (и для \cd{camlp5}~\cite{Camlp5}, и для  \cd{ppxlib}~\cite{PPXLib}), библиотека времени исполнения и система плагинов. Синтаксическое расширение касается объявлений типов, аннотированных пользователем, и генерирует следующие сущности:


\begin{itemize}
\item обобщенная функция трансформации (одна на каждый тип);
\item виртуальный класс, который используется как общий предок для всех трансформаций (один на каждый тип);
\item некоторое количество конкретных классов (по одному на каждый вид плагина);
\item структуру данных \emph{typeinfo}, которая содержит в себе информацию, специфичную для данного типа, а именно обобщенную функцию трансформации и набор функций трансформации, которые порождаются плагинам. Всё представлено как самостоятельный объект.
\end{itemize}

Мы поддерживаем большинство вариантов в правой части объявлений типов со следующими ограничениями:

\begin{itemize}
\item поддерживаются только регулярные алгебраические типы данных; GADT'ы обрабатываются как обычные алгебраические типы;
\item ограничения на типы (constraints) не учитываются;
\item объекты, модули и типы с ключевым словом ``\lstinline{nonrec}'' не поддерживаются;
\item расширяемые типы данных (``\lstinline{...}''/``\lstinline{+=}'') не поддерживаются.
\end{itemize}

К примеру, если к типу ``\lstinline{t}'' применить плагин ``\lstinline{show}'', то в файле реализации сгенерируются следующие сущности (с помощью ``$\dots$'' мы обозначаем части, объяснение которых пока опускаем):

\begin{figure}[t]
  \center
  \begin{tabular}{L{6cm}|l}
    \hline
    \multicolumn{2}{c}{С использованием \cd{camlp5}}\\
    \hline
    \lstinline|@type ... = ... | & синтаксическая конструкция для обработки  \\
    \lstinline|and  ... = ... | & типа с плагинами $p_1, p_2, \dots$; взаимно \\
    \lstinline|   $[$ with  $p_1, p_2, \dots$ $]$| & рекурсивные типы также поддерживаются; \\
    \lstinline|@$typ$| & название виртуального класса для типа $typ$; \\
    \lstinline|@$plugin$[$typ$]| & имя класса плагина для типа $typ$ и \\
                                 & плагина $plugin$\\
    \hline
        \multicolumn{2}{c}{С использованием \cd{ppxlib}}\\
    \hline
    \lstinline|type ... = ...|  & синтаксическая конструкция для \\
    \lstinline|and  ... = ...|  & обработки типа  с плагинами $p_1, p_2, \dots$  \\
    \lstinline|[@@deriving gt | & $ $ \\
    \lstinline|  ~options:{ $p_1, p_2, \dots$}]| & \\
  \end{tabular}
  \caption{Конструкции расширенного синтаксиса}
  \label{syntax}
\end{figure}

\begin{lstlisting}
let $\inbr{gcata_t}$ $\dots$ = $\dots$

class virtual [$\dots$] $\inbr{t}$ = object
  $\dots$
end

class [$\dots$] $\inbr{show_t}$ $\dots$ = object 
  inherit [$\dots$] $\inbr{t}$ $\dots$
  $\dots$
end

let t = {
  gcata   = $\inbr{gcata_t}$;
  $\dots$
  plugins = object
              method show = $\dots$
            end
}
\end{lstlisting}

С помощью структуры ``\lstinline{t}'' с информацией о типе мы можем симитировать функции трансформаций, индексированные типами :

\begin{lstlisting}
   let transform typeinfo = typeinfo.gcata
   let show      typeinfo = typeinfo.plugins#show
\end{lstlisting}

Функция ``\lstinline{transform(t)}'' -- это функция верхнего уровня из библиотеки, которая может быть инстанциирована для любого поддерживаемого типа  ``\lstinline{t}''. На рисунке~\ref{syntax} мы описываем конкретные синтаксические конструкции, реализованные как синтаксическое расширение. Обратите внимание, что конкретное представление имен для классов и функций трансформации (представленных выше как$\inbr{...}$) является несущественными пока используется \cd{camlp5}, так как предоставляется соответствующее синтаксическое расширение.

\subsection{Типы трансформаций}

Дизайн библиотеки основан на идеи описания катаморфизмов~\cite{Bananas} с помощью атрибутных 
грамматик~\cite{AGKnuth,AGSwierstra,ObjectAlgebrasAttribute}.
Вкратце, мы рассматриваем только трансформации следующего типа

\[
\iota \to t \to \sigma
\]
где $t$ -- это тип, значения которого мы преобразуем, $\iota$ и $\sigma$~--- типы \emph{наследуемых} и \emph{синтезируемых} атрибутов. 
Мы не будем использовать атрибутные грамматики, чтобы описывать алгоритмическую часть трансформаций, мы только переиспользуем терминологию для описания типов типов. 

Если рассматриваемый тип является параметрическим, то преобразование тоже будет параметрическим. Далее мы будет обозначать с помощью
$\left\{...\right\}$ множественное вхождение сущности в скобках. С помощью такой нотации мы сможем описать обобщенную форму преобразований, представимых с помощью нашей библиотеки, как

\[
  \left\{\iota_i \to \alpha_i \to \sigma_i\right\}\to\iota \to\left\{\alpha_i\right\}\;t \to \sigma
\]

Здесь $\iota_i\to\alpha_i\to\sigma_i$ является функцией-преобразованием для типового параметра $\alpha_i$. В общем, функции-трансформации структуры данных действуют на наследуемые атрибуты и конкретные значения и возвращают синтезируемые атрибуты для различных типов. Общий для всех преобразований класс-предок для $n$-параметрического типа имеет $3(n+1)$ типовых параметров:

\begin{itemize}
\item тройка $\iota_i$, $\alpha_i$, $\sigma_i$ для каждого типового параметра $\alpha_i$, где $\iota_i$ и $\sigma_i$ --- это типовые переменные для наследуемого и синтезированного атрибутов для преобразования  $\alpha_i$;
\item пара дополнительных типовых переменных $\iota$ и $\sigma$ для представления наследуемого и синтезированного атрибутом трансформируемого типа;
\item дополнительная типовая переменная $\varepsilon$, которая приравнивается к ``\lstinline|$\{\alpha_i\}$ t|'' для типов отличных от полиморфных вариантные, и приравнивается к \emph{открытому} типу ``\lstinline|[> $\{\alpha_i\}$ t]|'' для полиморфных вариантных типов (подробнее в 
разделе~\ref{pv}).
\end{itemize}

Например, если нам дан двупараметрический тип \lstinline{($\alpha$, $\beta$) t}, то заголовком общего класса-предка будет 

\begin{lstlisting}
class virtual [$\iota_\alpha$, $\alpha$, $\sigma_\alpha$, $\iota_\beta$, $\beta$, $\sigma_\beta$, $\iota$, $\varepsilon$, $\sigma$] $\inbr{t}$
\end{lstlisting}

Конкретные преобразования будут наследоваться от этого класса и, возможно, конкретизировать некоторые из типовых параметров.
Дополнительно конкретные классы получают несколько аргументов-функций:

\begin{itemize}
\item $n$ функций, преобразующих типовые параметры: \lstinline|f$_{\alpha_i}$ : $\iota_i$ -> $\alpha_i$ -> $\sigma_i$|;
\item функция для реализации открытой рекурсии: \lstinline|fself : $\iota$ -> $\varepsilon$ ->  $\sigma$|.
\end{itemize}

Например, для типа, упомянутого выше и преобразования ``\lstinline{show}'' заголовок конкретного класс будет выглядеть как

\begin{lstlisting}
class [$\alpha$, $\beta$, $\varepsilon$] $\inbr{show_t}$ 
  (f$_\alpha$ : unit -> $\alpha$ -> string)
  (f$_\beta$ : unit -> $\beta$ -> string)
  (fself : unit -> $\epsilon$ -> string) =
object 
  inherit [unit, $\alpha$, string, unit, $\beta$, string, unit, $\varepsilon$, string] $\inbr{t}$
  $\dots$
end 
\end{lstlisting}

Обратите внимание, что мы поддерживаем это соглашения для всех типов, хотя для некоторых типов некоторые компоненты могут быть излишни, например, ``\lstinline{fself}''
нужен только для рекурсивных типов. Объяснение этому простое: если мы \emph{используем} некоторый тип
то мы в общем случае не знаем его определения. Следовательно, для поддержки раздельной компиляции интерфейсы всех сущностей должны иметь общую структуру.

Эта схема типизации выглядит очень многословной и неочевидной. Присутствует большое количество типовых параметров в которых легко запутаться.
Однако, пользователям понадобится разбираться с ними только если они будут реализовывать преобразование \emph{вручную} с нуля путём 
наследования от общего класса-предка.
В большинстве случаем преобразование реализуется путём небольшой специализации конкретного плагина или используя систему плагинов. 
В первом случае многие типовые параметры будут уже специализированная (например, для  ``\lstinline{show}'' большинство типовых параметров конкретизируется в базовые типы), во втором система плагинов упрощает процесс правильной конкретизации типовых параметром (подробнее в 
разделе~\ref{plugins}).

Нам также необходимо описать типы аргументов у методов общего класса. Метод для конструктора  ``\lstinline|C of a$_1$ * a$_2$ * ... * a$_k$|'' имеет следующую сигнатуру:

\begin{lstlisting}
method virtual $\inbr{C}$ : $\iota$ -> $\varepsilon$ -> a$_1$ -> a$_2$ -> ... -> a$_k$ -> $\sigma$
\end{lstlisting}

Обратите внимание, метод принимает не только наследуемый атрибут и аргументы, соответствующие конструктору, но и значение, которое сейчас преобразуется.

Наконец, мы опишем тип обобщенных функций преобразования. Тип слегка изменяется для случая полиморфных вариантных типов.


Для не типа, не являющегося полиморфным вариантным типом, с именем ``\lstinline|$\{\alpha_i\}$ t|'' обобщенная функция трансформации имеет следующий тип:

\begin{lstlisting}
val $\inbr{gcata_t}$ : [$\{\iota_{\alpha_i}$, $\alpha_i$, $\sigma_{\alpha_i}\}$, $\iota$, $\{\alpha_i\}$ t, $\sigma$]#$\inbr{t}$ -> $\iota$ -> $\{\alpha_i\}$ t -> $\sigma$
\end{lstlisting}

Она принимает объект, представляющий преобразование, у которого типовые параметры, полученные путём наследования от базового класса, соответствующим образом конкретизированы , наследуемый атрибут, значение, которое будет преобразовано и возвращает синтезируемый атрибут.
Дополнительный параметр ``$\varepsilon$'' конкретизируется в обрабатываемый тип. 
Для полиморфных вариантных типов дополнительный параметр конкретизируется в \emph{открытую}
версию типа  (``\lstinline|[> $\{\alpha_i\}$ t]|''). 
Это позволяет применять функцию преобразования к объекту, представляющего преобразование расширенного типа с большим количество конструкторов.


\subsection{Комбинатор неподвижной точки и мемоизация}
\label{memofix}

В нашем подходе мы полагаемся  на открытую рекурсию: класс, реализующий конкретное преобразование принимает функцию преобразования самого себя как параметр.
Чтобы создать такую функцию необходим комбинатор неподвижной точки. В  этом разделе
мы рассмотрим только простой такой комбинатор, а именно для одиночного объявления типа.
Во взаимно рекурсивном случае понадобится более сложная реализация (подробнее в 
разделе~\ref{murec}).

Мы напоминаем вам пример из раздела~\ref{sec:expo}:

\begin{lstlisting}
let $\inbr{pretty_{expr}}$ e =
  fix (fun fself p e -> $\inbr{gcata_{expr}}$ (new $\inbr{pretty_{expr}}$ fself) p e)
     min_int e
\end{lstlisting}

Здесь присутствует лямбда абстракции, тело которой вычисляется всякий раз, когда вызывается \lstinline{fself}'' в классе преобразования (по сути, для каждого узла в дереве трансформируемого значения). Так как все объекты одинаковы, то их создание можно соптимизировать.

Мы мемоизируем создания объекта, представляющего преобразование, с помощью ленивых вычислений. Для этого мы абстрагируем создание объекта в функцию, которая принимает
аргумент ``\lstinline{fself}''. Реализация комбинатора неподвижной точки выглядит следующим образом:

\begin{lstlisting}
let fix gcata make_obj $\iota$ x =
  let rec obj = lazy (make_obj fself)
  and fself $\iota$ x = gcata (Lazy.force obj) $\iota$ x in
  fself $\iota$ x
\end{lstlisting}

Этот комбинатор может использоваться для всех типов и не является генерируемым по типу данных. Теперь мы может немного исправить объявление функции ``\lstinline{transform}'':

\begin{lstlisting}
let transform typeinfo = fix typeinfo.gcata
\end{lstlisting}

С помощью этого определения пользователю не нужно использовать комбинатор неподвижной точки явно:

\begin{lstlisting}
let $\inbr{show_{expr}}$ e =
  transform(expr) (fun fself -> new $\inbr{show_{expr}}$ fself) () e
\end{lstlisting}

\subsection{Система плагинов}
\label{plugins}

\begin{figure}[t]
  \center
  \small
  \begin{tabular}{cp{9cm}p{5cm}}
    Название & Тип функции трансформации & Комментарий \\[3mm]
    \hline\\
    \lstinline|show| & \lstinline|$\{$ unit -> $\alpha_i$ -> string $\}$ -> unit -> $\{\alpha_i\}$ t -> string| & преобразование в строку\\[2mm]
    \lstinline|fmt| & \lstinline|$\{$ formatter -> $\alpha_i$ -> unit $\}$ -> formatter -> $\{\alpha_i\}$ t -> unit| & форматированный вывод с помощью модуля ``\lstinline|Format|'' \\[2mm]
    \lstinline|html| & \lstinline|$\{$ unit -> $\alpha_i$ -> HTML.t $\}$ -> unit  -> $\{\alpha_i\}$ t -> HTML.t| & преобразование в HTML представление \\[2mm]
    \lstinline|compare| & \lstinline| $\{$ $\alpha_i$ -> $\alpha_i$ -> comparison $\}$ -> $\{\alpha_i\}$ t -> $\{\alpha_i\}$ t -> comparison| & сравнение \\[2mm]
    \lstinline|eq| & \lstinline|$\{$ $\alpha_i$ -> $\alpha_i$ -> bool $\}$ -> $\{\alpha_i\}$ t -> $\{\alpha_i\}$ t -> bool| & проверка на равенство \\[2mm]
    \lstinline|foldl| & \lstinline |$\{$ $\alpha$ -> $\alpha_i$ -> $\alpha$ $\}$ -> $\alpha$ -> $\{\alpha_i\}$ t -> $\alpha$| & протаскивание наследуемого атрибута через все узлы сверху вниз \\[2mm]
    \lstinline|foldr| & \lstinline |$\{$ $\alpha$ -> $\alpha_i$ -> $\alpha$ $\}$ -> $\alpha$ -> $\{\alpha_i\}$ t -> $\alpha$| & протаскивание наследуемого атрибута через все узлы снизу вверх \\[2mm]
    \lstinline|gmap| & \lstinline|$\{$ unit -> $\alpha_i$ -> $\beta_i$ $\}$ -> unit -> $\{\alpha_i\}$ t -> $\{\beta_i\}$ t| & функтор %\\[2mm]
%    \lstinline|eval| & \lstinline|$\{$ $\epsilon$ -> $\alpha_i$ -> $\beta_i$ $\}$ -> $\epsilon$ -> $\{\alpha_i\}$ t -> $\{\beta_i\}$ t| & a variant of functor with an environment ``$\epsilon$'' passed through a transformation\\[2mm]
%    \lstinline|stateful| & \lstinline|$\{$ $\epsilon$ -> $\alpha_i$ -> $\epsilon$ * $\beta_i$ $\}$ -> $\epsilon$ -> $\{\alpha_i\}$ t -> $\epsilon$ * $\{\beta_i\}$ t| & similar to ``\lstinline|eval|'' but allows to update the environment on the way        
  \end{tabular}
  \caption{Список предоставляемых по умолчанию плагинов}
  \label{listofplugins}
\end{figure}

Поведением по умолчанию для нашей библиотеки является создание обобщенной функции трансформации, обобщенного класса и структуры с информацией о типе. Они не создает никаких конкретных встроенных преобразований. Все преобразования создаются \emph{плагинами}, а система плагинов позволяет пользователям реализовывать их собственные.
Присутствует некоторое количество плагинов, поставляемых вместе с библиотекой 
(таблица~\ref{listofplugins}), но ни один из них не обрабатывается каким-то особым образом остальной частью библиотеки.

Каждый плагин реализован как динамически загружаемый объект, и чтобы создать плагин, разработчик должен правильно воспользоваться интерфейсом, предоставляемым библиотекой.
Аналогичный подход используется в нескольких уже существующих 
библиотеках~\cite{PPXLib,Yallop}, но, мы заявляем, что в нашем случае реализация плагинов выглядит несколько проще. Причиной этому является то, что конкретная и обобщенная части трансформаций разделены. Следовательно, создание плагина выливается только в правильное создание класса трансформации, что требует минимального вмешательства разработчика.
В общем случае, только следующая информация о новом плагине должна быть указана:

\begin{itemize}
\item Типы наследуемого и синтезируемого атрибутов для каждого параметра типа.
\item Типы наследуемого и синтезируемого атрибутов для самого преобразуемого типа.
\item Тело метода для преобразования конструкторов.
% \item Как будет выглядеть метод для структуры What the toplevel method of the typeinfo structure for the plugin is look like?
\end{itemize}

Итого, количество мест, где плагин генерирует код для обработки типов довольно мало, а генерируемый код относительно прост. Интерфейс построения синтаксического дерева напоминает интерфейс в \cd{ppxlib} (а именно, подмодуль \texttt{Ast\_builder}), который должен быть знаком всем, кто когда-то разрабатывал синтаксические расширения для \textsc{OCaml}
В разделе~\ref{pluginExample} мы представим полный пример создания свежей реализации плагина.

\subsection{Взаимная рекурсия}
\label{murec}

Опущены 2 страницы про них
\begin{comment}

Полная поддержка взаимно рекурсивных определений типов требует дополнительных усилий.
Формально, создание всех необходимых сущностей может быть произведена также, как и для 
одиночного случая, но это может нарушить расширяемость получаемых преобразований.
Мы продемонстрируем это феномен в примере ниже. Рассмотрим определение типа


\begin{lstlisting}
type expr = $\dots$ | LocalDef of def * expr
and  def  = Def of string * expr
\end{lstlisting}

где мы опустили неважные части (переменные, бинарные операции и т.д.) в объявлении типа выражений. Довольно очевидно, что обобщённые функции преобразований для обоих типов могут  быть оставлены как они есть, так как они по сути просто перекладывают работы про выполнению преобразования на плечи методов объекта и не зависят от наличия рекурсии в определениях типов.

\begin{lstlisting}
let $\inbr{gcata_{expr}}$ $\omega$ $\iota$ = function
$\dots$
| LocalDef (d, e) as x -> $\omega$#$\inbr{LocalDef}$ $\iota$ x d e

let $\inbr{gcata_{def}}$ $\omega$ $\iota$ = function
| Def (s, e) as x -> $\omega$#$\inbr{Def}$ $\iota$ x s e
\end{lstlisting}

То же самое верно и для общего класса-предка. Однако, если мы начнем реализовывать конкретные преобразования, то нам понадобится преобразование значений 
типа ``\lstinline{expr}'' внутри класса для ``\lstinline{def}'', и наоборот. Это может быть сделано с помощью взаимно рекурсивных определений классов (мы опять же опускаем неважные части кода):

\begin{lstlisting}
class $\inbr{show_{expr}}$ fself = object 
  inherit [unit, _, string] $\inbr{expr}$ fself
  $\dots$
  method $\inbr{LocalDef}$ $\iota$ x d e =
    $\dots$ (fix $\inbr{gcata_{def}}$ (fun fself -> new $\inbr{show_{def}}$ fself) $\dots$) $\dots$
end
and $\inbr{show_{def}}$ fself = object 
  inherit [unit, _, string] $\inbr{def}$ fself
  method $\inbr{Def}$ $\iota$ x s e =
    $\dots$ (fix $\inbr{gcata_{expr}}$ (fun fself -> new $\inbr{show_{expr}}$ fself) $\dots$) $\dots$
end
\end{lstlisting}

Заметьте, что в обоих аргументах ``\lstinline{fix}'' мы создаем \emph{конкретные} классы  (``$\inbr{show_{def}}$'' и ``$\inbr{show_{expr}}$''). На первый взгляд, это должно работать как полагается. Строго говоря, это \emph{конкретное} преобразование действительно работает.
Но что случится, если нам понадобится переопределить поведение в классе 
 ``$\inbr{show_{expr}}$''? Согласно подходу, определенному выше, на необходимо отнаследоваться от ``$\inbr{show_{expr}}$'', переопределить некоторые метода и сконструировать функцию с помощью комбинатора неподвижной точки:

\begin{lstlisting}
class custom_show fself = object 
  inherit $\inbr{show_{expr}}$ fself
  method $\inbr{Const}$ $\iota$ x n = "a constant"
end

let custom_show e = 
  fix $\inbr{gcata_{expr}}$ (fun fself -> new custom_show fself) () e
\end{lstlisting}

А это не будет работать так, как мы ожидаем, потому мы не определили метод
``$\inbr{LocalDef}$'', который использует класс по умолчанию для типа  ``\lstinline{def}'', который в свою очередь пользуется классом по умолчанию для типа  ``\lstinline{expr}''.
Получается, что мы переопределили поведение только одной компоненты взаимно рекурсивного преобразования типов, а именно для типа ``\lstinline{expr}''. 
Все вхождения типа ``\lstinline{expr}'' в других типах всё ещё преобразуются стандартным образом. Чтобы исправить это поведение, нам придется повторить реализацию взаимно рекурсивных классов \emph{целиком}, что обесценивает всю идею расширяемости.

Наше решение проблемы снова полагается на идею открытой рекурсии. Вкратце, мы параметризируем конкретный класс преобразования трансформациями \emph{всех} типов, участвующих во взаимно рекурсивном определении типов.
так как эта параметризация нарушает соглашение об интерфейсах классов, нам придется объявить эти классы как дополнительные. Для нашего примера они будут выглядит вот так:

\begin{lstlisting}
class $\inbr{show\_stub_{expr}}$ $f_{expr}$ $f_{def}$ = object 
  inherit [unit, _, string] $\inbr{expr}$ $f_{expr}$
  $\dots$
  method $\inbr{LocalDef}$ $\iota$ x d e = $\dots$ ($f_{def}$ $\dots$) $\dots$
end

class $\inbr{show\_stub_{def}}$ $f_{expr}$ $f_{def}$ = object 
  inherit [unit, _, string] $\inbr{def}$ $f_{def}$
  method $\inbr{Def}$ $\iota$ x s e = $\dots$ ($f_{expr}$ $\dots$) $\dots$
end
\end{lstlisting}

Обратите внимание на отсутствие рекурсивных классов.

Затем мы сгенерируем комбинатор неподвижной точки для этого взаимно рекурсивного определения:

\begin{lstlisting}
let $\inbr{fix_{expr, def}}$ ($c_{expr}$, $c_{def}$) =
  let rec $t_{expr}$ $\iota$ x = $\inbr{gcata_{expr}}$ ($c_{expr}$ $t_{expr}$ $t_{def}$) $\iota$ x
  and $t_{def}$ $\iota$ x = $\inbr{gcata_{def}}$ ($c_{def}$ $t_{expr}$ $t_{def}$) $\iota$ x in
  ($t_{expr}$, $t_{def}$)
\end{lstlisting}

Здесь $c_{expr}$ и $c_{def}$ являются генераторами объектов, которые принимают как параметры функции преобразования всех типов, которые встречаются во взаимно рекурсивном определении. Обратите внимание, что тот же самый комбинатор неподвижной точки может использоваться для того, чтобы сконструировать любое конкретное преобразование для данного взаимно рекурсивного определения типов.

С этими дополнительными классами мы может сконструировать реализации по умолчанию для любого конкретного преобразования:

\begin{lstlisting}
let $\inbr{show_{expr}}$, $\inbr{show_{def}}$ =
  $\inbr{fix_{expr,def}}$ (new $\inbr{show\_stub_{expr}}$, new $\inbr{show\_stub_{def}}$) 
\end{lstlisting}

Эти преобразования по умолчанию, во-первых, должны сохраниться во всех структурах с информацией о типах для соответствующих типов, и во-вторых, используются для создания классов трансформацией, с ожидаемым интерфейсом:

\begin{lstlisting}
class $\inbr{show_{expr}}$ fself = object 
  inherit $\inbr{show\_stub_{expr}}$ fself $\inbr{show_{def}}$ 
end
class $\inbr{show_{def}}$ fself = object 
  inherit $\inbr{show\_stub_{def}}$ $\inbr{show_{expr}}$ fself 
end
\end{lstlisting}

Здесь мы снова сделали взаимно рекурсивные типы неотличимыми от простых (в терминах интерфейсов классов), что позволяет единообразным способом конструировать преобразования этих типов в файлах, где эти типы используются, но не объявлены.

С другой стороны, чтобы расширить имеющееся преобразование, теперь необходимо наследоваться от \emph{дополнительных} классов и использовать специальный комбинатор неподвижной точки.
Для нашего предыдущего неудачного случая преобразование выглядит почти также просто, как и для одиночного объявления типа:

\begin{lstlisting}
let custom_show, _ =
  $\inbr{fix_{expr,def}}$ ((fun $f_{expr}$ $f_{def}$ ->
                  object inherit $\inbr{show\_stub_{expr}}$ $f_{expr}$ $f_{def}$
                    method $\inbr{Const}$ $\iota$ x n = "a constant"
                  end),
                new $\inbr{show\_stub_{def}}$) 
\end{lstlisting}

В конкретной реализации библиотеки мы генерируем мемоизирующий комбинатор неподвижной точки, который следует тому же шаблону, который был описан в разделе ~\ref{memofix}. К тому же, мы сохраняем данный комбинатор в структуре с информацией о типе, чтобы для 
типа ``\lstinline{t}'' этот комбинатор мог быть использован с помощью выражение 
``\lstinline{fix(t)}''. Пользователям, однако, придется держать в уме, что тип является взаимно рекурсивным, чтобы воспользоваться комбинатором правильно.

Однако присутствует одна сложность с поддержкой взаимной рекурсии: мы полагаемся на то свойства, что добавление одной функции преобразования для типа  достаточно, чтобы реализовать открытую рекурсию. Однако, строго говоря, это не так. Например, рассмотрим следующее объявление типа:

\begin{lstlisting}
type ($\alpha$, $\beta$) a = A of $\alpha$ b * $\beta$ b
and  $\alpha$ b = X of ($\alpha$, $\alpha$) a
\end{lstlisting}

В аргументах конструктора ``\lstinline{A}'' мы имеем \emph{различные} параметризации типа ``\lstinline{b}'', и поэтому нам понадобятся \emph{две} функции~--- для``\lstinline{$\alpha$ b}'' и для ``\lstinline{$\beta$ b}''. Однако, тип ``\lstinline{a}'' не является регулярным~--- начав преобразование типа ``\lstinline{($\alpha$, $\beta$) a}'' мы придём к необходимости преобразования значений типов ``\lstinline{($\alpha$, $\alpha$) a}'' и ``\lstinline{($\beta$, $\beta$) a}''.

Следовательно, мы уже отсеяли такие объявления типов. Получается, что взаимно рекурсивные объявления типов являются \emph{существенными} в том смысле, что они не всегда могут быть разделены на два не взаимно рекурсивных определения, а именно, когда каждая пара типов взаимно достижима. Если мы заменим второе объявление типа, скажем, на

\begin{lstlisting}
...
and $\alpha$ b = int
\end{lstlisting}

то мы получим объявление типов, которое не поддерживается у нас. Однако, так как типы ``\lstinline{a}'' и ``\lstinline{b}''  \emph{не являются}
по сути взаимно рекурсивными, то всё определение типов может быть переписано, что уже позволит воспользоваться нашими наработками.
\end{comment}



\subsection{Полиморфные вариантные типы}
\label{pv}

Опущены, но были в оригинале

\begin{comment}
Мы считаем поддержку полиморфных вариантных типов~\cite{PolyVar,PolyVarReuse} важной части нашей работы, так как она открывает возможности 
композиционального определения структур данных с возможность объявления композициональных преобразований.
Главным отличием между полиморфными вариантным типами  и алгебраическими, является возможность 
\emph{расширения} объявленных ранее полиморфных вариантных типов путём добавление новых конструкторов или комбинированием нескольких типов в один. 

Нашей задачей является предоставление  \emph{бесшовной} интеграции с обобщенными возможностями. Когда несколько типов будет скомбинированы, мы должны получить все обобщенные возможности простым наследование соответствующих типов.

Как мы сказали ранее, дополнительный параметр  ``$\varepsilon$'' вычисляется в открытую разновидность полиморфного вариантного типа. Следовательно, должно быть разрешено использовать ту же функцию обобщенного преобразования до для более \emph{широкого} типа\footnote{Мы воздерживаемся от использования термина ``подтип'' так как в \textsc{OCaml} нет настоящего подтипирования.}. 
Это может быть достигнуто специфической формой обобщенной функции трансформации, которая производит ``открытие'':

\begin{lstlisting}
let $\inbr{gcata_t}$ $\omega$ $\iota$ subj =
  match subj with
  $\dots$
  | C $\dots$ -> $\omega$#$\inbr{C}$ $\iota$ (match subj with #t as subj -> subj) $\dots$
  $\dots$
\end{lstlisting}

Это выливается в применении методов объекта, представляющего преобразование, к открытой разновидности типа, в то время как обобщенная функция преобразования принимает замкнутый тип.

Если несколько полиморфных вариантных типов объединяются, то обобщенная функция преобразования сопоставляем значение с образцами-типами и передает управление соответствующим обобщенными функциям преобразования.
\end{comment}