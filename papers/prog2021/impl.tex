\section{Метод}
\label{sec:implementation}

\textcolor{red}{Длинновато, и лучше явно чтобы структура виднелась}

Наш метод применяет обобщенное программирование к аннотированным  типам данных и порождает во время компиляции следующие сущности.

\begin{itemize}
\item Базовый виртуальный класс (раздел~\ref{transtypes}), который используется как общий предок для всех преобразований, один на каждый тип. 

\item Некоторое количество конкретных классов, по одному на каждый вид требуемого преобразования.

\item Обобщенная функция преобразования (\emph{generic catamorphism}, \emph{gcata})~--- одна на каждый тип данных.

\item Структура данных \emph{typeinfo} (раздел~\ref{typeinfo}), которая сохраняет сущности, построенные на предыдущих шагах, для последующего использования.
\end{itemize}


При объявлении базового класса (раздел~\ref{transtypes})
мы объявляем некоторое количество виртуальных методов, по одному методу на каждый конструктор алгебраического типа. Некоторые другие подходы~\cite{Visitors} требуют объявления большего количества виртуальных методов, что несет в себе риск раскрытия слишком большого количества деталей реализации типа, в случае, если программист пожелал скрыть эти детали, сделав тип абстрактным. Объявление слишком узкого интерфейса для объектов несёт риск построения недостаточно выразительных преобразований. В разделе~\ref{sec:Evaluation} мы испытываем наш метод на некотором количестве примеров, чтобы показать, что наш способ проектирования интерфейсов объектов позволяет получать достаточно разнообразные преобразования.
%минимальный ограниченный набор методов, что позволяет раскрывать меньше деталей при написании преобразований 
%избежать утечек абстракции при преобразованиях 
%абстрактных типов данных.\footnote{Сказатть, что объявляются виртуальные методы, они потом реализуются в объектах и мы хотим минимальное количество этих методов. Сформулировать способ как мы выбираем минимальные методы} 


Это ограничение вызывает трудности при построении функций-преобразований и преобразований для взаимно-рекурсивных типов, которые преодолеваются в разделах~\ref{memofix} и~\ref{murec}, соответственно. Построенные функции объединяются, что позволяет эмулировать (раздел~\ref{typeinfo}) возможность написание функций, индексированных типами (ad hoc полиморфизм~\cite{cardelli}).

Отметим, что функции-преобразования, построенные в разделе~\ref{memofix}, имеют такие же типы, как и функции, получающиеся стандартными подходами к обобщенному программированию, и  поэтому будут удобны для использования разработчиками. 
%на основе построенных классов и объектов мы строим (раздел~\ref{memofix}) преобразования-функции, чтобы интерфейс, предоставляемый подходом, был стандартным для \ocaml{}. 

\subsection{Типы преобразований}
\label{transtypes}

%TODO: сказать прямее и точнее

Наш метод построения расширяемых преобразований предполагает представление преобразований с помощью классов и объектов, из которых можно получать функции-преобразования. Эти функции-преобразования для простых типов данных используются при построении классов для сложных типов данных, поэтому мы начнем с описания типов функций-преобразований.

Основываясь на идее описания катаморфизмов~\cite{Bananas} с помощью атрибутных 
грамматик~\cite{AGKnuth,ObjectAlgebrasAttribute,AGSwierstra} мы рассматриваем функции-преобразования следующего вида:

\[
\iota \to t \to \sigma,
\]

\noindent где $t$ -- это тип, значения которого мы преобразуем, $\iota$ и $\sigma$~--- типы \emph{наследуемых} и \emph{синтезируемых} атрибутов. 
Мы не будем использовать атрибутные грамматики для того, чтобы описывать алгоритмическую часть преобразований, мы только переиспользуем терминологию для описания типов. 

Если тип $t$ является параметрическим, то преобразование тоже будет параметрическим. Далее мы будет обозначать с помощью
$\left\{...\right\}$ множественное вхождение сущности в скобках. С помощью такой нотации мы сможем следующим образом описать обобщенную форму наших преобразований:

\[
  \left\{\iota_i \to \alpha_i \to \sigma_i\right\}\to\iota \to\left\{\alpha_i\right\}\;t \to \sigma
\]

\noindent Эта форма состоит из $n$ функций-преобразований типовых параметров и функции-преобразования непосредственно типа  $t$. Все используемые функции-преобразования действуют на соответствующие наследуемые атрибуты и возвращают синтезированные атрибуты.
%TODO: как оно соотносится с предыдущей формулой, сказать точнее
%Здесь $\iota_i\to\alpha_i\to\sigma_i$ является функцией-пре\-образованием для типового параметра $\alpha_i$. В общем, функции-преобразования значений типы $t$ действуют также на наследуемые атрибуты и возвращают синтезируемые атрибуты (!!!). 
Общий для всех преобразований класс-предок для $n$-параметрического типа будет иметь $3*(n+1)$ типовых параметров:

\begin{itemize}
\item тройка $\iota_i$, $\alpha_i$, $\sigma_i$ для каждого типового параметра $\alpha_i$, где $\iota_i$ и $\sigma_i$ --- это типовые переменные наследуемого и синтезированного атрибутов для преобразования  $\alpha_i$;
\item пара дополнительных типовых переменных $\iota$ и $\sigma$ для представления наследуемого и синтезированного атрибутов преобразуемого типа;
\item дополнительная типовая переменная $\varepsilon$, которая приравнивается к ``\lstinline|$\{\alpha_i\}$ t|'' для типов отличных от полиморфных вариантные, и приравнивается к \emph{открытому} типу ``\lstinline|[> $\{\alpha_i\}$ t]|'' для полиморфных вариантных типов (подробнее в разделе~\ref{pv}).
\end{itemize}

\noindent Например, если нам дан двупараметрический тип \lstinline{($\alpha$, $\beta$) t}, то заголовком общего класса-предка будет 

\begin{lstlisting}
class virtual [$\iota_\alpha\!$, $\!\alpha\!$, $\!\sigma_\alpha$, $\!\iota_\beta$, $\!\beta\!$, $\!\sigma_\beta\!$, $\!\iota\!$, $\!\varepsilon\!$, $\!\sigma\!$] $\inbr{t}$
\end{lstlisting}

Конкретные преобразования будут наследоваться от этого класса и, возможно, конкретизировать некоторые из типовых параметров.
Дополнительно конкретные классы получают несколько аргументов-функций:

\begin{itemize}
\item $n$ функций, преобразующих типовые параметры: \lstinline|f$_{\alpha_i}$ : $\iota_i$ -> $\alpha_i$ -> $\sigma_i$|;
\item функция для реализации открытой рекурсии: \lstinline|fself : $\iota$ -> $\varepsilon$ ->  $\sigma$|.
\end{itemize}

\noindent Например, для типа, упомянутого выше и преобразования ``\lstinline{show}'' заголовок конкретного класс будет выглядеть как

\begin{lstlisting}
class [$\alpha$, $\beta$, $\varepsilon$] $\inbr{show_t}$ 
  (f$_\alpha$     : unit -> $\alpha$ -> string)
  (f$_\beta$     : unit -> $\beta$ -> string)
  (fself : unit -> $\varepsilon$ -> string) =
object 
  inherit [ unit, $\alpha$, string
          , unit, $\beta$, string
          , unit, $\varepsilon$, string] $\inbr{t}$
  $\dots$
end 
\end{lstlisting}

Обратите внимание, что мы поддерживаем эти соглашения для всех типов, хотя для некоторых типов некоторые компоненты могут быть излишни, например, ``\lstinline{fself}''
нужен только для рекурсивных типов. Объяснение этому простое: если мы \emph{используем} некоторый тип
то мы в общем случае не знаем его определения. Следовательно, для поддержки раздельной компиляции интерфейсы всех сущностей должны иметь общую структуру.

Эта схема типизации выглядит очень многословной и неочевидной. Присутствует большое количество типовых параметров в которых легко запутаться.
Однако, пользователям понадобится разбираться с ними только если они будут реализовывать преобразование \emph{вручную} с нуля путем 
наследования от общего класса-предка.
В большинстве случаев преобразование реализуется путем небольшой специализации конкретного преобразования или используя систему плагинов. 
В первом случае многие типовые параметры будут уже специализированные (например, для  ``\lstinline{show}'' большинство типовых параметров конкретизируется в базовые типы), во втором система плагинов упрощает процесс правильной конкретизации типовых параметром. % (подробнее в разделе~\ref{plugins}).

Также необходимо описать сигнатуры методов общего класса. Метод для конструктора  ``\lstinline|C of a$_1$ * a$_2$ * ... * a$_k$|'' имеет следующую сигнатуру:

\begin{lstlisting}
method virtual $\inbr{C}$ 
  : $\iota$ -> $\varepsilon$ -> a$_1$ -> a$_2$ -> ... -> a$_k$ -> $\sigma$
\end{lstlisting}

\noindent Метод принимает не только наследуемый атрибут и аргументы, соответствующие конструктору, но и значение, которое сейчас преобразуется.

Наконец, мы опишем тип обобщенных функций преобразования. Тип слегка изменяется для случая полиморфных вариантных типов.

Для типа, не являющегося полиморфным вариантным типом, с именем ``\lstinline|$\{\alpha_i\}$ t|'' \emph{обобщенная функция преобразования} имеет следующий тип:

\begin{lstlisting}
val $\inbr{gcata_t}$ : [$\{\iota_{\alpha_i}$, $\!\!\alpha_i$, $\!\!\sigma_{\alpha_i}\}$, $\!\!\iota\!$, $\!\!\{\alpha_i\}$ t, $\sigma$] #$\inbr{t}$ 
                -> $\iota$ -> $\{\alpha_i\}$ t -> $\sigma$
\end{lstlisting}

Она принимает объект, представляющий преобразование, у которого типовые параметры, полученные путём наследования от базового класса, соответствующим образом конкретизированы, наследуемый атрибут, значение, которое будет преобразовано и возвращает синтезируемый атрибут.
Дополнительный параметр ``$\varepsilon$'' конкретизируется в обрабатываемый тип, а 
для полиморфных вариантных типов ---~в \emph{открытую}
версию типа:  ``\lstinline|[> $\!\!\{\alpha_i\}$ t]|''. 

Обобщенная функция преобразования позволяет запускать   преобразования, представленные как объекты, а также преобразования, расширенные путём наследования. Преобразования типов, используемых при объявлении данного, никаким явным образом не попадают в интерфейсы объектов. Такой дизайн был выбран для того, чтобы не предоставлять детали реализации типа в интерфейсе объекта-преобразования. Другие подходы, например~\cite{Visitors}, и реализуют обобщённую функцию преобразования, и преобразования типовых параметров в виде методов объектов.


\subsection{Комбинатор неподвижной точки и мемоизация}
\label{memofix}

В предыдущем разделе мы описали способ построения объектов, представляющих преобразования. Теперь необходимо воспользоваться только что построенными объектами, чтобы построить функции-преобразования. Их необходимо строить, чтобы наш подход с использованием обобщённого программирования предоставлял практикующему разработчику знакомый интерфейс.

Мы полагаемся  на открытую рекурсию: класс, реализующий конкретное преобразование принимает функцию-преобразование самого себя как параметр.
Чтобы создать такую функцию необходим комбинатор неподвижной точки. В  этом разделе
мы рассмотрим только простой такой комбинатор, а именно для одиночного объявления типа.
Во взаимно рекурсивном случае понадобится чуть более сложная реализация. %(подробнее в разделе~\ref{murec}).

%Мы напоминаем вам пример из раздела~\ref{sec:expo}:

Преобразование $tr$ для типа $t$, представленное с помощью функции $\inbr{tr_{t}}$, реализуется следующим способом:

\begin{lstlisting}
let $\inbr{tr_{t}}$ $\{f_i\}$ $\iota$ x =
  transform_gc $\inbr{gcata_t}$ (new $\inbr{tr_{t}}$ $\{f_i\}$) $\iota$ x
\end{lstlisting}
\noindent Оно определяется с помощью класса  $\inbr{tr_{t}}$, представляющего преобразование для типа $t$, и обобщенной функции преобразования типа $t$. 

%\begin{lstlisting}
%let transform t = transform_gc t.gcata
%\end{lstlisting}
\begin{lstlisting}
let transform_gc gcata make_obj $\iota$ x =
  let rec obj = lazy (make_obj fself)
  and fself $\iota$ x = 
    gcata (Lazy.force obj) $\iota$ x in
  fself $\iota$ x
\end{lstlisting}

\noindent В этой реализации также используется комбинатор неподвижной точки \lstinline{transform_gc}, объявляемый один раз для всех типов. Он нужна для того, чтобы передавать в класс, описанный с помощью открытой рекурсии, функцию-преобразование типа $t$, которую мы хотим описать. В реализации используется ленивое создание объекта, представляющего преобразование, чтобы избежать создания этого объекта при каждом рекурсивном вызове. Эта экономия возможна по причине того, что во время применения преобразования объект, представляющий преобразование, не изменяется.

%\begin{comment}
%\begin{lstlisting}
%let $\inbr{pretty_{expr}}$ i e = 
%  fix (fun fself -> 
%         $\inbr{gcata_{expr}}$ (new $\inbr{pretty_{expr}}$ fself))
%  i e
%\end{lstlisting}
%\end{comment}


%\begin{comment}
%Здесь присутствует лямбда абстракции, тело которой вычисляется всякий раз, когда вызывается \lstinline{fself}'' в классе преобразования (по сути, для каждого узла в дереве трансформируемого значения). Так как все объекты одинаковы, то их создание можно соптимизировать.
%
%Мы мемоизируем создания объекта, представляющего преобразование, с помощью ленивых вычислений. Для этого мы абстрагируем создание объекта в функцию, которая принимает
%аргумент ``\lstinline{fself}''. Реализация комбинатора неподвижной точки выглядит следующим образом:
%
%\begin{lstlisting}
%let fix gcata make_obj $\iota$ x =
%  let rec obj = lazy (make_obj fself)
%  and fself $\iota$ x = gcata (Lazy.force obj) $\iota$ x in
%  fself $\iota$ x
%\end{lstlisting}
%
%Этот комбинатор может использоваться для всех типов и не является генерируемым по типу данных. Теперь мы может немного исправить объявление функции ``\lstinline{transform}'':
%
%\begin{lstlisting}
%let transform typeinfo = fix typeinfo.gcata
%\end{lstlisting}
%
%С помощью этого определения пользователю не нужно использовать комбинатор неподвижной точки явно:

%\begin{lstlisting}
%let $\inbr{show_{expr}}$ e =
%  transform(expr) (fun fself -> new $\inbr{show_{expr}}$ fself) () e
%\end{lstlisting}

%\end{comment}

\subsection{Взаимно рекурсивные определения}
\label{murec}

В случае, если необходимо построить преобразование для группы взаимно-рекурсивных определений типов, то порожденный код несколько усложнится. Во-первых классы преобразований также начнут получать преобразования для других типов, объявленных взаимно-рекурсивно, в следствие использования представления с открытой рекурсией. Во-вторых, для данной группы будет нужен специальный комбинатор неподвижной точки, который осуществляет <<завязывание в узел>> преобразований одного вида для данной группы типов. В третьих, будет необходимо объявить дополнительные классы преобразований, специализированные для только что построенных преобразований других типов, чтобы финальный интерфейс классов был одинаков для взаимно-рекурсивных и обычных определений.



\subsection{Полиморфные вариантные типы}
\label{pv}

Мы считаем поддержку полиморфных вариантных типов~\cite{PolyVar,PolyVarReuse} важной частью нашей работы, так как она позволяет 
композиционально объявлять типы данных, а также строить композициональные преобразования.
Главным отличием между полиморфными вариантным типами и алгебраическими, является возможность
\emph{расширения} объявленных ранее полиморфных вариантных типов либо путём добавления новых конструкторов, либо комбинированием нескольких типов в один.

Нашей задачей является предоставление  \emph{бесшовной} интеграции с обобщенными возможностями. Если несколько полиморфных вариантных типов будет скомбинированы, то мы должны уметь получать все обобщенные возможности простым наследованием соответствующих типов.

Как мы сказали ранее (раздел~\ref{transtypes}), дополнительный параметр  ``$\varepsilon$'' вычисляется в открытую разновидность полиморфного вариантного типа. Следовательно, системой типов языка \OCaml{} разрешено использовать ту же функцию обобщенного преобразования для более \emph{широкого} типа\footnote{Мы воздерживаемся от использования термина ``подтип'' так как в \textsc{OCaml} вместо него используется \emph{row-полиморфизм}.}. 
Это может быть достигнуто специфической формой обобщенной функции-преобразования, которая производит ``открытие'':

\begin{lstlisting}
let $\inbr{gcata_t}$ $\omega$ $\iota$ subj =
  match subj with
  | C $\dots$ -> 
      $\omega$#$\inbr{C}$ $\iota$ (match subj with 
                 #t as subj -> subj) 
      $\dots$
  | $\dots$
\end{lstlisting}

Тонкостью является применение методов объекта, представляющего преобразование, к открытой разновидности типа, в то время как обобщенная функция-преобразование принимает замкнутый тип.

Если несколько полиморфных вариантных типов объединяются, то обобщенная функция-преобразование сопоставляет значение с образцами-типами и передает управление соответствующим обобщенными функциям преобразования.

\subsection{Сохранение информации о типе}
\label{typeinfo}

Последним этапом порождения кода, является объединение в общую структуру данных построенных функций, а именно, обобщенной функции-преобразования, комбинатора неподвижной точки, и реализаций специфичных преобразований. Это открывает возможности по написанию кода, индексированного типами, что в сочетании с использованием модулей неявно (modular impicits~\cite{ModularImplicits}), может открыть интересные перспективы в будущем. 

В примере ниже мы описываем функцию, которая принимает информацию о типе и вызывает с помощью неё два преобразования: \lstinline{show} и \lstinline{gmap}.
Особенностью данного примера является, то, что в качестве \lstinline{info} можно передать информацию о \emph{любом} типе, для которого реализованы два соответствующих преобразования.


\begin{lstlisting}
let f info = 
  ... 
  GT.show info ...
  GT.gmap info ...
\end{lstlisting}


\subsection{Ограничения}

\textcolor{red}{Лучше 1), 2) и т.д.}

Мы поддерживаем различные варианты объявлений типов в  \ocaml{} со следующими ограничениями:

\begin{enumerate}
\item только регулярные алгебраические типы данных; обобщённые~\cite{GADT} обрабатываются как обычные алгебраические типы;
\item ограничения на типы (constraints) не учитываются;
\item расширяемые алгебраические типы данных
(``\lstinline{..}''/``\lstinline{+=}'') не поддерживаются;
\item объекты, модули и типы с ключевым словом ``\lstinline{nonrec}'' не поддерживаются.
\end{enumerate}

\noindent Пункты 1-3 являются стандартными ограничениями для обобщённого программирования, они присутствуют также и в~\cite{ppxderiving}. Ограничение 4 возникает потому, что \ocaml{} не позволяет описывать классы с одинаковым именем в одной области видимости. Однако,  необходимость в ключевом слове ``\lstinline{nonrec}'' возникает редко, и мы планируем решить эту проблему в будущем.




% Дальше закомментировано









\begin{comment}
\subsection{Система плагинов}
\label{plugins}


\subsection{Взаимная рекурсия}
%\label{murec}

%Опущены 2 страницы про них

Полная поддержка взаимно рекурсивных определений типов требует дополнительных усилий.
Формально, создание всех необходимых сущностей может быть произведена также, как и для 
одиночного случая, но это может нарушить расширяемость получаемых преобразований.
Мы продемонстрируем это феномен в примере ниже. Рассмотрим определение типа


\begin{lstlisting}
type expr = $\dots$ | LocalDef of def * expr
and  def  = Def of string * expr
\end{lstlisting}

где мы опустили неважные части (переменные, бинарные операции и т.д.) в объявлении типа выражений. Довольно очевидно, что обобщённые функции преобразований для обоих типов могут  быть оставлены как они есть, так как они по сути просто перекладывают работы про выполнению преобразования на плечи методов объекта и не зависят от наличия рекурсии в определениях типов.

\begin{lstlisting}
let $\inbr{gcata_{expr}}$ $\omega$ $\iota$ = function
$\dots$
| LocalDef (d, e) as x -> $\omega$#$\inbr{LocalDef}$ $\iota$ x d e

let $\inbr{gcata_{def}}$ $\omega$ $\iota$ = function
| Def (s, e) as x -> $\omega$#$\inbr{Def}$ $\iota$ x s e
\end{lstlisting}

То же самое верно и для общего класса-предка. Однако, если мы начнем реализовывать конкретные преобразования, то нам понадобится преобразование значений 
типа ``\lstinline{expr}'' внутри класса для ``\lstinline{def}'', и наоборот. Это может быть сделано с помощью взаимно рекурсивных определений классов (мы опять же опускаем неважные части кода):

\begin{lstlisting}
class $\inbr{show_{expr}}$ fself = object 
  inherit [unit, _, string] $\inbr{expr}$ fself
  $\dots$
  method $\inbr{LocalDef}$ $\iota$ x d e =
    $\dots$ (fix $\inbr{gcata_{def}}$ (fun fself -> new $\inbr{show_{def}}$ fself) $\dots$) $\dots$
end
and $\inbr{show_{def}}$ fself = object 
  inherit [unit, _, string] $\inbr{def}$ fself
  method $\inbr{Def}$ $\iota$ x s e =
    $\dots$ (fix $\inbr{gcata_{expr}}$ (fun fself -> new $\inbr{show_{expr}}$ fself) $\dots$) $\dots$
end
\end{lstlisting}

Заметьте, что в обоих аргументах ``\lstinline{fix}'' мы создаем \emph{конкретные} классы  (``$\inbr{show_{def}}$'' и ``$\inbr{show_{expr}}$''). На первый взгляд, это должно работать как полагается. Строго говоря, это \emph{конкретное} преобразование действительно работает.
Но что случится, если нам понадобится переопределить поведение в классе 
 ``$\inbr{show_{expr}}$''? Согласно подходу, определенному выше, на необходимо отнаследоваться от ``$\inbr{show_{expr}}$'', переопределить некоторые метода и сконструировать функцию с помощью комбинатора неподвижной точки:

\begin{lstlisting}
class custom_show fself = object 
  inherit $\inbr{show_{expr}}$ fself
  method $\inbr{Const}$ $\iota$ x n = "a constant"
end

let custom_show e = 
  fix $\inbr{gcata_{expr}}$ (fun fself -> new custom_show fself) () e
\end{lstlisting}

А это не будет работать так, как мы ожидаем, потому мы не определили метод
``$\inbr{LocalDef}$'', который использует класс по умолчанию для типа  ``\lstinline{def}'', который в свою очередь пользуется классом по умолчанию для типа  ``\lstinline{expr}''.
Получается, что мы переопределили поведение только одной компоненты взаимно рекурсивного преобразования типов, а именно для типа ``\lstinline{expr}''. 
Все вхождения типа ``\lstinline{expr}'' в других типах всё ещё преобразуются стандартным образом. Чтобы исправить это поведение, нам придется повторить реализацию взаимно рекурсивных классов \emph{целиком}, что обесценивает всю идею расширяемости.

Наше решение проблемы снова полагается на идею открытой рекурсии. Вкратце, мы параметризируем конкретный класс преобразования трансформациями \emph{всех} типов, участвующих во взаимно рекурсивном определении типов.
так как эта параметризация нарушает соглашение об интерфейсах классов, нам придется объявить эти классы как дополнительные. Для нашего примера они будут выглядит вот так:

\begin{lstlisting}
class $\inbr{show\_stub_{expr}}$ $f_{expr}$ $f_{def}$ = object 
  inherit [unit, _, string] $\inbr{expr}$ $f_{expr}$
  $\dots$
  method $\inbr{LocalDef}$ $\iota$ x d e = $\dots$ ($f_{def}$ $\dots$) $\dots$
end

class $\inbr{show\_stub_{def}}$ $f_{expr}$ $f_{def}$ = object 
  inherit [unit, _, string] $\inbr{def}$ $f_{def}$
  method $\inbr{Def}$ $\iota$ x s e = $\dots$ ($f_{expr}$ $\dots$) $\dots$
end
\end{lstlisting}

Обратите внимание на отсутствие рекурсивных классов.

Затем мы сгенерируем комбинатор неподвижной точки для этого взаимно рекурсивного определения:

\begin{lstlisting}
let $\inbr{fix_{expr, def}}$ ($c_{expr}$, $c_{def}$) =
  let rec $t_{expr}$ $\iota$ x = $\inbr{gcata_{expr}}$ ($c_{expr}$ $t_{expr}$ $t_{def}$) $\iota$ x
  and $t_{def}$ $\iota$ x = $\inbr{gcata_{def}}$ ($c_{def}$ $t_{expr}$ $t_{def}$) $\iota$ x in
  ($t_{expr}$, $t_{def}$)
\end{lstlisting}

Здесь $c_{expr}$ и $c_{def}$ являются генераторами объектов, которые принимают как параметры функции преобразования всех типов, которые встречаются во взаимно рекурсивном определении. Обратите внимание, что тот же самый комбинатор неподвижной точки может использоваться для того, чтобы сконструировать любое конкретное преобразование для данного взаимно рекурсивного определения типов.

С этими дополнительными классами мы может сконструировать реализации по умолчанию для любого конкретного преобразования:

\begin{lstlisting}
let $\inbr{show_{expr}}$, $\inbr{show_{def}}$ =
  $\inbr{fix_{expr,def}}$ (new $\inbr{show\_stub_{expr}}$, new $\inbr{show\_stub_{def}}$) 
\end{lstlisting}

Эти преобразования по умолчанию, во-первых, должны сохраниться во всех структурах с информацией о типах для соответствующих типов, и во-вторых, используются для создания классов трансформацией, с ожидаемым интерфейсом:

\begin{lstlisting}
class $\inbr{show_{expr}}$ fself = object 
  inherit $\inbr{show\_stub_{expr}}$ fself $\inbr{show_{def}}$ 
end
class $\inbr{show_{def}}$ fself = object 
  inherit $\inbr{show\_stub_{def}}$ $\inbr{show_{expr}}$ fself 
end
\end{lstlisting}

Здесь мы снова сделали взаимно рекурсивные типы неотличимыми от простых (в терминах интерфейсов классов), что позволяет единообразным способом конструировать преобразования этих типов в файлах, где эти типы используются, но не объявлены.

С другой стороны, чтобы расширить имеющееся преобразование, теперь необходимо наследоваться от \emph{дополнительных} классов и использовать специальный комбинатор неподвижной точки.
Для нашего предыдущего неудачного случая преобразование выглядит почти также просто, как и для одиночного объявления типа:

\begin{lstlisting}
let custom_show, _ =
  $\inbr{fix_{expr,def}}$ ((fun $f_{expr}$ $f_{def}$ ->
                  object inherit $\inbr{show\_stub_{expr}}$ $f_{expr}$ $f_{def}$
                    method $\inbr{Const}$ $\iota$ x n = "a constant"
                  end),
                new $\inbr{show\_stub_{def}}$) 
\end{lstlisting}

В конкретной реализации библиотеки мы генерируем мемоизирующий комбинатор неподвижной точки, который следует тому же шаблону, который был описан в разделе ~\ref{memofix}. К тому же, мы сохраняем данный комбинатор в структуре с информацией о типе, чтобы для 
типа ``\lstinline{t}'' этот комбинатор мог быть использован с помощью выражение 
``\lstinline{fix(t)}''. Пользователям, однако, придется держать в уме, что тип является взаимно рекурсивным, чтобы воспользоваться комбинатором правильно.

Однако присутствует одна сложность с поддержкой взаимной рекурсии: мы полагаемся на то свойства, что добавление одной функции преобразования для типа  достаточно, чтобы реализовать открытую рекурсию. Однако, строго говоря, это не так. Например, рассмотрим следующее объявление типа:

\begin{lstlisting}
type ($\alpha$, $\beta$) a = A of $\alpha$ b * $\beta$ b
and  $\alpha$ b = X of ($\alpha$, $\alpha$) a
\end{lstlisting}

В аргументах конструктора ``\lstinline{A}'' мы имеем \emph{различные} параметризации типа ``\lstinline{b}'', и поэтому нам понадобятся \emph{две} функции~--- для``\lstinline{$\alpha$ b}'' и для ``\lstinline{$\beta$ b}''. Однако, тип ``\lstinline{a}'' не является регулярным~--- начав преобразование типа ``\lstinline{($\alpha$, $\beta$) a}'' мы придём к необходимости преобразования значений типов ``\lstinline{($\alpha$, $\alpha$) a}'' и ``\lstinline{($\beta$, $\beta$) a}''.

Следовательно, мы уже отсеяли такие объявления типов. Получается, что взаимно рекурсивные объявления типов являются \emph{существенными} в том смысле, что они не всегда могут быть разделены на два не взаимно рекурсивных определения, а именно, когда каждая пара типов взаимно достижима. Если мы заменим второе объявление типа, скажем, на

\begin{lstlisting}
...
and $\alpha$ b = int
\end{lstlisting}

то мы получим объявление типов, которое не поддерживается у нас. Однако, так как типы ``\lstinline{a}'' и ``\lstinline{b}''  \emph{не являются}
по сути взаимно рекурсивными, то всё определение типов может быть переписано, что уже позволит воспользоваться нашими наработками.



\subsection{Полиморфные вариантные типы}
\label{pv}

Мы считаем поддержку полиморфных вариантных типов~\cite{PolyVar,PolyVarReuse} важной части нашей работы, так как она открывает возможности 
композиционального определения структур данных с возможность объявления композициональных преобразований.
Главным отличием между полиморфными вариантным типами  и алгебраическими, является возможность 
\emph{расширения} объявленных ранее полиморфных вариантных типов путём добавление новых конструкторов или комбинированием нескольких типов в один. 

Нашей задачей является предоставление  \emph{бесшовной} интеграции с обобщенными возможностями. Когда несколько типов будет скомбинированы, мы должны получить все обобщенные возможности простым наследование соответствующих типов.

Как мы сказали ранее, дополнительный параметр  ``$\varepsilon$'' вычисляется в открытую разновидность полиморфного вариантного типа. Следовательно, должно быть разрешено использовать ту же функцию обобщенного преобразования до для более \emph{широкого} типа\footnote{Мы воздерживаемся от использования термина ``подтип'' так как в \textsc{OCaml} нет настоящего подтипирования.}. 
Это может быть достигнуто специфической формой обобщенной функции трансформации, которая производит ``открытие'':

\begin{lstlisting}
let $\inbr{gcata_t}$ $\omega$ $\iota$ subj =
  match subj with
  $\dots$
  | C $\dots$ -> $\omega$#$\inbr{C}$ $\iota$ (match subj with #t as subj -> subj) $\dots$
  $\dots$
\end{lstlisting}

Это выливается в применении методов объекта, представляющего преобразование, к открытой разновидности типа, в то время как обобщенная функция преобразования принимает замкнутый тип.

Если несколько полиморфных вариантных типов объединяются, то обобщенная функция преобразования сопоставляем значение с образцами-типами и передает управление соответствующим обобщенными функциям преобразования.



\end{comment}