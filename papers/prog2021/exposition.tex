% !TeX encoding = windows-1251
\section{Подход с использованием позднего связывания}
\label{sec:expo}

В данном разделе мы представим пример, мотивирующий к использованию позднего связывания; метод реализации для языков, где позднее связывание не поддерживается; а также реализацию с использованием нашего подхода

Рассмотрим стандартное представление лямбда-выражений и поставим задачу написания интерпретатора лямбда выражения, использую различные стратегии вычислений.

\begin{lstlisting}
type lam =
| Var of string
| Abs of string * lam
| App of lam *lam
\end{lstlisting}

\begin{comment}
В этом разделе мы постепенно представим наш подход используя несколько примеров. 
Хотя изложение не предоставляет конкретных деталей и не может использоваться как точная спецификация,
мы здесь предоставляем основные составляющие решения и мотивацию, которая привела к ним.
Далее мы будет использовать следующее соглашение: будем обозначать $\inbr{\dots}$ представление некоторого понятия в конкретном синтаксисе языка \textsc{OCaml}. Например, ``$\inbr{f_t}$`` является обозначением конкретной функции индексированной типом  ``$f$'' для типа ``$t$''. 
В конкретном синтаксисе оно может быть выражено как ``\lstinline{f_t}'', но мы пока воздержимся от указания конкретной формы.
\end{comment}

%Начнем с простого примера. 
%Рассмотрим объявление типа арифметических выражений:
%
%\begin{lstlisting}
%type expr =
%| Const of int
%| Var   of string
%| Binop of string * expr * expr
%\end{lstlisting}

Распространенные стратегии вычисления лямбда выражений (call-by-name, call-by-value, applicative order, normal order) различаются в двух аспектах: 1) редуцируем под лябмда-абстракцией или нет; 2) как именно выячисляем применение одного выражения к другому. При стандартном способе реализации с помощью сопоставления с образцом нам пришлось бы повторять реализацию для некоторых конструкторов заново. Сейчас мы сэмулируем позднее связывание с помощью структур (records) языка OCaml, чтобы сократить размер кода.


\begin{lstlisting}
type strategy = 
  { on_var : strategy -> string -> lam 
  ; on_abs : strategy -> string -> lam -> lam 
  ; on_app : strategy -> lam -> lam -> lam 
  }
\end{lstlisting}

При таком подходе каждый метод принимает  текущую стратегию вычислений (аналог \texttt{this}), чтобы сэмулировать позднее при вызове преобразований подтермов.
\begin{lstlisting}
let apply_strat st = function
  | Var name -> st.on_var st name
  | Abs (x, b) -> st.on_abs st x b
  | App (l, r) -> st.on_app st l r
\end{lstlisting}
Функция применения стратегии реализуется раз и навсегда для всех стратегий.

\begin{lstlisting}
let reduce_under_abstraction st x b =
  Abs (x, apply_strat st b)
let no_reduce_under_abstraction _ x b = 
  Abs (x, b)
\end{lstlisting}

Функции для произведения вычислений под абстракцией реализуются прямолинейно и должны иметь такой же тип, как у поля \lstinline{on_var} в в структуре \lstinline{strategy}.

\begin{lstlisting}
let no_strat =
  let on_var _ name = Var name in
  let on_abs _ name body = 
    Abs (name, body) in
  let on_app _ l r = App (l, r) in
  { on_var; on_abs; on_app }
\end{lstlisting}
Стратегия~\lstinline{no_strat}, которая не производит никаких вычислений, будет служить заготовкой для реализации других стратегий.

\begin{lstlisting}
let subst: string * lam -> lam -> lam = ...

let cbv =
  let on_app st f arg =
    match apply_strat st f with
    | Abs (x, e) -> 
        apply_strat st (subst (x, arg) e)
    | f2 -> App (f2, arg)
  in
  { no_strat with on_app }
\end{lstlisting}

%TODO: subst

Стратегия \lstinline{cbv} (вызов по значению) отличается от \lstinline{no_strat} только тем, как она вычисляет применение. Как хорошо видно, было произведено изменение обработки конструктора \lstinline{App}, обработка двух других явно не описывалась.

\begin{lstlisting}
let ao_strat =
  { cbv_strat with 
    on_abs = reduce_under_abstraction }
\end{lstlisting}

Аппликативный порядок вычислений отличается от вызова по значению только способом вычисления абстракции, поэтому мы произвели изменения только с полем \lstinline{on_abs}.

Данный вид эмуляции позднего связывания используется в компиляторе OCaml как способ коротко описывать преобразования абстрактного синтаксического дерева OCaml. Там он реализован в ручную без использования генеративных процедур. Также его можно без особых усилий перенести в нефункциональные языки программирования, например Си.

Этот вид эмуляции обладает некоторыми недостатками. Во-первых, количество "методов" в структуре  определено заранее и поэтому различные дополнительные функции, свойственные преобразованиям (например, \lstinline{subst}), необходимо использовать заранее. Также в данном подходе изменять методы необходимо по одному, а при их большом количестве это может привести к ненужным ошибками.

Подход, предлагаемый в данной работе, побеждает эти два недостатка путём использования структурно типизированных \emph{объектов} \ocaml, вместо структур.

\begin{lstlisting}
class no_under_abs = object
  method on_Var v = Var v 
  method on_Abs x b = Abs (x, b)
end
\end{lstlisting}

Реализация класса \lstinline{no_under_abs} определяет преобразования для переменных и абстракций, но даже никак не требует  наличия метода, для обработки применения.

\begin{lstlisting}
class cbv_part fself = object(self)
  method private subst 
    : string*lam -> lam -> lam 
    = ...
  method on_App f arg = 
    match fself f  with
    | Abs (x, e) -> 
        fself (subst (x, arg) e)
    | f2 -> App (f2, arg)
end
\end{lstlisting}

Суть вызова по значению описана в классе \lstinline{cbv}, который определяет способ редукции применения, а также метод \lstinline{subst} для осуществления подстановки. Этот класс никак не требует объявленных методов для вычисления имён переменных и лямбда-абстракции.

\begin{lstlisting}
class cbv fself = object
  inherit no_under_abs
  inherit cbv_part fself
end
\end{lstlisting}

Полноценная реализация вызова по значению может быть получена путём наследования двух классов.

\begin{lstlisting}
let gcata tr = function 
| Var v -> tr#on_Var v 
| Abs (x,b) -> tr#on_Abs x b 
| App (l,r) -> tr#on_App l r

let eval_cbv e =
  let rec eval e = 
    gcata (new cbv eval) e 
  in
  eval e
\end{lstlisting}

Аналогом функции \lstinline{apply_strat} здесь выступает \lstinline{gcata} (generic catamorphism). Аргумент \lstinline{fself} класса \lstinline{cbv} является финальной трансформацией лямбда-выражения и получается ``завязыванием в узел'' реализации функции \lstinline{eval_cbv}. Мотивация к данному решению, а также причина, по которой метод \lstinline{subst} был сделан абстрактным, будут разобрана в разделе ~\cite{related}.

Таким образом путём использования структурно типизированных объектов, которые естесственным образом реализую позднее связывание, мы получили возможность описывать части преобразований арифместического выражения отдельно друг от друга, а также способ композировать части преобразований с помощью наследования.




\section{Дальше не читать, но по плану:}
\section{Формальное изложение}
\section{Сравнение с visitors}
\section{Заключение}

Рекурсивная функция ``$\inbr{show_{expr}}$'' (наиболее естественный кандидат на реализацию)
преобразует выражение в строку: 

\begin{lstlisting}
let rec $\inbr{show_{expr}}$ = function
| Const  n         -> "Const " ^ string_of_int n
| Var    x         -> "Var " ^ x
| Binop (op, l, r) ->
  Printf.sprintf "Binop (%S, %s, %s)" 
                 op ($\inbr{show_{expr}}$ l) ($\inbr{show_{expr}}$ r)
\end{lstlisting}

Представление, возвращаемое ``$\inbr{show_{expr}}$'', сохраняет имена конструкторов. Оно может быть
полезно при отладке или сериализации. Однако, как правило, также требуется иное, ``красивое''(\emph{pretty-printed}) представление. 
В этом представлении выражение представляется в ``естественном синтаксисе'' с использованием инфиксных операций и без имён 
конструкторов, где скобки расставлены только там, где они действительно нужны. Мы можем реализовать это преобразование 
очень просто:

\begin{lstlisting}
let $\inbr{pretty_{expr}}$ e =
  let rec pretty_prio p = function
  | Const  n        -> string_of_int n
  | Var    x        -> x
  | Binop (o, l, r) ->
    let po = prio o in
    (if po <= p then br else id) @@
    pretty_prio po l ^ " " ^ o ^ " " ^ pretty_prio po r
  in
  pretty_prio min_int e
\end{lstlisting}

Здесь мы пользуемся функциями ``\lstinline{prio}'', ``\lstinline{br}'' и ``\lstinline{id}'', доступными из вне. Функция ``\lstinline{prio}''
возвращает приоритет бинарной операции, ``\lstinline{br}'' окружает свой аргумент скобками, а ``\lstinline{id}'' --- тождественная функция.
Дополнительная функция ``\lstinline{pretty_prio}'' принимает числовой параметр, который обозначает приоритет окружающей операции (если такая имеется). Если приоритет текущей операции меньше или равен переданному, тогда выражение окружается скобками. Для простоты мы считаем, что все операции неассоциативны, но такой же шаблон кода может быть использован для поддержки ассоциативных операций.
На верхнем уровне мы передаем наименьшее возможное число как приоритет, чтобы убедиться, что мы не получим скобок, окружающих выражение целиком 

Реализации этих двух функций имеют очень мало общего. Обе возращают строки, но вторая принимает дополнительный аргумент, и 
правые части сопоставления с образцом для соответствующих конструкторов различаются. Единственной общей частью является
сопоставление с образцом само по себе. Мы может извлечь его в отдельную функцию и параметризовать эту функцию множеством трансформаций, 
соответствующих конструкторам:

\begin{lstlisting}
let $\inbr{gcata_{expr}}$ $\omega$ $\iota$ = function
| Const n         -> $\omega$#$\inbr{Const}$ $\iota$ n
| Var   x         -> $\omega$#$\inbr{Var}$   $\iota$ x
| Binop (o, l, r) -> $\omega$#$\inbr{Binop}$ $\iota$ o l r
\end{lstlisting}

Здесь мы представляем множество семантически связанных функций объектом. ``$\omega$'' -- это объект, где методы соответствуют конструктором
один к одному. ``$\iota$'' представляет дополнительный параметр, который может использоваться функциями как, например, ``$\inbr{pretty_{expr}}$'' (и игнорироваться функциями на подобие ``$\inbr{show_{expr}}$'').

Упомянутая в начале функция ``$\inbr{show_{expr}}$'' может быть выражена следующим образом\footnote{Для ясности понимания мы опустили некоторые аннотации типов, которые помогают этому листингу кода пройти проверку типов.}:

\begin{lstlisting}
let rec $\inbr{show_{expr}}$ e = $\inbr{gcata_{expr}}$
  object
    method $\inbr{Const}$ _ n   = "Const " ^ string_of_int n
    method $\inbr{Var}$  $\enspace$   _ x   = "Var " ^ x
    method $\inbr{Binop}$ _ o l r =
      Printf.sprintf "Binop (%S, %s, %s)" 
                     o ($\inbr{show_{expr}}$ l) ($\inbr{show_{expr}}$ r)
  end
  ()
  e
\end{lstlisting}

И, разумеется, всё то же  самое применимо к функции $\inbr{pretty_{expr}}$.

Вы могли заметить, что оба объекта, необходимые для реализации этих функций, могут быть созданы с помощью общего виртуального класса:

\begin{lstlisting}
class virtual [$\iota$, $\sigma$] $\inbr{expr}$ =
object
  method virtual $\inbr{Const}$ : $\iota$ -> int -> $\sigma$
  method virtual $\inbr{Var}\enspace\;\;$ : $\iota$ -> string -> $\sigma$
  method virtual $\inbr{Binop}$ : $\iota$ -> string -> expr -> expr -> $\sigma$  
end
\end{lstlisting}

Конкретный класс, представляющий преобразование будет наследоваться от этого общего предка. Чтобы иметь возможность 
вызывать рекурсивно данное преобразование, мы параметризуем класс функцией самотрансформации ``\lstinline{fself}'' 
(\emph{открытая рекурсия}). 
Написание в стиле открытой рекурсии необходимо для возможности поддержки полиморфных вариантных типов и рекурсивных определений.
Теперь мы сможем реализовать логику распечатки в формат, удобный человеку, в изоляции, отдельно от функции ``красивой'' распечатки
 (обратите внимание на использование ``\lstinline{fself}''):

\begin{lstlisting}
class $\inbr{pretty_{expr}}$ (fself : $\iota$ -> expr -> $\sigma$) = object 
  inherit [int, string] $\inbr{expr}$ 
  method $\inbr{Const}$ p n = string_of_int n
  method $\inbr{Var}$ p x = x
  method $\inbr{Binop}$ p o l r =
    let po = prio o in
    (if po <= p then fun s -> "(" ^ s ^ ")" else fun s -> s) @@
    fself po l ^ " " ^ o ^ " " ^ fself po r
end
\end{lstlisting}

Функция распечатки в удобный человеку формат может быть легко описана с использованием класса выше и функции обобщенной 
трансформации\footnote{Так как имена функции и классов находятся в разных пространствах имен в \textsc{OCaml}, мы может 
использовать одно и то же имя для класса и функции трансформации.}:

\begin{lstlisting}
let $\inbr{pretty_{expr}}$ e =
  let rec pretty_prio p e = 
    $\inbr{gcata_{expr}}$ (new $\inbr{pretty_{expr}}$ pretty_prio) p e 
  in
  pretty_prio min_int e
\end{lstlisting}

Также мы может избежать объявления вложенной функции с помощью комбинатора неподвижной точки ``\lstinline{fix}'':

\begin{lstlisting}
let $\inbr{pretty_{expr}}$ e =
  fix (fun fself p e -> $\inbr{gcata_{expr}}$ (new $\inbr{pretty_{expr}}$ fself) p e)
      min_int e
\end{lstlisting}

Выше мы смогли выделить две общие части для двух существенно различных преобразований: функцию обобщенного обхода
(``$\inbr{gcata_{expr}}$'') и такой виртуальный класс (``$\inbr{expr}$''), что все трансформации можно представить как его экземпляры.
Но стоило ли это того? В действительности, в этом примере мы добились не очень большого переиспользования кода путём добавления
большого количества абстракций. Итоговый код получился по размеру даже больше исходного.

Мы утверждаем, что преобразования в данном конкретном случае были недостаточно обобщенные. Чтобы оправдать описанный подход,
давайте рассмотрим более оптимистичный сценарий. Широко известно, что многие трансформации могут быть представлены 
(по понятным причинам) как \emph{катаморфизмы}, т.е. как ``свёртки''~\cite{Fold,Bananas,CalculatingFP}. 
Формально, чтобы определить канонический катаморфизм нам нужно абстрагировать тип ``\lstinline{expr}'' 
от самого себя и описать функтор, но здесь мы воспользуемся более легковесным решением:

\begin{lstlisting}
class [$\iota$] $\inbr{fold_{expr}}$ (fself : $\iota$ -> expr -> $\iota$) = object 
  inherit [$\iota$, $\iota$] $\inbr{expr}$ 
  method $\inbr{Const}$ i n = i
  method $\inbr{Var}$ i x = i
  method $\inbr{Binop}$ i o l r = fself (fself i l) r
end
\end{lstlisting}

Эта реализация просто передает ``\lstinline{i}'' сквозь все узлы трансформируемого значения, что выглядит довольно бесполезно на первый взгляд.
Однако, слегка изменив поведение, можно получить кое-что полезное:

\begin{lstlisting}
let fv e =
  fix (fun fself i e ->
        $\inbr{gcata_{expr}}$ (object inherit [string list] $\inbr{fold_{expr}}$ fself
                      method $\inbr{Var}$ i x = x :: i
                    end) i e
      ) [] e
\end{lstlisting}

Эта функция создает список всех свободных переменных в выражении, а так как в языке выражений нет способа связывать переменные, 
то это просто список всех переменных в терме. Объект, который мы сконструировали, наследуется от ``бесползеного'' класса ``$\inbr{fold_{expr}}$'' и переопределяет только один метод -- метод для обработки переменных.
Весь остальной код уже работает так, как нам нужно~--- ``$\inbr{gcata_{expr}}$'' обходит выражение, 
а остальные метода объекта аккуратно передают построенный список дальше.
Таким образом, мы смогли реализовать интересное преобразование с помощью очень малой модификации существующего кода, 
предоставленного уже имеющимся классом ``$\inbr{fold_{expr}}$''. Чтобы избежать впечатления, что мы аккуратно подготавливались к
представлению именно этого примера, мы покажем ещё один:

\begin{lstlisting}
let height e =
  fix (fun fself i e ->
        $\inbr{gcata_{expr}}$ 
          (object 
            inherit [int] $\inbr{fold_{expr}}$ fself
            method $\inbr{Binop}$ i _ l r = 1 + max (fself i l) (fself i r) 
          end) 
          i 
          e
      ) 0 e
\end{lstlisting}

Здесь мы вычисляем высоту дерева выражения, используя тот же самый класс ``$\inbr{fold_{expr}}$'' как базовый для другого самостоятельно объекта, переопределяем метод для бинарного оператора, который теперь будет вычислять высоты поддеревьев, выбирать из них максимальную высоту и прибавлять единицу.

Одной из других всеми известных обобщенных функций является ``map'':

\begin{lstlisting}
class $\inbr{map_{expr}}$ fself = object 
  inherit [unit, expr] $\inbr{expr}$
  method $\inbr{Var}$ _ x = Var x
  method $\inbr{Const}$ _ n = Const n
  method $\inbr{Binop}$ _ o l r = Binop (o, fself () l, fself () r)
end
\end{lstlisting}

Опять, так как нам не известно, что ``\lstinline{expr}'' -- это функтор, то всё, что мы можем сделать в функции ``$\inbr{map_{expr}}$'' --- 
это копированиею. Однако, отнаследовавшись от этого класса, мы может получить новый вид преобразований:

\begin{lstlisting}
class simplify fself = object 
  inherit $\inbr{map_{expr}}$ fself
  method $\inbr{Binop}$ _ o l r =
    match fself () l, fself () r with
    | Const l, Const r -> Const ((op o) l r)
    | l      , r       -> Binop (o, l, r)     
end
\end{lstlisting}

Данный класс проводит упрощение выражения: если оба аргумента бинарной операции вычисляются в константу той же самой трансформацией, тогда 
мы может произвести операцию сразу. Функция ``\lstinline{op}'' объявлена где-то ещё, она возвращает функцию, которая будет производить вычисление данного бинарного оператора.

Вот ещё один пример:

\begin{lstlisting}
class substitute fself state = object 
  inherit $\inbr{map_{expr}}$ fself
  method $\inbr{Var}$ _ x = Const (state x)  
end
\end{lstlisting}

Здесь мы выполняем подстановку переменных в выражении на значения, определенные в некотором состоянии, представленном функций ``\lstinline{state}''. Два класса, объявленных выше могут быть скомбинированы для получения интерпретатора выражений:

\begin{lstlisting}
class eval fself state =  object
  inherit substitute fself state
  inherit simplify   fself
end

let eval state e =
  fix (fun fself i e -> $\inbr{gcata_{expr}}$ (new eval fself state) i e) () e  
\end{lstlisting}

Во всех примерах мы выбрали достаточно стандартные преобразования и можно сказать, что реализовали всё достаточно малыми усилиями,
если закрыть глаза на несколько многословный синтаксис классов и объектов в  \textsc{OCaml}. В каждом случае было необходимо переопределить
только один метод и воспользоваться функцией, однозначно получаемой по типу. 
С другой стороны, мы работали с очень просто устроенным типом, он даже не был полиморфным, а поддержка полиморфизма может привести к 
специфически проблемам. В оставшейся части статьи мы покажем, что идеи, представленные выше, может быть расширены до подхода к обобщенному программированию, где все компоненты могут быть синтезированы из объявления типа. В частности, наш подход предоставляет полную поддержку:

\begin{itemize}
\item полиморфизма;
\item применения типовых операторов (type operators);
\item взаимной рекурсии, где поддержка воистину \emph{расширяемых} преобразований потребует некоторых усилий;
\item полиморфных вариантных типов, с которыми будет необходимо позаботиться о гладкой интеграции возможностей полиморфных вариантом и наследования классов;
\item раздельной компиляции --- мы можем сгенерировать код по определениям типов не заглядывая внутрь модулей, от которых зависит обрабатываемый тип;
\item инкапсуляции, а именно поддержки сигнатур модулей, включая абстрактные типы и приватные определения. Обобщенные функции для абстрактных типов могут использоваться из вне модуля, но не позволят инспектировать или изменять содержимое абстрактного типа.
\end{itemize}

Что касается вопросов производительности, то как Вы могли заметить, во всех примерах мы создавали большое количество 
\emph{идентичных} объектов во время преобразования (под одному на каждый узел структуры данных). Далее мы увидим, что с этим можно побороться
с помощью мемоизации. Наконец, наш подход предоставляет система плагинов, которые могут быть использованы для генерации большого количества преобразований, как, например, ``\lstinline{show}'', ``\lstinline{fold}'' или ``\lstinline{map}''. Система плагинов расширяема, т.е. пользователи могут  реализовать их собственные плагины с помощью небольших усилий, так большая часть функциональности по обходу структуры данных предоставляется библиотекой. 


\blockquote{Выкинуть/перенести\\
Одним из важных наблюдений, которые спровоцировали разработку, является то, что многие обобщенные функции можно рассматривать как модификации некоторых других обобщенных функций. Наш подход, являясь генеративным (мы создаем функции на основе объявлений типов), также позволяет конечным пользователям легко получать новые преобразования видоизменяя некоторые части уже имеющихся. Это достигается путём кодирования конструкторов один к одному в методы классов, что несколько напоминает подход, называемый алгебрами объектов~\cite{ObjectAlgebras}.

Отличительным особенностями нашего подхода являются:

\begin{itemize}
\item каждое преобразование выражается с помощью \emph{функции преобразования} и \emph{объекта преобразования}, которые содержат в себе ``интересные'' части преобразования;
\item функция преобразования уникально для данного типа и всех объектов преобразования, которые являются образцами уникального класса;
\item и функция преобразования, и класс генерируются из объявления типа; мы поддерживаем регулярные алгебраические типы данных, структуры, полиморфные вариантные типы и базовые заранее описанные типы;
\item мы предоставляем несколько плагинов, для того, чтобы генерировать практически полезные преобразования в виде конкретных классов;
\item система плагинов расширяема -- программист может реализовать свои собственные плагины.
\end{itemize}



Изначальной идеей данной работы было совмещение комбинаторов и объектно-ориентированного подхода: первый позволит делать реализовать параметризацию удобным образом, а второй предоставит расширяемость за счет позднего связывания (late binding). Идея в виде конкретного шаблона проектирования была успешно апробирована~\cite{SCICO}, а затем реализована в виде библиотеки и синтаксического расширения~\cite{TransformationObjects}. Последующий опыт, связанный с разработкой библиотеки~\cite{OCanren}, снова указал на некоторые недостатки в реализации. В данной работе представляется почти полностью переписанная реализация, где найденные недостатки были исправлены.
}

Оставшаяся часть работы организована следующим образом. В разделе~\cite{section2} мы покажем способ эмуляции позднего связывания для языков программирования, где его нет, а также покажем покажем как использование \GT~улучшает ситуацию. 
В разделе \ref{sec:relatedworks} обсудим аналогичные подходы и библиотеки и сравнимся с ними. В последнем разделе \ref{sec:futurework} укажем направления для дальнейшего развития.
\begin{comment}
 В следующем разделе \ref{sec:expo} мы неформально опишем наш подход с помощью примеров. Затем \ref{sec:implementation} опишем реализацию в деталях, подчеркнув аспекты, которые считаем важными или интересными. Далее представим несколько примеров, реализованных \ref{sec:examples} с помощью нашей библиотеки. В разделе \ref{sec:relatedworks} обсудим аналогичные подходы и библиотеки и сравнимся с ними. В последнем разделе \ref{sec:futurework} укажем направления для дальнейшего развития.
\end{comment}

