\section{Неформальное описание}
\label{sec:expo}

В этом разделе мы постепенно представим наш подход используя несколько примеров. 
Хотя изложение не предоставляет конкретных деталей и не может использоваться как точная спецификация,
мы здесь предоставляем основные составляющие решения и мотивацию, которая привела к ним.
Далее мы будет использовать следующее соглашение: будем обозначать $\inbr{\dots}$ представление некоторого понятия в конкретном синтаксисе языка \textsc{OCaml}. Например, ``$\inbr{f_t}$`` является обозначением конкретной функции индексированной типом  ``$f$'' для типа ``$t$''. 
В конкретном синтаксисе оно может быть выражено как ``\lstinline{f_t}'', но мы пока воздержимся от указания конкретной формы.

Начнем с простого примера. Рассмотрим такое объявление типа арифметических выражений:

\begin{lstlisting}
type expr =
| Const of int
| Var   of string
| Binop of string * expr * expr
\end{lstlisting}

Рекурсивная функция ``$\inbr{show_{expr}}$'' (наиболее естественный кандидат на реализацию)
преобразует выражение в строку: 

\begin{lstlisting}
let rec $\inbr{show_{expr}}$ = function
| Const  n         -> "Const " ^ string_of_int n
| Var    x         -> "Var " ^ x
| Binop (op, l, r) ->
  Printf.sprintf "Binop (%S, %s, %s)" 
                 op ($\inbr{show_{expr}}$ l) ($\inbr{show_{expr}}$ r)
\end{lstlisting}

Представление, возвращаемое ``$\inbr{show_{expr}}$'', сохраняет имена конструкторов. Оно может быть
полезно при отладке или сериализации. Однако, как правило, также требуется иное, ``красивое''(\emph{pretty-printed}) представление. 
В этом представлении выражение представляется в ``естественном синтаксисе'' с использованием инфиксных операций и без имён 
конструкторов, где скобки расставлены только там, где они действительно нужны. Мы можем реализовать это преобразование 
очень просто:

\begin{lstlisting}
let $\inbr{pretty_{expr}}$ e =
  let rec pretty_prio p = function
  | Const  n        -> string_of_int n
  | Var    x        -> x
  | Binop (o, l, r) ->
    let po = prio o in
    (if po <= p then br else id) @@
    pretty_prio po l ^ " " ^ o ^ " " ^ pretty_prio po r
  in
  pretty_prio min_int e
\end{lstlisting}

Здесь мы пользуемся функциями ``\lstinline{prio}'', ``\lstinline{br}'' и ``\lstinline{id}'', доступными из вне. Функция ``\lstinline{prio}''
возвращает приоритет бинарной операции, ``\lstinline{br}'' окружает свой аргумент скобками, а ``\lstinline{id}'' --- тождественная функция.
Дополнительная функция ``\lstinline{pretty_prio}'' принимает числовой параметр, который обозначает приоритет окружающей операции (если такая имеется). Если приоритет текущей операции меньше или равен переданному, тогда выражение окружается скобками. Для простоты мы считаем, что все операции неассоциативны, но такой же шаблон кода может быть использован для поддержки ассоциативных операций.
На верхнем уровне мы передаем наименьшее возможное число как приоритет, чтобы убедиться, что мы не получим скобок, окружающих выражение целиком 

Реализации этих двух функций имеют очень мало общего. Обе возращают строки, но вторая принимает дополнительный аргумент, и 
правые части сопоставления с образцом для соответствующих конструкторов различаются. Единственной общей частью является
сопоставление с образцом само по себе. Мы может извлечь его в отдельную функцию и параметризовать эту функцию множеством трансформаций, 
соответствующих конструкторам:

\begin{lstlisting}
let $\inbr{gcata_{expr}}$ $\omega$ $\iota$ = function
| Const n         -> $\omega$#$\inbr{Const}$ $\iota$ n
| Var   x         -> $\omega$#$\inbr{Var}$   $\iota$ x
| Binop (o, l, r) -> $\omega$#$\inbr{Binop}$ $\iota$ o l r
\end{lstlisting}

Здесь мы представляем множество семантически связанных функций объектом. ``$\omega$'' -- это объект, где методы соответствуют конструктором
один к одному. ``$\iota$'' представляет дополнительный параметр, который может использоваться функциями как, например, ``$\inbr{pretty_{expr}}$'' (и игнорироваться функциями на подобие ``$\inbr{show_{expr}}$'').

Упомянутая в начале функция ``$\inbr{show_{expr}}$'' может быть выражена следующим образом\footnote{Для ясности понимания мы опустили некоторые аннотации типов, которые помогают этому листингу кода пройти проверку типов.}:

\begin{lstlisting}
let rec $\inbr{show_{expr}}$ e = $\inbr{gcata_{expr}}$
  object
    method $\inbr{Const}$ _ n   = "Const " ^ string_of_int n
    method $\inbr{Var}$  $\enspace$   _ x   = "Var " ^ x
    method $\inbr{Binop}$ _ o l r =
      Printf.sprintf "Binop (%S, %s, %s)" 
                     o ($\inbr{show_{expr}}$ l) ($\inbr{show_{expr}}$ r)
  end
  ()
  e
\end{lstlisting}

И, разумеется, всё то же  самое применимо к функции $\inbr{pretty_{expr}}$.

Вы могли заметить, что оба объекта, необходимые для реализации этих функций, могут быть созданы с помощью общего виртуального класса:

\begin{lstlisting}
class virtual [$\iota$, $\sigma$] $\inbr{expr}$ =
object
  method virtual $\inbr{Const}$ : $\iota$ -> int -> $\sigma$
  method virtual $\inbr{Var}\enspace\;\;$ : $\iota$ -> string -> $\sigma$
  method virtual $\inbr{Binop}$ : $\iota$ -> string -> expr -> expr -> $\sigma$  
end
\end{lstlisting}

Конкретный класс, представляющий преобразование будет наследоваться от этого общего предка. Чтобы иметь возможность 
вызывать рекурсивно данное преобразование, мы параметризуем класс функцией самотрансформации ``\lstinline{fself}'' 
(\emph{открытая рекурсия}). 
Написание в стиле открытой рекурсии необходимо для возможности поддержки полиморфных вариантных типов и рекурсивных определений.
Теперь мы сможем реализовать логику распечатки в формат, удобный человеку, в изоляции, отдельно от функции ``красивой'' распечатки
 (обратите внимание на использование ``\lstinline{fself}''):

\begin{lstlisting}
class $\inbr{pretty_{expr}}$ (fself : $\iota$ -> expr -> $\sigma$) = object 
  inherit [int, string] $\inbr{expr}$ 
  method $\inbr{Const}$ p n = string_of_int n
  method $\inbr{Var}$ p x = x
  method $\inbr{Binop}$ p o l r =
    let po = prio o in
    (if po <= p then fun s -> "(" ^ s ^ ")" else fun s -> s) @@
    fself po l ^ " " ^ o ^ " " ^ fself po r
end
\end{lstlisting}

Функция распечатки в удобный человеку формат может быть легко описана с использованием класса выше и функции обобщенной 
трансформации\footnote{Так как имена функции и классов находятся в разных пространствах имен в \textsc{OCaml}, мы может 
использовать одно и то же имя для класса и функции трансформации.}:

\begin{lstlisting}
let $\inbr{pretty_{expr}}$ e =
  let rec pretty_prio p e = 
    $\inbr{gcata_{expr}}$ (new $\inbr{pretty_{expr}}$ pretty_prio) p e 
  in
  pretty_prio min_int e
\end{lstlisting}

Также мы может избежать объявления вложенной функции с помощью комбинатора неподвижной точки ``\lstinline{fix}'':

\begin{lstlisting}
let $\inbr{pretty_{expr}}$ e =
  fix (fun fself p e -> $\inbr{gcata_{expr}}$ (new $\inbr{pretty_{expr}}$ fself) p e)
      min_int e
\end{lstlisting}

Выше мы смогли выделить две общие части для двух существенно различных преобразований: функцию обобщенного обхода
(``$\inbr{gcata_{expr}}$'') и такой виртуальный класс (``$\inbr{expr}$''), что все трансформации можно представить как его экземпляры.
Но стоило ли это того? В действительности, в этом примере мы добились не очень большого переиспользования кода путём добавления
большого количества абстракций. Итоговый код получился по размеру даже больше исходного.

Мы утверждаем, что преобразования в данном конкретном случае были недостаточно обобщенные. Чтобы оправдать описанный подход,
давайте рассмотрим более оптимистичный сценарий. Широко известно, что многие трансформации могут быть представлены 
(по понятным причинам) как \emph{катаморфизмы}, т.е. как ``свёртки''~\cite{Fold,Bananas,CalculatingFP}. 
Формально, чтобы определить канонический катаморфизм нам нужно абстрагировать тип ``\lstinline{expr}'' 
от самого себя и описать функтор, но здесь мы воспользуемся более легковесным решением:

\begin{lstlisting}
class [$\iota$] $\inbr{fold_{expr}}$ (fself : $\iota$ -> expr -> $\iota$) = object 
  inherit [$\iota$, $\iota$] $\inbr{expr}$ 
  method $\inbr{Const}$ i n = i
  method $\inbr{Var}$ i x = i
  method $\inbr{Binop}$ i o l r = fself (fself i l) r
end
\end{lstlisting}

Эта реализация просто передает ``\lstinline{i}'' сквозь все узлы трансформируемого значения, что выглядит довольно бесполезно на первый взгляд.
Однако, слегка изменив поведение, можно получить кое-что полезное:

\begin{lstlisting}
let fv e =
  fix (fun fself i e ->
        $\inbr{gcata_{expr}}$ (object inherit [string list] $\inbr{fold_{expr}}$ fself
                      method $\inbr{Var}$ i x = x :: i
                    end) i e
      ) [] e
\end{lstlisting}

Эта функция создает список всех свободных переменных в выражении, а так как в языке выражений нет способа связывать переменные, 
то это просто список всех переменных в терме. Объект, который мы сконструировали, наследуется от ``бесползеного'' класса ``$\inbr{fold_{expr}}$'' и переопределяет только один метод -- метод для обработки переменных.
Весь остальной код уже работает так, как нам нужно~--- ``$\inbr{gcata_{expr}}$'' обходит выражение, 
а остальные метода объекта аккуратно передают построенный список дальше.
Таким образом, мы смогли реализовать интересное преобразование с помощью очень малой модификации существующего кода, 
предоставленного уже имеющимся классом ``$\inbr{fold_{expr}}$''. Чтобы избежать впечатления, что мы аккуратно подготавливались к
представлению именно этого примера, мы покажем ещё один:

\begin{lstlisting}
let height e =
  fix (fun fself i e ->
        $\inbr{gcata_{expr}}$ 
          (object 
            inherit [int] $\inbr{fold_{expr}}$ fself
            method $\inbr{Binop}$ i _ l r = 1 + max (fself i l) (fself i r) 
          end) 
          i 
          e
      ) 0 e
\end{lstlisting}

Здесь мы вычисляем высоту дерева выражения, используя тот же самый класс ``$\inbr{fold_{expr}}$'' как базовый для другого самостоятельно объекта, переопределяем метод для бинарного оператора, который теперь будет вычислять высоты поддеревьев, выбирать из них максимальную высоту и прибавлять единицу.

Одной из других всеми известных обобщенных функций является ``map'':

\begin{lstlisting}
class $\inbr{map_{expr}}$ fself = object 
  inherit [unit, expr] $\inbr{expr}$
  method $\inbr{Var}$ _ x = Var x
  method $\inbr{Const}$ _ n = Const n
  method $\inbr{Binop}$ _ o l r = Binop (o, fself () l, fself () r)
end
\end{lstlisting}

Опять, так как нам не известно, что ``\lstinline{expr}'' -- это функтор, то всё, что мы можем сделать в функции ``$\inbr{map_{expr}}$'' --- 
это копированиею. Однако, отнаследовавшись от этого класса, мы может получить новый вид преобразований:

\begin{lstlisting}
class simplify fself = object 
  inherit $\inbr{map_{expr}}$ fself
  method $\inbr{Binop}$ _ o l r =
    match fself () l, fself () r with
    | Const l, Const r -> Const ((op o) l r)
    | l      , r       -> Binop (o, l, r)     
end
\end{lstlisting}

Данный класс проводит упрощение выражения: если оба аргумента бинарной операции вычисляются в константу той же самой трансформацией, тогда 
мы может произвести операцию сразу. Функция ``\lstinline{op}'' объявлена где-то ещё, она возвращает функцию, которая будет производить вычисление данного бинарного оператора.

Вот ещё один пример:

\begin{lstlisting}
class substitute fself state = object 
  inherit $\inbr{map_{expr}}$ fself
  method $\inbr{Var}$ _ x = Const (state x)  
end
\end{lstlisting}

Здесь мы выполняем подстановку переменных в выражении на значения, определенные в некотором состоянии, представленном функций ``\lstinline{state}''. Два класса, объявленных выше могут быть скомбинированы для получения интерпретатора выражений:

\begin{lstlisting}
class eval fself state =  object
  inherit substitute fself state
  inherit simplify   fself
end

let eval state e =
  fix (fun fself i e -> $\inbr{gcata_{expr}}$ (new eval fself state) i e) () e  
\end{lstlisting}

Во всех примерах мы выбрали достаточно стандартные преобразования и можно сказать, что реализовали всё достаточно малыми усилиями,
если закрыть глаза на несколько многословный синтаксис классов и объектов в  \textsc{OCaml}. В каждом случае было необходимо переопределить
только один метод и воспользоваться функцией, однозначно получаемой по типу. 
С другой стороны, мы работали с очень просто устроенным типом, он даже не был полиморфным, а поддержка полиморфизма может привести к 
специфически проблемам. В оставшейся части статьи мы покажем, что идеи, представленные выше, может быть расширены до подхода к обобщенному программированию, где все компоненты могут быть синтезированы из объявления типа. В частности, наш подход предоставляет полную поддержку:

\begin{itemize}
\item полиморфизма;
\item применения типовых операторов (type operators);
\item взаимной рекурсии, где поддержка воистину \emph{расширяемых} преобразований потребует некоторых усилий;
\item полиморфных вариантных типов, с которыми будет необходимо позаботиться о гладкой интеграции возможностей полиморфных вариантом и наследования классов;
\item раздельной компиляции --- мы можем сгенерировать код по определениям типов не заглядывая внутрь модулей, от которых зависит обрабатываемый тип;
\item инкапсуляции, а именно поддержки сигнатур модулей, включая абстрактные типы и приватные определения. Обобщенные функции для абстрактных типов могут использоваться из вне модуля, но не позволят инспектировать или изменять содержимое абстрактного типа.
\end{itemize}

Что касается вопросов производительности, то как Вы могли заметить, во всех примерах мы создавали большое количество 
\emph{идентичных} объектов во время преобразования (под одному на каждый узел структуры данных). Далее мы увидим, что с этим можно побороться
с помощью мемоизации. Наконец, наш подход предоставляет система плагинов, которые могут быть использованы для генерации большого количества преобразований, как, например, ``\lstinline{show}'', ``\lstinline{fold}'' или ``\lstinline{map}''. Система плагинов расширяема, т.е. пользователи могут  реализовать их собственные плагины с помощью небольших усилий, так большая часть функциональности по обходу структуры данных предоставляется библиотекой. 
